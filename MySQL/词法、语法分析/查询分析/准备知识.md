- [Query term tree structure](#query-term-tree-structure)
- [æ¦‚å¿µ](#æ¦‚å¿µ)
  - [ç¾åŒ–æ¦‚å¿µ](#ç¾åŒ–æ¦‚å¿µ)
  - [show parse\_tree æŸ¥çœ‹](#show-parse_tree-æŸ¥çœ‹)
- [è§£ææ ‘ å’Œ è¯­æ³•æ ‘](#è§£ææ ‘-å’Œ-è¯­æ³•æ ‘)
  - [è§£ææ ‘](#è§£ææ ‘)
    - [PT\_query\_xxx](#pt_query_xxx)
  - [è¯­æ³•æ ‘](#è¯­æ³•æ ‘)
    - [Query\_term\_xxx](#query_term_xxx)
    - [Query\_result\_xxx](#query_result_xxx)
    - [Query\_block](#query_block)
    - [Query\_expression](#query_expression)
    - [lex ä¸­çš„è¯­æ³•æ ‘ç›¸å…³å˜é‡](#lex-ä¸­çš„è¯­æ³•æ ‘ç›¸å…³å˜é‡)
- [è°“è¯çš„é€‰æ‹©æ€§](#è°“è¯çš„é€‰æ‹©æ€§)
- [å¯å‘å¼](#å¯å‘å¼)
- [æ´¾ç”Ÿè¡¨ã€åˆå¹¶](#æ´¾ç”Ÿè¡¨åˆå¹¶)
  - [å­æŸ¥è¯¢çº§åˆ«](#å­æŸ¥è¯¢çº§åˆ«)
  - [æ€ä¹ˆæ ·å†³å®šæ˜¯å¦åˆå¹¶](#æ€ä¹ˆæ ·å†³å®šæ˜¯å¦åˆå¹¶)
    - [ä¸¾ä¾‹](#ä¸¾ä¾‹)
  - [å…¶å®ƒ](#å…¶å®ƒ)
- [è¡¨å‡½æ•°](#è¡¨å‡½æ•°)
- [ç§»é™¤å†—ä½™æŸ¥è¯¢](#ç§»é™¤å†—ä½™æŸ¥è¯¢)
- [Scalar Subqueries](#scalar-subqueries)
  - [å¦å¤–ä¸€ç§è§£è¯»](#å¦å¤–ä¸€ç§è§£è¯»)
- [MySQL Optimizeå’ŒPlanningé˜¶æ®µ](#mysql-optimizeå’Œplanningé˜¶æ®µ)
  - [è€ä¼˜åŒ–å™¨çš„å…¥å£](#è€ä¼˜åŒ–å™¨çš„å…¥å£)
  - [æ–°ä¼˜åŒ–å™¨çš„å…¥å£](#æ–°ä¼˜åŒ–å™¨çš„å…¥å£)
- [ğ“¢ğ“”ğ“¢ å’Œ ğ“£ğ“”ğ“¢](#ğ“¢ğ“”ğ“¢-å’Œ-ğ“£ğ“”ğ“¢)
- [join çš„ç¬¦å·è¡¨ç¤º](#join-çš„ç¬¦å·è¡¨ç¤º)
- [å…¶å®ƒæ¦‚å¿µçš„æ•°å­¦ç¬¦å·](#å…¶å®ƒæ¦‚å¿µçš„æ•°å­¦ç¬¦å·)
- [transformation](#transformation)
  - [commutativity äº¤æ¢å¾‹](#commutativity-äº¤æ¢å¾‹)
  - [associativity ç»“åˆå¾‹](#associativity-ç»“åˆå¾‹)
  - [asscom äº¤æ¢ç»“åˆå¾‹](#asscom-äº¤æ¢ç»“åˆå¾‹)
- [xx](#xx)

# Query term tree structure

# æ¦‚å¿µ

```
/**
  Query term tree structure. There are five node types, cf. Query_term_type.
  Leaf nodes are Query_block objects. We have three kinds of n-ary set operation
  nodes corresponding to INTERSECT, UNION and EXCEPT. Finally, we have a "unary"
  node which essentially adds a ORDER BY/LIMIT over another node.

  Query blocks serve a dual purpose: they represent the query specification and
  table constructors of the query. As such they are the leaf nodes of the query
  tree.  But they also serve as a way to realize ORDER BY and LIMIT for non-leaf
  nodes, accessed via the function Query_term::query_block().  Therefore, every
  non-leaf node in the tree has a companion Query_block to hold ORDER BY and
  LIMIT information.  For the leaf nodes, which are themselves query blocks, the
  query_block() function just returns a pointer to self, i.e. the leaf nodes
  handle ORDER BY and LIMIT themselves.

  \verbatim
  Example: ((SELECT * FROM t1 UNION SELECT * FROM t2 UNION ALL SELECT * FROM t3
             ORDER BY a LIMIT 5) INTERSECT
            (((SELECT * FROM t3 ORDER BY a LIMIT 4) ) EXCEPT SELECT * FROM t4)
            ORDER BY a LIMIT 4) ORDER BY -a LIMIT 3;

  ->
              m_query_term   +------------------+     slave(s)
              +--------------|-Query_expression |------------------+
              |              +------------------+                  |
              V        post_                                       |
  +-------------------+processing_ +-----------------------+       |
  | Query_term_unary  |block()     |Query_block            |       |
  |                   |----------->|order by -(`a`) limit 3|       |
  +-------------------+            +-----------------------+       |
   |m_children                                                     |
   | +-----------------------+   +----------------------+          |
   | |Query_term_intersect   |   |Query_block           |          |
   +>|last distinct index: 1 |-->|order by `a` limit 4  |          |
     +-----------------------+   +----------------------+          |
      |m_children                                                  |
      |  +-----------------------+   +----------------------+      |
      |  |Query_term_union       |   |Query_block           |      |
      +->|last distinct index: 1 |-->|order by `a`  limit 5 |      |
      |  +-----------------------+   +----------------------+      |
      |    |m_children                                             |
      |    |   +------------+        SELECT * FROM t1             /
      |    +-->|Query_block |  <---------------------------------+
      |    |   +------------+  ----------------------------------+ next
      |    |                                                      \
      |    |   +------------+        SELECT * FROM t2             /
      |    +-->|Query_block |  <---------------------------------+
      |    |   +------------+  ----------------------------------+ next
      |    |                                                      \
      |    |   +------------+        SELECT * FROM t3             /
      |    +-->|Query_block |  <---------------------------------+
      |        +------------+  ----------------------------------+ next
      |                                                           \
      |  +-----------------------+  +------------+                 |
      |  |Query_term_except      |->|Query_block |                 |
      +->|last distinct index: 1 |  +------------+                 |
         +-----------------------+                                 |
           |m_children                                             |
           |   +----------------------+                            |
           |   |Query_block           |      SELECT * FROM t3      /
           +-->|order by `a`  limit 4 |  <------------------------+
           |   +----------------------+  -------------------------+ next
           |                                                       \
           |   +------------+                SELECT * FROM t4      |
           +-->|Query_block | <------------------------------------+
               +------------+
  \endverbatim
  Note that all leaf query blocks representing the query specifications are
  linked under Query_expression via their next pointers. The nesting is achieved
  by the arrows on the left side of the figure, via the nodes' m_children
  members. The four classes Query_term_unary and Query_term_{union, intersect,
  except} are modelled via the base class Query_term_set_op which contains a
  m_children member. Each of these also contain a Query_block which will handle
  its order by and/or limit clauses. These are similar to the old so-called
  "fake_query_block" (which is now gone), and are not linked in with "next"
  pointers.

  The is also a back pointer from the children nodes to the parent Query_term
  object (not shown).

  In the simple case of a single query specification (or table value constructor
  or explicit table), there is no super-structure over the Query_block linked
  from the Query_expression, i.e. Query_expression's m_query_term member is just
  a Query_block.

  The query blocks (QT_QUERY_BLOCK nodes) corresponding to the query
  specification (or table value constructors) are prepared and optimized by
  running over them from the Query_expression via the slave/next pointers as
  before. There are separate methods which handle prepare and optimization for
  non-leaves, i.e. nodes of types QT_UNARY, QT_INTERSECT, QT_EXCEPT and
  QT_UNION.

  We also define an iterator class (Query_terms) for iterating over all
  the nodes in the tree, see also Query_expression::query_terms() for its use.
  When possible, we access all nodes using iterators.

  The built structure can be traced with the debug trace keyword "ast", e.g.
  as SET SESSION debug = 'd,ast:O,/tmp/mysqld.trace';
*/
```

## ç¾åŒ–æ¦‚å¿µ

```sql
(
    (
        SELECT * FROM t1 
        UNION 
        SELECT * FROM t2 
        UNION ALL 
        SELECT * FROM t3            
        ORDER BY a LIMIT 5
    ) 
  
    INTERSECT           
    (
        ((SELECT * FROM t3 ORDER BY a LIMIT 4) ) 
        EXCEPT 
        SELECT * FROM t4
    )
    ORDER BY a LIMIT 4
) ORDER BY -a LIMIT 3



  ->
              m_query_term   +------------------+     slave(s)
              +--------------|-Query_expression |------------------+
              |              +------------------+                  |
              V        post_                                       |
  +-------------------+processing_ +-----------------------+       |
  | Query_term_unary  |block()     |Query_block            |       |
  |                   |----------->|order by -(`a`) limit 3|       |
  +-------------------+            +-----------------------+       |
   |m_children                                                     |
   | +-----------------------+   +----------------------+          |
   | |Query_term_intersect   |   |Query_block           |          |
   +>|last distinct index: 1 |-->|order by `a` limit 4  |          |
     +-----------------------+   +----------------------+          |
      |m_children                                                  |
      |  +-----------------------+   +----------------------+      |
      |  |Query_term_union       |   |Query_block           |      |
      +->|last distinct index: 1 |-->|order by `a`  limit 5 |      |
      |  +-----------------------+   +----------------------+      |
      |    |m_children                                             |
      |    |   +------------+        SELECT * FROM t1             /
      |    +-->|Query_block |  <---------------------------------+
      |    |   +------------+  ----------------------------------+ next
      |    |                                                      \
      |    |   +------------+        SELECT * FROM t2             /
      |    +-->|Query_block |  <---------------------------------+
      |    |   +------------+  ----------------------------------+ next
      |    |                                                      \
      |    |   +------------+        SELECT * FROM t3             /
      |    +-->|Query_block |  <---------------------------------+
      |        +------------+  ----------------------------------+ next
      |                                                           \
      |  +-----------------------+  +------------+                 |
      |  |Query_term_except      |->|Query_block |                 |
      +->|last distinct index: 1 |  +------------+                 |
         +-----------------------+                                 |
           |m_children                                             |
           |   +----------------------+                            |
           |   |Query_block           |      SELECT * FROM t3      /
           +-->|order by `a`  limit 4 |  <------------------------+
           |   +----------------------+  -------------------------+ next
           |                                                       \
           |   +------------+                SELECT * FROM t4      |
           +-->|Query_block | <------------------------------------+
               +------------+
  \endverbatim
```

## show parse_tree æŸ¥çœ‹

![](assets/001.png)

# è§£ææ ‘ å’Œ è¯­æ³•æ ‘
PT_query_xxx å’Œ Query_xxx çš„ä¸»è¦åŒºåˆ«åœ¨äºï¼Œå‰è€…æ˜¯è§£ææ ‘ä¸­çš„èŠ‚ç‚¹ï¼Œå®ƒç›´æ¥å¯¹åº”äºSQLæŸ¥è¯¢çš„æ–‡æœ¬è¡¨ç¤ºï¼Œè€Œåè€…æ˜¯æŠ½è±¡è¯­æ³•æ ‘ä¸­çš„èŠ‚ç‚¹ï¼Œå®ƒå¯¹åº”äºæŸ¥è¯¢çš„é€»è¾‘ç»“æ„ã€‚
## è§£ææ ‘
### PT_query_xxx
https://dev.mysql.com/doc/dev/mysql-server/8.1.0/classPT__query__expression__body__inherit__graph_org.svg

![Alt text](assets/002.png)
## è¯­æ³•æ ‘
### Query_term_xxx
https://dev.mysql.com/doc/dev/mysql-server/8.1.0/classQuery__term__inherit__graph_org.svg

![Alt text](assets/003.png)

### Query_result_xxx
https://dev.mysql.com/doc/dev/mysql-server/8.1.0/classQuery__result__inherit__graph_org.svg

![Alt text](assets/004.png)

### Query_block
This class represents a query block, aka a query specification, which is a query consisting of a SELECT keyword, followed by a table list, optionally followed by a WHERE clause, a GROUP BY, etc
```cpp
class Query_block : public Query_term {  // æŸ¥è¯¢å—ç±»ï¼Œç»§æ‰¿è‡ªæŸ¥è¯¢é¡¹ç±»
public:
    size_t m_added_non_hidden_fields;  // æ·»åŠ çš„ééšè—å­—æ®µæ•°é‡
    mem_root_deque<Item*> fields;  // å­—æ®µåˆ—è¡¨
    List<Window> m_windows;  // çª—å£å‡½æ•°åˆ—è¡¨
    List<Item_func_match> *ftfunc_list;  // å…¨æ–‡æ£€ç´¢å‡½æ•°åˆ—è¡¨æŒ‡é’ˆ
    List<Item_func_match> ftfunc_list_alloc;  // åˆ†é…çš„å…¨æ–‡æ£€ç´¢å‡½æ•°åˆ—è¡¨
    mem_root_deque<mem_root_deque<Item*>*> *row_value_list;  // è¡Œå€¼åˆ—è¡¨
    mem_root_deque<Table_ref*> sj_nests;  // åŠè¿æ¥åµŒå¥—è¡¨å¼•ç”¨åˆ—è¡¨
    SQL_I_List<Table_ref> m_table_list;  // è¡¨åˆ—è¡¨
    SQL_I_List<ORDER> order_list;  // æ’åºåˆ—è¡¨
    Group_list_ptrs *order_list_ptrs;  // æ’åºåˆ—è¡¨æŒ‡é’ˆ
    Opt_hints_qb *opt_hints_qb;  // ä¼˜åŒ–æç¤ºæŸ¥è¯¢å—
    char *db;  // æ•°æ®åº“åç§°
    LEX *parent_lex;  // çˆ¶çº§è¯æ³•åˆ†æå™¨
    table_map select_list_tables;  // é€‰æ‹©åˆ—è¡¨çš„è¡¨æ˜ å°„
    table_map outer_join;  // å¤–è¿æ¥è¡¨æ˜ å°„
    Name_resolution_context context;  // åç§°è§£æä¸Šä¸‹æ–‡
    Name_resolution_context *first_context;  // ç¬¬ä¸€ä¸ªåç§°è§£æä¸Šä¸‹æ–‡
    JOIN *join;  // è¿æ¥
    mem_root_deque<Table_ref*> m_table_nest;  // è¡¨åµŒå¥—åˆ—è¡¨
    mem_root_deque<Table_ref*> *m_current_table_nest;  // å½“å‰è¡¨åµŒå¥—åˆ—è¡¨
    Table_ref *end_lateral_table;  // ç»“æŸçš„Lateralè¡¨
    Item *select_limit;  // é€‰æ‹©é™åˆ¶
    Item *offset_limit;  // åç§»é™åˆ¶
    Item::cond_result cond_value;  // æ¡ä»¶å€¼
    Item::cond_result having_value;  // HAVINGæ¡ä»¶å€¼
    uint select_n_where_fields;  // WHEREå­—æ®µæ•°é‡
    uint select_n_having_items;  // HAVINGé¡¹æ•°é‡
    uint saved_cond_count;  // ä¿å­˜çš„æ¡ä»¶è®¡æ•°
    uint cond_count;  // æ¡ä»¶è®¡æ•°
    uint between_count;  // BETWEENè®¡æ•°
    enum_condition_context condition_context;  // æ¡ä»¶ä¸Šä¸‹æ–‡
    sub_select_type linkage;  // å­æŸ¥è¯¢ç±»å‹
    bool subquery_in_having;  // HAVINGä¸­çš„å­æŸ¥è¯¢
    bool m_use_select_limit;  // ä½¿ç”¨SELECTé™åˆ¶
    bool m_internal_limit;  // å†…éƒ¨é™åˆ¶
private:
    Query_block *next;  // ä¸‹ä¸€ä¸ªæŸ¥è¯¢å—
    Query_expression *master;  // ä¸»æŸ¥è¯¢è¡¨è¾¾å¼
    Query_expression *slave;  // ä»æŸ¥è¯¢è¡¨è¾¾å¼
    Query_block *link_next;  // ä¸‹ä¸€ä¸ªè¿æ¥æŸ¥è¯¢å—
    Query_block **link_prev;  // ä¸Šä¸€ä¸ªè¿æ¥æŸ¥è¯¢å—
    Query_result *m_query_result;  // æŸ¥è¯¢ç»“æœ
public:
    Table_ref *resolve_nest;  // è§£æåµŒå¥—
private:
    Item *m_where_cond;  // WHEREæ¡ä»¶
    Item *m_having_cond;  // HAVINGæ¡ä»¶
    int hidden_group_field_count;  // éšè—çš„åˆ†ç»„å­—æ®µæ•°é‡
    bool has_sj_nests;  // æ˜¯å¦æœ‰åŠè¿æ¥åµŒå¥—
    bool has_aj_nests;  // æ˜¯å¦æœ‰å¤–è¿æ¥åµŒå¥—
    bool m_right_joins;  // å³è¿æ¥
    bool allow_merge_derived;  // å…è®¸åˆå¹¶æ´¾ç”Ÿ
    bool m_agg_func_used;  // èšåˆå‡½æ•°å·²ä½¿ç”¨
    bool m_json_agg_func_used;  // JSONèšåˆå‡½æ•°å·²ä½¿ç”¨
    bool m_empty_query;  // ç©ºæŸ¥è¯¢
    static const char *type_str[13];  // ç±»å‹å­—ç¬¦ä¸²æ•°ç»„
```
### Query_expression
This class represents a query expression (one query block or several query blocks combined with UNION)
```cpp
class Query_expression {
  private:
    Query_expression *next;  // ä¸‹ä¸€ä¸ªæŸ¥è¯¢è¡¨è¾¾å¼
    Query_expression **prev;  // å‰ä¸€ä¸ªæŸ¥è¯¢è¡¨è¾¾å¼çš„æŒ‡é’ˆ
    Query_block *master;  // ä¸»æŸ¥è¯¢å—
    Query_block *slave;  // ä»æŸ¥è¯¢å—
    Query_term *m_query_term;  // æŸ¥è¯¢é¡¹
    enum_parsing_context explain_marker;  // è§£é‡Šæ ‡è®°
    bool prepared;  // æ˜¯å¦å·²å‡†å¤‡å¥½
    bool optimized;  // æ˜¯å¦å·²ä¼˜åŒ–
    bool executed;  // æ˜¯å¦å·²æ‰§è¡Œ
    Query_result *m_query_result;  // æŸ¥è¯¢ç»“æœ
    unique_ptr_destroy_only m_root_iterator;  // å”¯ä¸€çš„æ ¹è¿­ä»£å™¨
    AccessPath *m_root_access_path;  // æ ¹è®¿é—®è·¯å¾„
    Mem_root_array<MaterializePathParameters::QueryBlock> m_query_blocks_to_materialize;  // éœ€è¦å®ä½“åŒ–çš„æŸ¥è¯¢å—æ•°ç»„
  public:
    uint8 uncacheable;  // ä¸å¯ç¼“å­˜çš„æ ‡å¿—
    Query_expression::enum_clean_state cleaned;  // æ¸…ç†çŠ¶æ€
  private:
    mem_root_deque<Item*> types;  // ç±»å‹é˜Ÿåˆ—
  public:
    ha_rows select_limit_cnt;  // é€‰æ‹©é™åˆ¶è¡Œæ•°
    ha_rows offset_limit_cnt;  // åç§»é™åˆ¶è¡Œæ•°
    Item_subselect *item;  // å­æŸ¥è¯¢é¡¹
    PT_with_clause *m_with_clause;
    Table_ref *derived_table;
    Query_block *first_recursive;
    table_map m_lateral_deps;
    bool m_reject_multiple_rows;
    ha_rows send_records;  // å‘é€è®°å½•æ•°
}
```
å›¾è§£
```sql
  select *
  from table1
     where table1.field IN (select * from table1_1_1 union
                            select * from table1_1_2)
     union
   select *
     from table2
     where table2.field=(select (select f1 from table2_1_1_1_1
                                   where table2_1_1_1_1.f2=table2_1_1.f3)
                           from table2_1_1
                           where table2_1_1.f1=table2.f2)
     union
   select * from table3;
 
   we will have following structure:
 
   select1: (select * from table1 ...)
   select2: (select * from table2 ...)
   select3: (select * from table3)
   select1.1.1: (select * from table1_1_1)
   ...
 
     main unit
     select1 select2 select3
     |^^     |^
    s|||     ||master
    l|||     |+---------------------------------+
    a|||     +---------------------------------+|
    v|||master                         slave   ||
    e||+-------------------------+             ||
     V|            neighbor      |             V|
     unit1.1<+==================>unit1.2       unit2.1
     select1.1.1 select 1.1.2    select1.2.1   select2.1.1
                                               |^
                                               ||
                                               V|
                                               unit2.1.1.1
                                               select2.1.1.1.1
 
 
   relation in main unit will be following:
   (bigger picture for:
      main unit
      select1 select2 select3
   in the above picture)
 
         main unit
         |^^^
         ||||
         ||||
         |||+------------------------------+
         ||+--------------+                |
    slave||master         |                |
         V|      neighbor |       neighbor |
         select1<========>select2<========>select3
 
    list of all query_block will be following (as it will be constructed by
    parser):
 
    select1->select2->select3->select2.1.1->select 2.1.2->select2.1.1.1.1-+
                                                                          |
    +---------------------------------------------------------------------+
    |
    +->select1.1.1->select1.1.2
```

### lex ä¸­çš„è¯­æ³•æ ‘ç›¸å…³å˜é‡
```cpp
 public:
   Query_expression *unit;  // æŸ¥è¯¢æ ‘çš„æ ¹èŠ‚ç‚¹
   Query_block *query_block;    // æŸ¥è¯¢å—
   Query_block *all_query_blocks_list;  // æ‰€æœ‰æŸ¥è¯¢å—çš„åˆ—è¡¨
 private:
   Query_block *m_current_query_block;  // å½“å‰æŸ¥è¯¢å—
```

# è°“è¯çš„é€‰æ‹©æ€§
å®ƒæè¿°äº†ä¸€ä¸ªè°“è¯ï¼ˆå³æŸ¥è¯¢æ¡ä»¶ï¼‰èƒ½å¤Ÿè¿‡æ»¤æ‰å¤šå°‘æ•°æ®ã€‚é€‰æ‹©æ€§çš„å€¼èŒƒå›´é€šå¸¸åœ¨0åˆ°1ä¹‹é—´ï¼Œå…¶ä¸­0è¡¨ç¤ºè°“è¯è¿‡æ»¤æ‰æ‰€æœ‰çš„è¡Œï¼ˆå³æ²¡æœ‰è¡Œæ»¡è¶³è¯¥æ¡ä»¶ï¼‰ï¼Œ1è¡¨ç¤ºè°“è¯ä¸è¿‡æ»¤ä»»ä½•è¡Œï¼ˆå³æ‰€æœ‰è¡Œéƒ½æ»¡è¶³è¯¥æ¡ä»¶ï¼‰ã€‚

ä¾‹å¦‚ï¼Œå‡è®¾æˆ‘ä»¬æœ‰ä¸€ä¸ªåŒ…å«1000è¡Œçš„è¡¨ï¼Œè¡¨ä¸­æœ‰ä¸€ä¸ªåä¸ºageçš„åˆ—ã€‚å¦‚æœæˆ‘ä»¬çš„æŸ¥è¯¢æ˜¯SELECT * FROM table WHERE age > 30ï¼Œå¹¶ä¸”è¡¨ä¸­æœ‰250è¡Œçš„ageå€¼å¤§äº30ï¼Œé‚£ä¹ˆè¿™ä¸ªè°“è¯çš„é€‰æ‹©æ€§å°±æ˜¯0.25ï¼ˆå³250/1000ï¼‰ã€‚è¿™æ„å‘³ç€è¿™ä¸ªè°“è¯èƒ½å¤Ÿè¿‡æ»¤æ‰75%çš„æ•°æ®ã€‚

# å¯å‘å¼
æ¯”å¦‚ä½ åœ¨ä¸€ä¸ªå¤§åŸå¸‚ä¸­å¯»æ‰¾ä»ç‚¹Aåˆ°ç‚¹Bçš„æœ€å¿«è·¯å¾„ã€‚æœ€ä¼˜çš„æ–¹æ³•æ˜¯è€ƒè™‘åŸå¸‚ä¸­çš„æ¯ä¸€æ¡è¡—é“ï¼Œä½†è¿™éœ€è¦å¤§é‡çš„æ—¶é—´å’Œè®¡ç®—èµ„æºã€‚ä¸€ä¸ªå¯å‘å¼çš„æ–¹æ³•å¯èƒ½æ˜¯é¿å¼€é‚£äº›ä½ çŸ¥é“å¸¸å¸¸å µè½¦çš„è¡—é“ï¼Œæˆ–è€…é€‰æ‹©é‚£äº›ä½ çŸ¥é“é€šå¸¸æ¯”è¾ƒç•…é€šçš„è¡—é“ã€‚è¿™ç§æ–¹æ³•å¯èƒ½ä¸ä¼šç»™ä½ æœ€å¿«çš„è·¯å¾„ï¼Œä½†æ˜¯ä¼šåœ¨åˆç†çš„æ—¶é—´å†…ç»™ä½ ä¸€ä¸ªå¥½çš„è·¯å¾„ã€‚è¿™å°±æ˜¯å¯å‘å¼çš„ä¸€ä¸ªä¾‹å­ã€‚

# æ´¾ç”Ÿè¡¨ã€åˆå¹¶
```sql
SELECT * FROM (SELECT * FROM orders WHERE order_date > '2023-01-01') as derived_table;
```
åœ¨è¿™ä¸ªæŸ¥è¯¢ä¸­ï¼Œderived_tableæ˜¯ä¸€ä¸ªæ´¾ç”Ÿè¡¨ï¼Œå®ƒæ˜¯é€šè¿‡å­æŸ¥è¯¢åˆ›å»ºçš„ã€‚å¦‚æœä¸è¿›è¡Œåˆå¹¶ï¼Œæ•°æ®åº“éœ€è¦å…ˆæ‰§è¡Œå­æŸ¥è¯¢ï¼Œå°†ç»“æœå­˜å‚¨åœ¨ä¸€ä¸ªä¸´æ—¶è¡¨derived_tableä¸­ï¼Œç„¶åå†ä»è¿™ä¸ªä¸´æ—¶è¡¨ä¸­é€‰æ‹©æ‰€æœ‰çš„è®°å½•ã€‚è¿™å°±éœ€è¦é¢å¤–çš„å­˜å‚¨ç©ºé—´æ¥ä¿å­˜ä¸´æ—¶è¡¨ï¼Œè€Œä¸”åœ¨æŸ¥è¯¢è¿‡ç¨‹ä¸­éœ€è¦è¿›è¡Œé¢å¤–çš„è¯»å†™æ“ä½œï¼Œè¿™å¯èƒ½ä¼šé™ä½æŸ¥è¯¢æ•ˆç‡ã€‚

ä½†æ˜¯ï¼Œå¦‚æœæˆ‘ä»¬å°†æ´¾ç”Ÿè¡¨åˆå¹¶åˆ°ä¸»æŸ¥è¯¢ä¸­ï¼Œé‚£ä¹ˆæŸ¥è¯¢å°±å¯ä»¥ç›´æ¥å˜ä¸ºï¼š
```sql
SELECT * FROM orders WHERE order_date > '2023-01-01';
```
## å­æŸ¥è¯¢çº§åˆ«
å¦‚æœä¸€ä¸ªå­æŸ¥è¯¢æ˜¯åœ¨ä¸»æŸ¥è¯¢çš„SELECTã€FROMã€WHEREæˆ–HAVINGå­å¥ä¸­å®šä¹‰çš„ï¼Œé‚£ä¹ˆè¿™ä¸ªå­æŸ¥è¯¢å°±æ˜¯ç¬¬ä¸€çº§å­æŸ¥è¯¢  
ä¾‹å¦‚ï¼š
```sql
SELECT order_id, (SELECT COUNT(*) FROM order_items WHERE order_id = o.order_id) as item_count
FROM orders o;
```

å¦‚æœä¸€ä¸ªå­æŸ¥è¯¢æ˜¯åœ¨å¦ä¸€ä¸ªå­æŸ¥è¯¢ä¸­å®šä¹‰çš„ï¼Œé‚£ä¹ˆè¿™ä¸ªå­æŸ¥è¯¢å°±ä¸æ˜¯ç¬¬ä¸€çº§å­æŸ¥è¯¢  
ä¾‹å¦‚ï¼š
```sql
SELECT * FROM (SELECT order_id, (SELECT COUNT(*) FROM order_items WHERE order_id = o.order_id) as item_count
FROM orders o) as derived_table;
```
åœ¨è¿™ä¸ªæŸ¥è¯¢ä¸­ï¼Œ(SELECT COUNT(*) FROM order_items WHERE order_id = o.order_id)å°±ä¸æ˜¯ç¬¬ä¸€çº§å­æŸ¥è¯¢ï¼Œå› ä¸ºå®ƒæ˜¯åœ¨å¦ä¸€ä¸ªå­æŸ¥è¯¢ä¸­å®šä¹‰çš„ã€‚

## æ€ä¹ˆæ ·å†³å®šæ˜¯å¦åˆå¹¶
    Determine whether it is suggested to merge immediate derived tables, based
    on the placement of the query block:
      - DTs belonging to outermost query block: always
      - DTs belonging to first level subqueries: Yes if inside SELECT statement,
        no otherwise (including UPDATE and DELETE).
        This is required to support a workaround for allowing subqueries
        containing the same table as is target for delete or update,
        by forcing a materialization of the subquery.
      - All other cases inherit status of parent query block.
### ä¸¾ä¾‹
å‡è®¾æˆ‘ä»¬æœ‰ä¸€ä¸ªæŸ¥è¯¢ï¼Œå…¶ä¸­åŒ…å«ä¸€ä¸ªå­æŸ¥è¯¢ï¼Œè¿™ä¸ªå­æŸ¥è¯¢åˆåŒ…å«ä¸€ä¸ªæ´¾ç”Ÿè¡¨ï¼ˆDTï¼‰ï¼š

```sql
SELECT * FROM (SELECT * FROM orders WHERE order_date > '2023-01-01') as derived_table;
```

åœ¨è¿™ä¸ªä¾‹å­ä¸­ï¼Œ`derived_table`å°±æ˜¯ä¸€ä¸ªç›´æ¥æ´¾ç”Ÿçš„è¡¨ï¼Œå®ƒå±äºæœ€å¤–å±‚çš„æŸ¥è¯¢å—ï¼Œæ‰€ä»¥æˆ‘ä»¬æ€»æ˜¯å¯ä»¥åˆå¹¶è¿™ä¸ªæ´¾ç”Ÿè¡¨ã€‚

ç°åœ¨ï¼Œå‡è®¾æˆ‘ä»¬æœ‰ä¸€ä¸ªæ›´å¤æ‚çš„æŸ¥è¯¢ï¼Œå…¶ä¸­åŒ…å«ä¸€ä¸ªå­æŸ¥è¯¢ï¼Œè¿™ä¸ªå­æŸ¥è¯¢åˆåŒ…å«ä¸€ä¸ªæ´¾ç”Ÿè¡¨ï¼Œè€Œè¿™ä¸ªå­æŸ¥è¯¢æ˜¯åœ¨ä¸€ä¸ª`SELECT`è¯­å¥ä¸­ï¼š

```sql
SELECT order_id, (SELECT COUNT(*) FROM (SELECT * FROM order_items WHERE order_id = o.order_id) as derived_table) as item_count
FROM orders o;
```

åœ¨è¿™ä¸ªä¾‹å­ä¸­ï¼Œ`derived_table`æ˜¯ä¸€ä¸ªç›´æ¥æ´¾ç”Ÿçš„è¡¨ï¼Œå®ƒå±äºç¬¬ä¸€çº§å­æŸ¥è¯¢ï¼Œå¹¶ä¸”è¿™ä¸ªå­æŸ¥è¯¢æ˜¯åœ¨ä¸€ä¸ª`SELECT`è¯­å¥ä¸­ï¼Œæ‰€ä»¥æˆ‘ä»¬å¯ä»¥åˆå¹¶è¿™ä¸ªæ´¾ç”Ÿè¡¨ã€‚

ç„¶è€Œï¼Œå¦‚æœè¿™ä¸ªå­æŸ¥è¯¢æ˜¯åœ¨ä¸€ä¸ª`UPDATE`æˆ–`DELETE`è¯­å¥ä¸­ï¼Œé‚£ä¹ˆæˆ‘ä»¬å°±ä¸èƒ½åˆå¹¶è¿™ä¸ªæ´¾ç”Ÿè¡¨ã€‚ä¾‹å¦‚ï¼š

```sql
UPDATE orders
SET order_status = 'processed'
WHERE order_id IN (SELECT order_id FROM (SELECT * FROM orders WHERE order_date > '2023-01-01') as derived_table);
```

åœ¨è¿™ä¸ªä¾‹å­ä¸­ï¼Œ`derived_table`æ˜¯ä¸€ä¸ªç›´æ¥æ´¾ç”Ÿçš„è¡¨ï¼Œå®ƒå±äºç¬¬ä¸€çº§å­æŸ¥è¯¢ï¼Œä½†æ˜¯è¿™ä¸ªå­æŸ¥è¯¢æ˜¯åœ¨ä¸€ä¸ª`UPDATE`è¯­å¥ä¸­ï¼Œæ‰€ä»¥æˆ‘ä»¬ä¸èƒ½åˆå¹¶è¿™ä¸ªæ´¾ç”Ÿè¡¨ã€‚

å¯¹äºæ‰€æœ‰å…¶ä»–æƒ…å†µï¼Œæ´¾ç”Ÿè¡¨æ˜¯å¦å¯ä»¥åˆå¹¶ï¼Œå–å†³äºå®ƒæ‰€åœ¨çš„çˆ¶æŸ¥è¯¢å—ã€‚ä¾‹å¦‚ï¼Œå¦‚æœä¸€ä¸ªæ´¾ç”Ÿè¡¨åœ¨ä¸€ä¸ªå­æŸ¥è¯¢ä¸­ï¼Œè€Œè¿™ä¸ªå­æŸ¥è¯¢åˆåœ¨å¦ä¸€ä¸ªå­æŸ¥è¯¢ä¸­ï¼Œé‚£ä¹ˆè¿™ä¸ªæ´¾ç”Ÿè¡¨æ˜¯å¦å¯ä»¥åˆå¹¶ï¼Œå°±å–å†³äºå®ƒçš„çˆ¶æŸ¥è¯¢å—ï¼ˆä¹Ÿå°±æ˜¯å¤–å±‚çš„å­æŸ¥è¯¢ï¼‰æ˜¯å¦å¯ä»¥åˆå¹¶æ´¾ç”Ÿè¡¨ã€‚å¦‚æœçˆ¶æŸ¥è¯¢å—å¯ä»¥åˆå¹¶æ´¾ç”Ÿè¡¨ï¼Œé‚£ä¹ˆè¿™ä¸ªæ´¾ç”Ÿè¡¨ä¹Ÿå¯ä»¥åˆå¹¶ï¼›å¦‚æœçˆ¶æŸ¥è¯¢å—ä¸èƒ½åˆå¹¶æ´¾ç”Ÿè¡¨ï¼Œé‚£ä¹ˆè¿™ä¸ªæ´¾ç”Ÿè¡¨ä¹Ÿä¸èƒ½åˆå¹¶ã€‚ä¾‹å¦‚ï¼š

```sql
SELECT * FROM (SELECT * FROM (SELECT * FROM orders WHERE order_date > '2023-01-01') as derived_table_1) as derived_table_2;
```

åœ¨è¿™ä¸ªä¾‹å­ä¸­ï¼Œ`derived_table_1`æ˜¯ä¸€ä¸ªç›´æ¥æ´¾ç”Ÿçš„è¡¨ï¼Œå®ƒå±äºä¸€ä¸ªå­æŸ¥è¯¢ï¼Œè¿™ä¸ªå­æŸ¥è¯¢åˆå±äºå¦ä¸€ä¸ªå­æŸ¥è¯¢ã€‚å› ä¸º`derived_table_1`çš„çˆ¶æŸ¥è¯¢å—ï¼ˆä¹Ÿå°±æ˜¯å¤–å±‚çš„å­æŸ¥è¯¢ï¼‰å¯ä»¥åˆå¹¶æ´¾ç”Ÿè¡¨ï¼Œæ‰€ä»¥`derived_table_1`ä¹Ÿå¯ä»¥åˆå¹¶ã€‚åŒæ ·ï¼Œ`derived_table_2`ä¹Ÿå¯ä»¥åˆå¹¶ï¼Œå› ä¸ºå®ƒå±äºæœ€å¤–å±‚çš„æŸ¥è¯¢å—ã€‚

## å…¶å®ƒ
```
This is required to support a workaround for allowing subqueries
        containing the same table as is target for delete or update,
        by forcing a materialization of the subquery.  
```
è¿™æ®µè¯çš„ç†è§£ï¼š
```sql
DELETE FROM orders
WHERE order_id IN (SELECT order_id FROM orders WHERE order_date > '2023-01-01');
```  
åœ¨è¿™ä¸ªæŸ¥è¯¢ä¸­ï¼Œå­æŸ¥è¯¢ä¸­çš„è¡¨orderså’Œä¸»æŸ¥è¯¢ä¸­è¦åˆ é™¤çš„è¡¨éƒ½æ˜¯åŒä¸€ä¸ªè¡¨ã€‚å¦‚æœæˆ‘ä»¬ç›´æ¥æ‰§è¡Œè¿™ä¸ªæŸ¥è¯¢ï¼Œé‚£ä¹ˆä¸»æŸ¥è¯¢çš„åˆ é™¤æ“ä½œå¯èƒ½ä¼šå½±å“å­æŸ¥è¯¢çš„ç»“æœï¼Œå› ä¸ºå­æŸ¥è¯¢çš„ç»“æœä¾èµ–äºordersè¡¨ä¸­çš„æ•°æ®ã€‚ä½†æ˜¯ï¼Œå¦‚æœæˆ‘ä»¬å…ˆå°†å­æŸ¥è¯¢çš„ç»“æœå®ä½“åŒ–ï¼ˆä¹Ÿå°±æ˜¯ä¿å­˜åˆ°ä¸€ä¸ªä¸´æ—¶è¡¨ä¸­ï¼‰ï¼Œé‚£ä¹ˆå³ä½¿ä¸»æŸ¥è¯¢åˆ é™¤äº†ordersè¡¨ä¸­çš„æ•°æ®ï¼Œä¹Ÿä¸ä¼šå½±å“å­æŸ¥è¯¢çš„ç»“æœï¼Œå› ä¸ºå­æŸ¥è¯¢çš„ç»“æœå·²ç»ä¿å­˜åœ¨ä¸´æ—¶è¡¨ä¸­äº†ã€‚

æ‰€ä»¥ï¼Œè¿™æ®µè¯çš„å«ä¹‰æ˜¯ï¼Œä¸ºäº†æ”¯æŒè¿™ç§è§£å†³æ–¹æ¡ˆï¼Œéœ€è¦å¼ºåˆ¶å¯¹å­æŸ¥è¯¢è¿›è¡Œå®ä½“åŒ–ã€‚

# è¡¨å‡½æ•°
```sql
SELECT * 
FROM JSON_TABLE('{"a": 1, "b": 2}', '$.*' COLUMNS(a INT PATH '$.a', b INT PATH '$.b'));
```
è¿™ä¸ªæŸ¥è¯¢ä¼šè¿”å›ä¸€ä¸ªåŒ…å«ä¸€è¡Œçš„è¡¨ï¼Œè¿™ä¸€è¡ŒåŒ…å«ä¸¤ä¸ªåˆ—aå’Œbï¼Œå¯¹åº”JSONå¯¹è±¡ä¸­çš„ä¸¤ä¸ªå±æ€§ã€‚

# ç§»é™¤å†—ä½™æŸ¥è¯¢
```
    Permanently remove redundant parts from the query if
      1) This is a subquery
      2) Not normalizing a view. Removal should take place when a
         query involving a view is optimized, not when the view
         is created
```
ä¸¾ä¾‹ï¼š
```sql
SELECT * FROM (SELECT id, name FROM users WHERE name = 'John') as subquery;
```
åœ¨è¿™ä¸ªæŸ¥è¯¢ä¸­ï¼Œå­æŸ¥è¯¢SELECT id, name FROM users WHERE name = 'John'æ˜¯å†—ä½™çš„ï¼Œå› ä¸ºå®ƒçš„ç»“æœè¢«å®Œå…¨åŒ…å«åœ¨ä¸»æŸ¥è¯¢ä¸­ã€‚æ‰€ä»¥ï¼Œè¿™ä¸ªæŸ¥è¯¢å¯ä»¥è¢«ä¼˜åŒ–ä¸ºï¼š
```sql
SELECT id, name FROM users WHERE name = 'John';
```

# Scalar Subqueries
æ ‡é‡å­æŸ¥è¯¢ï¼ˆScalar Subqueriesï¼‰æ˜¯ä¸€ç§ç‰¹æ®Šçš„å­æŸ¥è¯¢ï¼Œå®ƒåªè¿”å›ä¸€è¡Œä¸­çš„ä¸€ä¸ªåˆ—å€¼ã€‚æ ‡é‡å­æŸ¥è¯¢è¡¨è¾¾å¼çš„å€¼æ˜¯å­æŸ¥è¯¢çš„å¯é€‰åˆ—è¡¨é¡¹çš„å€¼ã€‚å¦‚æœå­æŸ¥è¯¢è¿”å›0è¡Œï¼Œåˆ™æ ‡é‡å­æŸ¥è¯¢è¡¨è¾¾å¼çš„å€¼ä¸ºNULLã€‚å¦‚æœå­æŸ¥è¯¢è¿”å›å¤šè¡Œï¼Œåˆ™ä¼šæŠ¥é”™ã€‚

ä»¥ä¸‹æ˜¯ä¸€ä¸ªæ ‡é‡å­æŸ¥è¯¢çš„ä¾‹å­ï¼š

```sql
SELECT name, (SELECT MAX(salary) FROM employees WHERE department_id = d.id) as max_salary
FROM departments d;
```

åœ¨è¿™ä¸ªæŸ¥è¯¢ä¸­ï¼Œ`(SELECT MAX(salary) FROM employees WHERE department_id = d.id)`å°±æ˜¯ä¸€ä¸ªæ ‡é‡å­æŸ¥è¯¢ã€‚å®ƒä¸ºæ¯ä¸ªéƒ¨é—¨è¿”å›æœ€é«˜çš„å·¥èµ„ï¼Œè¿™ä¸ªå€¼è¢«åŒ…å«åœ¨ä¸»æŸ¥è¯¢çš„ç»“æœä¸­ã€‚

## å¦å¤–ä¸€ç§è§£è¯»
ä¸¾ä¸ªä¾‹å­ï¼Œå‡è®¾æˆ‘ä»¬æœ‰ä»¥ä¸‹çš„SQLæŸ¥è¯¢ï¼š
```sql
SELECT * FROM orders WHERE order_id IN (SELECT order_id FROM order_items WHERE quantity > 5);
```
åœ¨è¿™ä¸ªæŸ¥è¯¢ä¸­ï¼Œå­æŸ¥è¯¢SELECT order_id FROM order_items WHERE quantity > 5æ˜¯ä¸€ä¸ªæ ‡é‡å­æŸ¥è¯¢ï¼Œå®ƒè¿”å›ä¸€ä¸ªå•åˆ—çš„ç»“æœé›†ã€‚è¿™ä¸ªæŸ¥è¯¢å¯ä»¥è¢«ä¼˜åŒ–ä¸ºï¼š
```sql
SELECT o.* FROM orders o JOIN (SELECT order_id FROM order_items WHERE quantity > 5) as derived_table ON o.order_id = derived_table.order_id;
```
åœ¨è¿™ä¸ªæŸ¥è¯¢ä¸­ï¼Œæˆ‘ä»¬å°†å­æŸ¥è¯¢è½¬æ¢ä¸ºä¸€ä¸ªæ´¾ç”Ÿè¡¨ï¼Œç„¶åå°†è¿™ä¸ªæ´¾ç”Ÿè¡¨è¿æ¥åˆ°ä¸»æŸ¥è¯¢ä¸­ã€‚è¿™æ ·ï¼ŒæŸ¥è¯¢å°±å¯ä»¥æ›´é«˜æ•ˆåœ°æ‰§è¡Œï¼Œå› ä¸ºå®ƒé¿å…äº†å­æŸ¥è¯¢çš„å¼€é”€ã€‚

# MySQL Optimizeå’ŒPlanningé˜¶æ®µ
![Alt text](assets/008.png)
## è€ä¼˜åŒ–å™¨çš„å…¥å£
è€ä¼˜åŒ–å™¨ä»ç„¶èµ°JOIN::optimizeæ¥æŠŠquery blockè½¬æ¢æˆquery execution plan (QEP)ã€‚

è¿™ä¸ªé˜¶æ®µä»ç„¶åšä¸€äº›é€»è¾‘çš„é‡å†™å·¥ä½œï¼Œè¿™ä¸ªé˜¶æ®µçš„è½¬æ¢å¯ä»¥ç†è§£ä¸ºåŸºäºcost-basedä¼˜åŒ–å‰åšå‡†å¤‡ã€‚
## æ–°ä¼˜åŒ–å™¨çš„å…¥å£
æ–°ä¼˜åŒ–å™¨é»˜è®¤ä¸æ‰“å¼€ï¼Œå¿…é¡»é€šè¿‡set optimizer_switch="hypergraph_optimizer=on"; æ¥æ‰“å¼€ã€‚ä¸»è¦é€šè¿‡FindBestQueryPlanå‡½æ•°æ¥å®ç°ï¼Œé€»è¾‘å¦‚ä¸‹ï¼š

- å…ˆåˆ¤æ–­æ˜¯å¦å±äºæ–°ä¼˜åŒ–å™¨å¯ä»¥æ”¯æŒçš„Queryè¯­æ³•ï¼ˆCheckSupportedQueryï¼‰ï¼Œä¸æ”¯æŒçš„ç›´æ¥è¿”å›é”™è¯¯ER_HYPERGRAPH_NOT_SUPPORTED_YETã€‚
- è½¬åŒ–top_join_listå˜æˆJoinHypergraphç»“æ„ã€‚ç”±äºHypergraphæ˜¯æ¯”è¾ƒç‹¬ç«‹çš„ç®—æ³•å±‚é¢çš„å®ç°ï¼ŒJoinHypergraphç»“æ„ç”¨æ¥æ›´å¥½çš„æŠŠæ•°æ®åº“çš„ç»“æ„åŒ…è£…åˆ°Hypergraphçš„edgeså’Œnodesçš„æ¦‚å¿µä¸Šçš„ã€‚
- é€šè¿‡EnumerateAllConnectedPartitionså®ç°è®ºæ–‡ä¸­çš„DPhypç®—æ³•ã€‚
- CostingReceiverç±»åŒ…å«äº†è¿‡å»JOIN planningçš„ä¸»è¦é€»è¾‘ï¼ŒåŒ…æ‹¬æ ¹æ®costé€‰æ‹©ç›¸åº”çš„è®¿é—®è·¯å¾„ï¼Œæ ¹æ®DPhypç”Ÿæˆçš„å­è®¡åˆ’è¿›è¡Œè¯„ä¼°ï¼Œä¿ç•™costæœ€å°çš„å­è®¡åˆ’ã€‚
- å¾—åˆ°root_pathåï¼Œæ¥ä¸‹æ¥å¤„ç†group/agg/having/sort/limitçš„ã€‚å¯¹äºGroup byæ“ä½œï¼Œç›®å‰Hypergraphä½¿ç”¨sorting first + streaming aggregationçš„æ–¹å¼ã€‚

# ğ“¢ğ“”ğ“¢ å’Œ ğ“£ğ“”ğ“¢
ğ“¢ğ“”ğ“¢(syntactic eligibility set)æ˜¯ä¸€ä¸ªjoin operatorä»è¯­æ³•ä¸Šè¦ä¾èµ–çš„è¡¨é›†åˆï¼Œä¾‹å¦‚è¿™ä¸ªjoin conditionä¸­æ¶‰åŠçš„è¡¨åˆ—éƒ½å¯¹åº”å“ªäº›è¡¨ï¼Œå¾ˆæ˜¾ç„¶è¿™æ˜¯æœ€åŸºæœ¬çš„è¦æ±‚ï¼Œæ²¡æœ‰è¿™äº›åˆ—conditionæ˜¯æ— æ³•è®¡ç®—çš„

ğ“£ğ“”ğ“¢(total eligibility set)åˆ™ä¸ä»…åŒ…å«SESçš„è¯­ä¹‰ï¼Œè¿˜ç”¨æ¥è¡¨ç¤ºå¯¹äºoperatorçš„è‡ªèº«å±æ€§ä»¥åŠoperatorä¹‹é—´é‡æ’åºçš„ä¾èµ–å…³ç³»çš„çº¦æŸ

ä¸¾2ä¸ªä¾‹å­ï¼š

t1 left outer join t2 where t2.b is NULL

è¿™é‡Œt2.b is NULLè¿™ä¸ªconditionï¼Œå…¶SESæ˜¯{t2}ï¼Œå› ä¸ºåªæ¶‰åŠåˆ°t2è¡¨ï¼Œä½†ç”±äºæ˜¯whereä¸­çš„ï¼Œä¸”t2æœ‰å¯èƒ½åœ¨joinä¸­äº§ç”ŸNULLåˆ—ï¼Œå› æ­¤TESå°±æ˜¯{t1, t2}ï¼Œè¡¨ç¤ºåœ¨t1,t2éƒ½åŒ…å«çš„å­æ ‘ä¸Šæ‰èƒ½åšè¿™ä¸ªoperatoræ“ä½œã€‚

t1 left anti join (t2 join t3 on t2.a = t3.a) on t1.b = t2.b

è¿™é‡Œç”±äºleft joinçš„çº¦æŸï¼Œ{t2, t3}çš„joinå¿…é¡»å…ˆå®Œæˆï¼Œæ‰èƒ½åšt1ä¸nestéƒ¨åˆ†çš„LOJï¼Œä¸ºäº†è¡¨ç¤ºè¿™ä¸ªçº¦æŸï¼ŒTES(LOJ)ä¸­ï¼Œå¿…é¡»å³å­æ ‘åŒ…å« {t2, t3}ï¼Œè€ŒTES(nest) = SES(nest) = {t2, t3}ã€‚


# join çš„ç¬¦å·è¡¨ç¤º
unicode å­—ç¬¦
https://www.compart.com/en/unicode/

â¨
â¨ nature join
âŸ— full outerjoi
âŸ• left outerjoin
âŸ– right outerjoin
âœ• cross join
â‹Š 
â‹‰ 
â‹‰
â–·


# å…¶å®ƒæ¦‚å¿µçš„æ•°å­¦ç¬¦å·
- LOP  
è¡¨ç¤ºé€»è¾‘çš„äºŒå…ƒç®—å­ï¼Œæ¯”å¦‚ â¨ã€âŸ—ã€âŸ•ã€âŸ–ã€â‹Šã€â‹‰ã€âœ• ç­‰

- Null Rejecting  
å±æ€§ A çš„é›†åˆä¸­ï¼Œæ¯ä¸ªå…ƒç»„çš„å€¼éƒ½ä¸ä¸º NULL  
æ¯”å¦‚: A={id,name,phone,create_date} ï¼Œè¿™é‡Œçš„ 4 ä¸ªå­—æ®µéƒ½å®šä¹‰ä¸º NOT NULL

- Free Attributes and Tables ğ“•(Â·), ğ“•$_T$(Â·)  
e æ˜¯è¡¨è¾¾å¼ï¼Œğ“(e) è¡¨ç¤º e ä¸­çš„å±æ€§æˆ–è€…å˜é‡  
ğ“•(e) è¡¨ç¤º the set of free attributes/variables in some expression e  
For example, if p â‰¡ R.a + S.b = S.c + T.d, then ğ“•(p) = {R.a, S.b, S.c, T.d}.

- STO(âš¬)/ğ“£(âš¬)  
å‡è®¾ A æ˜¯ä¸€ä¸ªå±æ€§é›†åˆï¼Œğ“£(A) è¡¨ç¤ºè¿™äº›å±æ€§æ‰€å±çš„è¡¨  
æˆ‘ä»¬æŠŠ ğ“£(ğ“•(e)) ç¼©å†™ä¸º ğ“•$_T$(e)  
å¯¹é¢ä¸Šé¢çš„ p ï¼Œæˆ‘ä»¬æœ‰ ğ“£(ğ“•(e)) = {R, S, T }  
å‡è®¾ âš¬ æ˜¯ä¸ªç®—å­ï¼Œé‚£ä¹ˆ left(âš¬) (right(âš¬)) è¡¨ç¤ºç®—å­çš„å·¦ï¼ˆå³ï¼‰æ ‘ã€‚  
ğ“£(âš¬)è¡¨ç¤ºç®—å­ä¸‹é¢å­æ ‘ä¸­çš„è¡¨ã€‚  
è¿™é‡Œçš„ ğ“£ è¡¨ç¤º Set of tables  
STO è¡¨ç¤º subtree operators  

- NEL/SES  
SES æ˜¯ syntactic eligibility sets çš„ç¼©å†™  
SES ä¹Ÿå« NEL  
SES è¡¨ç¤ºç®—å­ä¸­æ‰€åŒ…å«çš„è¡¨  
å¯¹é¢ä¸Šé¢çš„ p ï¼Œæˆ‘ä»¬æœ‰ SES(âš¬$_p$) = {R, S, T }

- Degenerate Predicates  
å‡è®¾ p æ˜¯äºŒå…ƒç®—å­ âš¬ çš„ Predicates  
å¦‚æœ ğ“£(left(âš¬)) âˆ© ğ“•$_T$(p) = âˆ… âˆ¨ ğ“£(right(âš¬)) âˆ© ğ“•$_T$(p) = âˆ…, é‚£ä¹ˆæˆ‘ä»¬ç§° p ä¸º degenerate  
ä¸¾ä¾‹ï¼šâ¨$_{true}$ è¿™é‡Œçš„ true Predicates æ˜¯ degenerate. è¿˜æœ‰  cross product(ç¬›å¡å°”ç§¯) ä¹Ÿæ˜¯ degenerate

# transformation
ä¸»è¦åŒ…å«3ç§transformationï¼š
## commutativity äº¤æ¢å¾‹
## associativity ç»“åˆå¾‹
## asscom äº¤æ¢ç»“åˆå¾‹

# xx
Set of tables (T ), and subtree operators (STO). For
a set of attributes A, T (A) denotes the set of tables to which
these attributes belong. We abbreviate T (F(e)) by FT(e).
For p we have T (F(e)) = {R, S, T }. Let â—¦ be an operator
in the initial operator tree. We denote by left(â—¦) (right(â—¦))
its left (right) child. STO(â—¦) denotes the operators contained
in the operator subtree rooted at â—¦. T (â—¦) denotes the set of
tables contained in the subtree rooted at â—¦.

$\triangleright \Gamma$

Unicode Character â€œğ“›â€ (U+1D4DB)  
Unicode Character â€œğ“”â€ (U+1D4D4)  
Unicode Character â€œğ“â€ (U+1D4DE)  
Unicode Character â€œğ“Ÿâ€ (U+1D4DF)


U+1D4D0 ğ“  
U+1D4D1 ğ“‘  
U+1D4D2 ğ“’  
U+1D4D3 ğ““  
U+1D4D4 ğ“”  
U+1D4D5 ğ“•  
U+1D4D6 ğ“–  
U+1D4D7 ğ“—  
U+1D4D8 ğ“˜  
U+1D4D9 ğ“™  
U+1D4DA ğ“š  
U+1D4DB ğ“›  
U+1D4DC ğ“œ  
U+1D4DD ğ“  
U+1D4DE ğ“  
U+1D4DF ğ“Ÿ  
U+1D4E0 ğ“   
U+1D4E1 ğ“¡  
U+1D4E2 ğ“¢  
U+1D4E3 ğ“£  
U+1D4E4 ğ“¤  
U+1D4E5 ğ“¥  
U+1D4E6 ğ“¦  
U+1D4E7 ğ“§  
U+1D4E8 ğ“¨  
U+1D4E9 ğ“©  

ğ“¢ğ“”ğ“¢
ğ“£ğ“”ğ“¢
ğ“›ğ“ğ“™
ğ“¢ğ“£ğ“

Unicode Character â€œğ’œâ€ (U+1D49C)  
Unicode Character â€œğ’â€ (U+1D49E)  
Unicode Character â€œğ’Ÿâ€ (U+1D49F)  
Unicode Character â€œğ’¢â€ (U+1D4A2)  
Unicode Character â€œğ’¥â€ (U+1D4A5)  
Unicode Character â€œğ’¦â€ (U+1D4A6)  
Unicode Character â€œğ’©â€ (U+1D4A9)  
Unicode Character â€œğ’ªâ€ (U+1D4AA)  
Unicode Character â€œğ’«â€ (U+1D4AB)  
Unicode Character â€œğ’¬â€ (U+1D4AC)  
Unicode Character â€œğ’®â€ (U+1D4AE)  
Unicode Character â€œğ’¯â€ (U+1D4AF)  
Unicode Character â€œğ’°â€ (U+1D4B0)  
Unicode Character â€œğ’±â€ (U+1D4B1)  
Unicode Character â€œğ’²â€ (U+1D4B2)  
Unicode Character â€œğ’³â€ (U+1D4B3)  
Unicode Character â€œğ’´â€ (U+1D4B4)  
Unicode Character â€œğ’µâ€ (U+1D4B5)  

Unicode Character â€œğ’œâ€ (U+1D49C)  
Unicode Character â€œğ’â€ (U+1D49D)  
Unicode Character â€œğ’â€ (U+1D49E)  
Unicode Character â€œğ’Ÿâ€ (U+1D49F)  
Unicode Character â€œğ’ â€ (U+1D4A0)  
Unicode Character â€œğ’¡â€ (U+1D4A1)  
Unicode Character â€œğ’¢â€ (U+1D4A2)  
Unicode Character â€œğ’£â€ (U+1D4A3)  
Unicode Character â€œğ’¤â€ (U+1D4A4)  
Unicode Character â€œğ’¥â€ (U+1D4A5)  
Unicode Character â€œğ’¦â€ (U+1D4A6)  
Unicode Character â€œğ’§â€ (U+1D4A7)  
Unicode Character â€œğ’¨â€ (U+1D4A8)  
Unicode Character â€œğ’©â€ (U+1D4A9)  
Unicode Character â€œğ’ªâ€ (U+1D4AA)  
Unicode Character â€œğ’«â€ (U+1D4AB)  
Unicode Character â€œğ’¬â€ (U+1D4AC)  
Unicode Character â€œğ’­â€ (U+1D4AD)  
Unicode Character â€œğ’®â€ (U+1D4AE)  
Unicode Character â€œğ’¯â€ (U+1D4AF)  
Unicode Character â€œğ’°â€ (U+1D4B0)  
Unicode Character â€œğ’±â€ (U+1D4B1)  
Unicode Character â€œğ’²â€ (U+1D4B2)  
Unicode Character â€œğ’³â€ (U+1D4B3)  
Unicode Character â€œğ’´â€ (U+1D4B4)  
Unicode Character â€œğ’µâ€ (U+1D4B5)  

Unicode Character â€œâš¬â€ (U+26AC)




