
# CSE (Common Subexpression Elimination)
**å…¬å…±å­è¡¨è¾¾å¼æ¶ˆé™¤**ï¼ˆCommon Subexpression Eliminationï¼Œç®€ç§° CSEï¼‰çš„æ¦‚å¿µã€‚å‡è®¾æˆ‘ä»¬æœ‰ä»¥ä¸‹ä¸¤ä¸ªæ¡ä»¶ï¼š
```sql
`SELECT * FROM 
EMP, DEPT 
WHERE 
(EMP.DEPTNO = DEPT.DEPTNO AND LOC = 'DALLAS' AND SAL > 100000) OR 
(EMP.DEPTNO = DEPT.DEPTNO AND LOC = 'DALLAS' AND JOB_TITLE = 'VICE PRESIDENT')`
```
åœ¨è¿™é‡Œï¼Œ`EMP.DEPTNO = DEPT.DEPTNO AND LOC = 'DALLAS'` å°±æ˜¯å…±å­è¡¨è¾¾å¼ï¼Œæ”¹å†™åå˜æˆï¼š

```sql
SELECT * FROM 
EMP, DEPT 
WHERE 
EMP.DEPTNO = DEPT.DEPTNO AND LOC = 'DALLAS' AND 
(SAL > 100000 OR JOB_TITLE = 'VICE PRESIDENT');
```

æ”¹å†™ä¹‹å‰ï¼Œä» `DEPT` åå‡ºçš„æ¯ä¸€è¡Œæ•°æ®éƒ½ä¼šè®¡ç®—ä¸¤æ¬¡ `LOC='DALLAS'` è¡¨è¾¾å¼ï¼Œæ”¹å†™ååªéœ€è¦è®¡ç®—ä¸€æ¬¡ã€‚è¿™æ ·ï¼Œæˆ‘ä»¬é¿å…äº†é‡å¤è®¡ç®—ï¼Œæé«˜äº†æŸ¥è¯¢æ€§èƒ½ã€‚è¿™å°±æ˜¯å…¬å…±å­è¡¨è¾¾å¼æ¶ˆé™¤çš„åŸºæœ¬æ€æƒ³ï¼ğŸš€

è¿™ä¸ªæŠ€æœ¯åœ¨ç¼–è¯‘å™¨å’Œæ•°æ®åº“ä¼˜åŒ–å™¨ä¸­éƒ½æœ‰å¹¿æ³›åº”ç”¨ï¼Œå®ƒå¯ä»¥æœ‰æ•ˆåœ°å‡å°‘å†—ä½™è®¡ç®—ï¼Œæé«˜ä»£ç æ‰§è¡Œæ•ˆç‡ã€‚

# Item ç±»å…³ç³»å›¾
[å®˜æ–¹ Item_bool_func ç±»å…³ç³»å›¾](https://dev.mysql.com/doc/dev/mysql-server/latest/classItem__bool__func__inherit__graph_org.svg)

[Item_basic_constant ç±»å…³ç³»å›¾](https://www.plantuml.com/plantuml/uml/lLVDZjis4BxhAOZDnKwoGD0UMcJR8bvRTLnu9KUsc-o9eAMnpKQYL9BQsDW6Q2y5-WfzXnRehJ-Fqotw6gKeYQNbTUJj1WtWI1f-C_FDS6R8VIOauJ9FOgSV4o7GX701M780pD98lILPlJIIa5mxIFrxfD_HGmORYPSAgwKFq5HoobP8I8wlI9n31HxC-caS4qbJXiBwpJA46Ka0YrAPre93W9JJbGt8APCVVe0Iii4ni9LSMufFdsfp2U6lWQFoOTlb8F9OeZ39S9WogSAnZA9YVQaMSbQB5saQAp5P41Qb3A9Ah7I5B1Ufm5cHGeuBpvQrZvLUH2J1SflLrFkfaFvIvp9HViIEcoNTGBHZ88AG9YGMMdXQas6vokWY1bkta9ajCDAS2RfIhF4o9glTY1JjDrJ5z0OlSnPQ-wFNrpIAW3Kq60xN4Bx6EdXE54CC6mXnA3SLGI69f66PdIg4IU1Fy7H-_cBk1fTdRRYP7xW3hDw7GU-Y3TqR3WDts9kDVAyD-dBa3VoN-FEvrpy67lZZyNo2tLUJe0qw3FpvPEGDjUq2_C1iFWd3FC4PJpFWae8uSzuwB9M0L3slvTEofVx-vO-RNt_ww-SVRtxxuURtxu7b2PgfWldps-_qkt8OLLLRYrJkhw1esfH7m1qdDCsA5qJGiDmWmYIwTWhgiYWMd90CvG8YR3uL7Ljt3PkwumgzHyXmGKK5TxfLyAbopca4w1fna3bdwCjUS3xoy6ZcNfoXjqwpsSe7RZ4odGL56WDtEX_FQZC2vByzrBcudBuOuzdbnCNAPVzvB-WsObXGPc9eB7qbKbOb96Vqwnnm9ZcEGC7JBKvPl4M9wQ3su9kyxU2lKXgXJB6GdL9hzdo07Zwkf-L3vVAnTe0L3RxLmJKTdFqlQVnYwdkD7EhnWgxVhUVDn-EkXfZfZJv5Nk_2nIM1paa1EUdUBPU5plikesPm2RhU5LL3LeVy02LR8wYU_wKe1cv_TD6xNop6oh6RwRalAutcbYxZbDJJmBDErapn02Rhu_aHYj9y4GCo4HzsDl3dvsFtZliRk5PE6XHp5kACbYGh0pPLlSwKG7iqNvsTcijeftlIrQJkst-Aj8ATVaQo35ZKCGwx-zILdwfVufIjYjyn2Hpxth3utJ658szspwfI5WwsXpxg6_sHc_XsxnEguINFOJyP-4a5tzcR9oVDgZI3shhRX0AB34Awf10TUGBSSrg__ncJ4IvfqL9bKGko11Dh8zrnkcWRjUTZ__oEGMgzv_vuu0Rxx239v7QVpsGsmZ6Lm4cCSnO15s7A0OThmXKrVR0gzyShh65JArZEorjKvLsdfm7G6IjkDofzjrLHjLIqkRElICFyNSfcsHYmOf6maNL0vLbWxlSVBQZKWh7xgZA6AkHX6_h3olC152iIPc_7RN-FeK--EJtLSJh5V-QpUU5pRf4Pi7t3SnhV1cHVeLgi5HUg5aXnbMY594xzOiJcK6ukcSFCCQ-MiVeGkKsBrjcXjdizy6wJvtjuQxorX6Hbpqvlst1mMjPjrcfk70-tMtwVrf6TVwnUSm3iwnqO1Cu1kQLa3uTZuLRFxrDfTgFJ53HX-wtThhBVvuxp35YK9_4_)

[Item_identã€Item_result_field ç±»å…³ç³»å›¾](https://www.plantuml.com/plantuml/uml/jLZTRjl85RxdKmpYcqHn2ZG5Yi9UBDQr5LUe8pbQgMwxM0n6vA4qDJd3p0njgMg0zgP0xtlL1Ve63T2x_lTXciNkNL-XCsT83IdJFtRg0B66v-VZTywSCp_yJ1kcJ9bdqM76j2QdJ6cWHW5G8HCxoejQDJ2GhoDY_pt7CUa9M1gQMbkKxf3FZU9YJhHHz89b9LJ6HvD3cMNCS2b8N8yQG5Im7AZsphmMN6SW5Pyt3KekpFTUafmjQGPYRXODnxqzXCkPEWT5_4yJLu4kCqFYlA2n5CQ6qm0bJfzQHIbgyKpAp8hPZ8b42aWgiVNLnYkvfeLBeQBkpGsq7rY_X1b6pQgegHzARKOfvZAtxz6jrwHy2KaB886OvopJA7nHan6bpUWiWwQla-4KjAIbq7nkMTCqO_DsH9Rs9RSnNTAq5B6Vdw1Vy2G1iUKXQBo0-9nYy8fPXXIM4DFOB2k2sZ33Ov-TAeJJyUYKVZxzuPjfV_op_Tli9gDn_uZQyV7uuFLjrWV7n-F-yS5aC1hUPdes61wDpkYhwV3mBkRZqSd9z9JsVtewlitqU3oQdWw6nuZjZ7Ssay_YkCnfeMG1od3G-z6xI4W3nDRpmkpvblhcpt__y9S_VVt-3n_--hiFV_ijY38d4rim__drRt1iNvXKLLkBZ68Nu9fMgWHKr6ZMof2c7B9aZMHUkI7fDHMMHiC7vz_QxbGjtcDgRWlkHVMOKyXda2IGKAieSn16V_7oowXk6Iki6sQdKOfIO9aweJVBCdc96CuyqqvXN17Jd1Mar5Q5Zvh6p5PPMosaGRIsYMMmoHPnFVRqMJKzqgP7yGJ8cYWmfHB4JGuTJFglzyaxvtZ1bIbPvW5UkGPm82aE0b3mdmv_F1oT3Vqajo5yckPWN6nFCLZ-B7YwR7x1lsmxUVXkLw-x5a3oX1JAcZxrTfCV7P6UMIIxzLhSqqRjOc3qRGbgHJ6qCDnEKXkLok8ZWHrU4z3nlnaI0q-LpE-2tcwXJT-qP_A___YAVFl-Nz_yyxrLrRNnxRz___LNVmobq6e2Im4RWQpVDSMkeEi62Gjmh80PIEXiPVrUmf9hexUQofAj6l34QZzniaz9PeSeGnmsayg4HY7FxrJ9XwFXKQZaHwc8_OvOAFFnFFS4-c-c1oS45V2sP4Y_kvbkZUN0_g_RAcojyO8fqdCOkFFV0FB4CdjYdRj8IqNM7q5jDFuuPb9r4CDyhVsk4eh3hyoV4lpHg0qhi7i1DfANu-c5emxibe_3IdE0osjUCCMCLCwmUNJ0dAGiqz2IeZrGfjrn1NGuBZLUdieiiRM4ApzvK4PVJqyclcuQINrGMlCoCxp8W60gdmGaMHYUyr-2Bt0D6SI6ri9cTpphW1sTJWQl1p_lUuu1zD7xAomoBt75w9x4xaMZVQpTJ6Nt9cQ1lkCscxRLFTUHkuT9rk5yiRUtsLqGqI4rNPjj4hmgfbnBiRKkmriwOnfySuUsiXHbgMAWTObuCJUhBdJKFNI1Q5To9_h3ePkuNVSpyiclNlZb8N9_mYDjdVEkID0mS8ms8rIqTy8eFBKCGhb6xKSq2Ojlj1bjAIYxIIbL9soOusvrku-YhMSqwgohg4k8vgr2YveFMsXMVBCQMKTnux2HW33Owwt5BwTuqqrck09UfyOpy8qMEDN1ehx2PfnfAbCAoq95M9b3Q-BgGsQbkm3MDsBIgmPNThr0hIr7Jjqg91DK4xHKa98UdkBziT_htk1wCCjaV6vV1GM8nEhTmV2H3ZfaxV4wrwHTugErWn3Ui__VgMktAxDkaz_jJYtggWXm1ma55UvxhGIRUeYAwYA8fX6UPZkkXasvXJTKAbkGe0qN34kaswhRmd-deOPSZqHpoEDYvOXskDng7gvHNczR05kGyeseUMulb3GGLoTt9bRL1vChcmZVZ9qAINtt-yGpu2A1vGqUb6KP_ONaWWfmruBmXKPIfCk4SKGADiV0DcyW2tO1LiClU0PpQ7XQfftoc0bQQkS3AL_ISrYXxkwNua7_9DmbMXM51RGEhofARNiraPU2jXlpsZeAtnCGp1zIxyTlt7_r-3UTLjHiFbTWvmKQyOyjUMJhehY5SVr5gayjzwj9bQK1jO5-qLxmyA2IhcmOKJX-Rpn2nUdIohbmltuN3jyFPIaIwbJ-v8lNpVk6C9fE-kDk-iuRFyCi82j0OH0xNeLyPlwzblMb0BMTsmiEbo7svZgLSgMDXR1EVZVOlpVhdmpwPmtIuL0Kzjie38FALskd2hDU3u8ur4Y7GPZb3cLN3jicxKH5du58oZpx7m00)

# Field ç±»å…³ç³»å›¾
[å®˜æ–¹ Field ç±»å…³ç³»å›¾](https://dev.mysql.com/doc/dev/mysql-server/latest/classField__inherit__graph_org.svg)

[cmp_item ç±»å…³ç³»å›¾]
https://www.plantuml.com/plantuml/svg/rLPDQnin4BtlhvXJM3inz5XmABHfId983OdlGjwTnDlgmvMqDiPjVdlHpieL6rab9X1y2B5cthoPUUEHTIMujG2LNB76eIns1S3vltEvraqzcfBnEMbTDyQrNC12Qm5S25rnXspDHOkiqdB53NVQsFBk-exTpsPp65_iwVtds-x_aCrd0EkqwQdADAnHpfDbl5G2bfLMraM9Hz1P-WZhk6kgo0qADr7vvVpcQoYM6RIjS7JmHgA-klby_t0zPxVVlyrUb18pI_uJcUKIWupPnjbYonpAbU0EowHkVufYC4LcAowuANPG04o0HYEPQeKWqYav-cJe8bVfmQCfUDhAqqQipZJgAR1Irm-T3SPKgq7RKvFzI_luYERouuTF4ELD2kQpL4jkBBeETJxCMwPb9knh9auH-IzQcbYkqjxST5D2_h1Q5JiQGQkQNosobJEiHkkCtZAjn1PaFwd_ePPQr6W85gRHIHRYeuKEkSi3T1U7yWnl0AAX3e_UkRTRzVm44WDebElr5rez-Jy8QhtNBNHyCpLtw1g9NKUfdW0yEwMc4ZVSg2wuTz8DiUIs8ml6OOPGVjHcTfC6k8nQhrrX2ZbIBuDSxBMgTRiGI4gTQaCrLesCUfBRO3hjlepUX9wYo77qg9ZstjRNei8f9Y3sK4ViYN_IOPo6n0SuEzk3dW-dUAFdq6dCZ917FrreNWEfGaIirc1Mz6K9X9U_9vCNJv_1cK235qKUHB_IUKYZN0uHNPrP6Dr9UKXOwNJVj2n_0G00

# è¡¨è¾¾å¼ä¼˜åŒ–ç ”ç©¶
```sql
drop table if exists t1;
drop table if exists t2;
drop table if exists t3;
drop table if exists t4;
drop table if exists t5;
drop table if exists t6;

create table t1 (id int primary key, a int, b int default 0, c int default 0, d int default 0);
create table t2 (id int primary key, a int, b int default 0, c int default 0, d int default 0);
create table t3 (id int primary key, a int, b int default 0, c int default 0, d int default 0);
create table t4 (id int primary key, a int, b int default 0, c int default 0, d int default 0);
create table t5 (id int primary key, a int, b int default 0, c int default 0, d int default 0);
create table t6 (id int primary key, a int, b int default 0, c int default 0, d int default 0);
insert into t1 (id,a) values (0,0),(1,1),(8,8);
insert into t2 (id,a) values (0,0),(1,1),(2,2);
insert into t3 (id,a) values (1,1),(2,2),(3,3),(8,8);
insert into t4 (id,a) values (2,2),(3,3),(4,4);
insert into t5 (id,a) values (2,2),(3,3),(4,4),(5,5);
insert into t6 (id,a) values (2,2),(3,3),(4,4),(5,5),(6,6);


((SELECT * FROM t1 UNION SELECT * FROM t2 UNION ALL SELECT * FROM t3
             ORDER BY a LIMIT 5) INTERSECT
            (((SELECT * FROM t3 ORDER BY a LIMIT 4) ) EXCEPT SELECT * FROM t4)
            ORDER BY a LIMIT 4) ORDER BY -a LIMIT 3;

set optimizer_switch="hypergraph_optimizer=on";

select t1.* from t1
left join t2 on t1.id=t2.id
left join t3 on t1.id=t3.id
where t1.a=1 and t2.a=t1.a and t3.a=t1.a # å¸¸é‡æ›¿æ¢
      and ((t1.b = 1 and t2.b=2) or (t1.b=1 and t2.c=2)) # å…¬å…±å­è¡¨è¾¾å¼æ¶ˆé™¤åæ˜¯ (t1.b = 1 and ( t2.b= 2 or t2.c=2))
      and t3.id # æ ‡é‡å¤„ç†
      ;

      
# æŸ¥çœ‹ SJ å’Œ AJ
select * from t1 where exists (select 1 from t2 where t1.id=t2.id) and not exists (select 1 from t3 where t1.id=t3.id) and t1.id=(select min(id) from t4) and t1.id=t1.a;

-exec source /data/ldc_docker/mysql-server/study/object2.py
-exec mysql join_graph graph
-exec mysql Mem_root_array graph->edges
```
# æŸ¥çœ‹ BLOCK çš„ MULTI EQUAL
## ç­‰å¼ä¸­æœ‰å­æŸ¥è¯¢
```sql
 select * from t1 where exists (select 1 from t2 where t1.id=t2.id) and not exists (select 1 from t3 where t1.id=t3.id) and t1.id=(select min(id) from t4) and t1.id=t1.a;

MakeJoinHypergraph å‰

SELECT `test`.`t1`.`id` AS `id`,
       `test`.`t1`.`a` AS `a`,
       `test`.`t1`.`b` AS `b`,
       `test`.`t1`.`c` AS `c`,
       `test`.`t1`.`d` AS `d`
FROM `test`.`t1` semi
JOIN (`test`.`t2`) anti
JOIN (`test`.`t3`) on((`test`.`t1`.`id` = `test`.`t3`.`id`))
WHERE ((`test`.`t1`.`id` =
          (SELECT min(`test`.`t4`.`id`)
           FROM `test`.`t4`))
       AND (`test`.`t1`.`id` = `test`.`t1`.`a`)
       AND (`test`.`t1`.`id` = `test`.`t2`.`id`))

MakeJoinHypergraph å

 SELECT `test`.`t1`.`id` AS `id`,
       `test`.`t1`.`a` AS `a`,
       `test`.`t1`.`b` AS `b`,
       `test`.`t1`.`c` AS `c`,
       `test`.`t1`.`d` AS `d`
FROM `test`.`t1` semi
JOIN (`test`.`t2`) anti
JOIN (`test`.`t3`) on(multiple equal(`test`.`t1`.`id`, `test`.`t1`.`a`, `test`.`t2`.`id`, `test`.`t3`.`id`))
WHERE ((`test`.`t1`.`id` =
          (SELECT min(`test`.`t4`.`id`)
           FROM `test`.`t4`))
       AND ((`test`.`t1`.`id` = `test`.`t1`.`a`)
            AND (`test`.`t1`.`id` = `test`.`t2`.`id`)))
end note
```
## ç­‰å¼ä¸­æœ‰æ²¡æœ‰å­æŸ¥è¯¢
```sql
select * from t1 where exists (select 1 from t2 where t1.id=t2.id) and not exists (select 1 from t3 where t1.id=t3.id)  and t1.id=t1.a;

MakeJoinHypergraph å‰

SELECT `test`.`t1`.`id` AS `id`,
       `test`.`t1`.`a` AS `a`,
       `test`.`t1`.`b` AS `b`,
       `test`.`t1`.`c` AS `c`,
       `test`.`t1`.`d` AS `d`
FROM `test`.`t1` semi
JOIN (`test`.`t2`) anti
JOIN (`test`.`t3`) on(multiple equal(`test`.`t1`.`id`, `test`.`t1`.`a`, `test`.`t2`.`id`, `test`.`t3`.`id`))
WHERE multiple equal(`test`.`t1`.`id`, `test`.`t1`.`a`, `test`.`t2`.`id`)

MakeJoinHypergraph å

SELECT `test`.`t1`.`id` AS `id`,
       `test`.`t1`.`a` AS `a`,
       `test`.`t1`.`b` AS `b`,
       `test`.`t1`.`c` AS `c`,
       `test`.`t1`.`d` AS `d`
FROM `test`.`t1` semi
JOIN (`test`.`t2`) anti
JOIN (`test`.`t3`) on(multiple equal(`test`.`t1`.`id`, `test`.`t1`.`a`, `test`.`t2`.`id`, `test`.`t3`.`id`))
WHERE multiple equal(`test`.`t1`.`id`, `test`.`t1`.`a`, `test`.`t2`.`id`)
```
## ç­‰å¼ä¸­æœ‰ a+b=c
```sql
select * from t1 where exists (select 1 from t2 where t1.id=t2.id) and not exists (select 1 from t3 where t1.id=t3.id)  and t1.id=t1.a and t1.b=t1.c+t1.d and t1.b=2;

MakeJoinHypergraph å‰

SELECT `test`.`t1`.`id` AS `id`,
       `test`.`t1`.`a` AS `a`,
       `test`.`t1`.`b` AS `b`,
       `test`.`t1`.`c` AS `c`,
       `test`.`t1`.`d` AS `d`
FROM `test`.`t1` semi
JOIN (`test`.`t2`) anti
JOIN (`test`.`t3`) on(multiple equal(`test`.`t1`.`id`, `test`.`t1`.`a`, `test`.`t2`.`id`, `test`.`t3`.`id`))
WHERE ((2 = (`test`.`t1`.`c` + `test`.`t1`.`d`))
       AND multiple equal(`test`.`t1`.`id`, `test`.`t1`.`a`, `test`.`t2`.`id`)
       AND multiple equal(2, `test`.`t1`.`b`))

MakeJoinHypergraph å

SELECT `test`.`t1`.`id` AS `id`,
       `test`.`t1`.`a` AS `a`,
       `test`.`t1`.`b` AS `b`,
       `test`.`t1`.`c` AS `c`,
       `test`.`t1`.`d` AS `d`
FROM `test`.`t1` semi
JOIN (`test`.`t2`) anti
JOIN (`test`.`t3`) on(multiple equal(`test`.`t1`.`id`, `test`.`t1`.`a`, `test`.`t2`.`id`, `test`.`t3`.`id`))
WHERE ((2 = (`test`.`t1`.`c` + `test`.`t1`.`d`))
       AND ((`test`.`t1`.`id` = `test`.`t1`.`a`)
            AND (`test`.`t1`.`id` = `test`.`t2`.`id`))
       AND (`test`.`t1`.`b` = 2))
```

# æŸ¥çœ‹ MULTI JOIN
## æ²¡æœ‰ç¬›å¡å°”ç§¯
```sql
select t1.* from t1,t2,t3,t4 where t1.id=t2.id and t1.id=t3.id and t1.id=t4.id;

MakeJoinHypergraph å‰

SELECT `test`.`t1`.`id` AS `id`,
       `test`.`t1`.`a` AS `a`,
       `test`.`t1`.`b` AS `b`,
       `test`.`t1`.`c` AS `c`,
       `test`.`t1`.`d` AS `d`
FROM `test`.`t1`
JOIN `test`.`t2`
JOIN `test`.`t3`
JOIN `test`.`t4`
WHERE multiple equal(`test`.`t1`.`id`, `test`.`t2`.`id`, `test`.`t3`.`id`, `test`.`t4`.`id`)

MakeJoinHypergraph å

SELECT `test`.`t1`.`id` AS `id`,
       `test`.`t1`.`a` AS `a`,
       `test`.`t1`.`b` AS `b`,
       `test`.`t1`.`c` AS `c`,
       `test`.`t1`.`d` AS `d`
FROM `test`.`t1`
JOIN `test`.`t2`
JOIN `test`.`t3`
JOIN `test`.`t4`
WHERE multiple equal(`test`.`t1`.`id`, `test`.`t2`.`id`, `test`.`t3`.`id`, `test`.`t4`.`id`)

MakeJoinHypergraph ä¸­é€”
PushDownAsMuchAsPossible ä¹‹å‰æ˜¯ MULTI_INNER_JOIN
PushDownAsMuchAsPossible ä¹‹åæ˜¯ INNER_JOINï¼Œæ²¡æœ‰ MULTI_INNER_JOIN

@startuml

map RelationalExpression_0x7fff3ca626c0 #header:Gold;back:lightgreen{
         type => <RelationalExpression::Type> RelationalExpression::MULTI_INNER_JOIN
         tables_in_subtree => <table_map> 0000000000001111
         nodes_in_subtree => <hypergraph::NodeMap> 1000111110001111100011111000111110001111100011111000111110001111
         table => <const Table_ref *> 0x8f8f8f8f8f8f8f8f
         join_conditions_pushable_to_this.address => <Mem_root_array<Item*>> 0x7fff3ca626e0
         companion_set => <CompanionSet *> 0x7fff3ca62920
         left => <RelationalExpression *> 0x0
         right => <RelationalExpression *> 0x0
         multi_children.address => <Mem_root_array<RelationalExpression*>> 0x7fff3ca62718
         join_conditions.address => <Mem_root_array<Item*>> 0x7fff3ca62738
         equijoin_conditions.address => <Mem_root_array<Item_eq_base*>> 0x7fff3ca62758
         properties_for_join_conditions.address => <Mem_root_array<CachedPropertiesForPredicate>> 0x7fff3ca62778
         properties_for_equijoin_conditions.address => <Mem_root_array<CachedPropertiesForPredicate>> 0x7fff3ca62798
         join_conditions_reject_all_rows => <bool> false
         conditions_used_tables => <table_map> 0000000000000000
         join_predicate_first => <int> 0
         join_predicate_last => <int> 0
         conflict_rules.address => <Mem_root_array<ConflictRule>> 0x7fff3ca627d0
}

map Mem_root_array_RelationalExpression_0x7fff3ca62718 #header:Gold;back:Tomato {
         0x7fff3ca620d0 => RelationalExpression *
         0x7fff3ca62330 => RelationalExpression *
         0x7fff3ca62590 => RelationalExpression *
         0x7fff3ca627f0 => RelationalExpression *
}


map CompanionSet_0x7fff3ca62920 #header:Gold;back:lightgreen{
         m_equal_terms.address => <Mem_root_array<CompanionSet::EqualTerm>> 0x7fff3ca62920
}

RelationalExpression_0x7fff3ca626c0::multi_children.address --> Mem_root_array_RelationalExpression_0x7fff3ca62718 : multi_children.address
RelationalExpression_0x7fff3ca626c0::companion_set --> CompanionSet_0x7fff3ca62920 : companion_set

@enduml
```
## æœ‰ç¬›å¡å°”ç§¯
```sql
select t1.* from t1,t2,t3,t4 where t1.id=t2.id and t1.id=t3.id ;

MakeJoinHypergraph å‰

SELECT `test`.`t1`.`id` AS `id`,
       `test`.`t1`.`a` AS `a`,
       `test`.`t1`.`b` AS `b`,
       `test`.`t1`.`c` AS `c`,
       `test`.`t1`.`d` AS `d`
FROM `test`.`t1`
JOIN `test`.`t2`
JOIN `test`.`t3`
JOIN `test`.`t4`
WHERE multiple equal(`test`.`t1`.`id`, `test`.`t2`.`id`, `test`.`t3`.`id`)

MakeJoinHypergraph å

SELECT `test`.`t1`.`id` AS `id`,
       `test`.`t1`.`a` AS `a`,
       `test`.`t1`.`b` AS `b`,
       `test`.`t1`.`c` AS `c`,
       `test`.`t1`.`d` AS `d`
FROM `test`.`t1`
JOIN `test`.`t2`
JOIN `test`.`t3`
JOIN `test`.`t4`
WHERE multiple equal(`test`.`t1`.`id`, `test`.`t2`.`id`, `test`.`t3`.`id`)

MakeJoinHypergraph ä¸­é€”
PushDownAsMuchAsPossible ä¹‹å‰æ˜¯ MULTI_INNER_JOIN
PushDownAsMuchAsPossible ä¹‹åæ˜¯ MULTI_INNER_JOINã€å’Œ INNER_JOIN çš„æ··åˆ

åœ¨ MakeJoinHypergraph å ç»§ç»­æŸ¥çœ‹
-exec mysql Mem_root_array graph->edges
å‘ç°æ²¡æœ‰ MULTI_INNER_JOINï¼Œå…¶ä¸­è¡¨ t4 è·Ÿå…¶å®ƒè¡¨æ¯”è¾ƒï¼Œå°‘äº† join_conditions_pushable_to_thisï¼Œå…¨éƒ¨æœ‰ companion_set

```

# è·Ÿè¸ªä¸€æ¬¡
```sql
select t1.* from t1
left join t2 on t1.id=t2.id
left join t3 on t1.id=t3.id
where t1.a=1 and t2.a=t1.a and t3.a=t1.a # å¸¸é‡æ›¿æ¢
      and ((t1.b = 1 and t2.b=2) or (t1.b=1 and t2.c=2)) # å…¬å…±å­è¡¨è¾¾å¼æ¶ˆé™¤åæ˜¯ (t1.b = 1 and ( t2.b= 2 or t2.c=2))
      and t3.id # æ ‡é‡å¤„ç†
      ;

select t1.* from t1
left join t2 on t1.id=t2.a
left join t3 on t1.b=t3.c
where t1.a=1 and t2.a=t1.a and t3.a=t1.a # å¸¸é‡æ›¿æ¢
      and ((t1.b = 1 and t2.b=2) or (t1.b=1 and t2.c=2)) # å…¬å…±å­è¡¨è¾¾å¼æ¶ˆé™¤åæ˜¯ (t1.b = 1 and ( t2.b= 2 or t2.c=2))
      and t3.id # æ ‡é‡å¤„ç†
      and t1.b=t3.id
      ;

select 
	t1.* 
from t1
left join t2 on t1.id=t2.id
left join t3 on t1.id=t3.id
where t1.a=1 and t2.a=t1.a and t3.a=t1.a # å¸¸é‡æ›¿æ¢
      and ((t1.b = 1 and t2.b=2) or (t1.b=1 and t2.c=2)) # å…¬å…±å­è¡¨è¾¾å¼æ¶ˆé™¤åæ˜¯ (t1.b = 1 and ( t2.b= 2 or t2.c=2))
      and t3.id # æ ‡é‡å¤„ç†
       and t1.d=t2.d and t1.d=t3.d and t1.c=t2.d;
      
MakeJoinHypergraph ä¹‹å‰
-exec mysql expr thd->lex->unit
SELECT `test`.`t1`.`id` AS `id`,
       `test`.`t1`.`a` AS `a`,
       `test`.`t1`.`b` AS `b`,
       `test`.`t1`.`c` AS `c`,
       `test`.`t1`.`d` AS `d`
FROM `test`.`t1`
JOIN `test`.`t2`
JOIN `test`.`t3`
WHERE (
      (
            (multiple equal(1, `test`.`t1`.`b`) AND multiple equal(2, `test`.`t2`.`b`))
            OR (multiple equal(1, `test`.`t1`.`b`) AND multiple equal(2, `test`.`t2`.`c`))
      )
      AND (0 <> `test`.`t3`.`id`)
      AND multiple equal(1, `test`.`t1`.`a`, `test`.`t2`.`a`, `test`.`t3`.`a`)
      AND multiple equal(`test`.`t1`.`id`, `test`.`t3`.`id`, `test`.`t2`.`id`))

  RelationalExpression *root =  // åç»­éå† join_listï¼Œ1ã€å¦‚æœæ˜¯ sj æˆ–è€… ajï¼Œåˆ™é€’å½’ 2ã€å¦‚æœä¸æ˜¯ sj æˆ–è€… ajï¼Œåˆ™ç›´æ¥ç”Ÿæˆ RelationalExpression 3ã€æ‹¿åˆ°ä¼˜åŒ–åçš„ <Item *> Table_ref->m_join_cond_optimï¼Œå¦‚æœæ˜¯ multiple equalitiesï¼Œåˆ™ 3.1ã€æ ‡é‡å¤„ç†ï¼Œ3.2ã€å¸¸é‡å¤„ç†ï¼ˆæ¯ä¸ªå­—æ®µå¡«å……å¸¸é‡ï¼‰ï¼Œ3.3ã€æ¶‰åŠè¡¨ä¸ªæ•°å¤§äº2çš„å¤„ç†ï¼ˆæå–å…¬å…±è¡¨ï¼‰ï¼Œ3.4ã€æ¶‰åŠè¡¨ä¸ªæ•°ç­‰äº2çš„å¤„ç†ï¼ˆè·å– Item_func_eqï¼‰
      MakeRelationalExpressionFromJoinList(thd, query_block->m_table_nest); // é€’å½’éå† join_cond ä¸­çš„æ¯ä¸ªä¸€ AND é¡¹ç›®ï¼Œç„¶åå­˜æ”¾åˆ° Mem_root_array<Item *> join->join_conditions æ•°ç»„ä¸­ï¼Œæ¶ˆé™¤å¤šä½™çš„è¿‡æ»¤æ¡ä»¶ï¼Œé‡æ’åº Mem_root_array<Item *> æ•°ç»„

-exec mysql RelationalExpression root
å¯¹åº”çš„å›¾
```
![alt text](pic/001.png)
å¯ä»¥è§‚å¯Ÿåˆ°ï¼Œå› ä¸º WHERE æ¡ä»¶ä¸­ä¼šå¯¹ LEFT JOIN å³è¾¹çš„è¡¨æ‹’ç» NULLï¼Œæ‰€ä»¥è¿æ¥è¢«è½¬æ¢æˆäº† INNER JOIN
```sql
  CompanionSetCollection companion_collection(thd, root);
```
![alt text](pic/002.png)
```sql
  FlattenInnerJoins(root);  // å¦‚æœ RelationalExpression ç¬¦åˆè½¬æ¢æˆ MULTI_INNER_JOIN è¦æ±‚ï¼Œé‚£ä¹ˆæŸ¥çœ‹å®ƒå·¦å³å­©å­ï¼Œå¦‚æœä¹Ÿæ˜¯ MULTI_INNER_JOINï¼Œé‚£ä¹ˆåˆå¹¶æˆä¸€ä¸ªæ›´å¤§çš„ MULTI_INNER_JOIN
```
![alt text](pic/003.png)

```sql
  PushDownJoinConditions(thd, root, companion_collection, &table_filters, // æŠŠæ•´ä¸ª expr->join_conditions ä¸‹æ¨ï¼Œé€’å½’ expr->leftã€expr->right æˆ–è€… expr->multi_children
                         &cycle_inducing_edges, trace);
```
è¯¥ä¾‹å­ä¸­æ‰€æœ‰ expr->join_conditions éƒ½æ˜¯ ç©ºæ•°ç»„ï¼Œæ‰€ä»¥æ²¡å˜åŒ–
![alt text](pic/004.png)

```sql
æŸ¥çœ‹ query_block->join->where_cond
-exec mysql Item graph->query_block()->join->where_cond
@startuml

map Item_0x7fff3ca6c238 #header:Gold;back:orange{
         __dynamic_type => Item_cond_and
         __print => (
            (
                  (multiple equal(1, `test`.`t1`.`b`) and multiple equal(2, `test`.`t2`.`b`)) 
               or (multiple equal(1, `test`.`t1`.`b`) and multiple equal(2, `test`.`t2`.`c`))
            ) 
            and (0 <> `test`.`t3`.`id`) 
            and multiple equal(1, `test`.`t1`.`a`, `test`.`t2`.`a`, `test`.`t3`.`a`) 
            and multiple equal(`test`.`t1`.`id`, `test`.`t3`.`id`, `test`.`t2`.`id`)
            )
}


Item *where_cond = EarlyExpandMultipleEquals(join->where_cond, // åœ¨ join ä¸‹æ¨å‰å±•å¼€ multiple equalitiesï¼Œè¿”å› AND conjunctionã€‚1ã€æ ‡é‡å¤„ç†ï¼Œ2ã€å¸¸é‡å¤„ç†ï¼ˆæ¯ä¸ªå­—æ®µå¡«å……å¸¸é‡ï¼‰ï¼Œ3ã€æ¶‰åŠè¡¨ä¸ªæ•°å¤§äº2çš„å¤„ç†ï¼ˆæå–å…¬å…±è¡¨ï¼‰ï¼Œ4ã€æ¶‰åŠè¡¨ä¸ªæ•°ç­‰äº2çš„å¤„ç†ï¼ˆè·å– Item_func_eqï¼‰

-exec mysql Item where_cond
@startuml

map Item_0x7fff3ca6c238 #header:Gold;back:orange{
         __dynamic_type => Item_cond_and
         __print => (
            (
                  ((`test`.`t1`.`b` = 1) and (`test`.`t2`.`b` = 2)) 
               or ((`test`.`t1`.`b` = 1) and (`test`.`t2`.`c` = 2))
            ) 
            and (0 <> `test`.`t3`.`id`) 
            and ((`test`.`t1`.`a` = 1) and (`test`.`t2`.`a` = 1) and (`test`.`t3`.`a` = 1)) 
            and multiple equal(`test`.`t1`.`id`, `test`.`t3`.`id`, `test`.`t2`.`id`)
            )
}
@enduml
1ã€æ ‡é‡å¤„ç†   æ— 
2ã€å¸¸é‡å¤„ç†   å¯ä»¥çœ‹åˆ°å·²ç» and ((`test`.`t1`.`a` = 1) and (`test`.`t2`.`a` = 1) and (`test`.`t3`.`a` = 1))  è¿™é‡Œæ˜¯ä»å¸¸é‡å¡«å…… multiple equal(1, `test`.`t1`.`a`, `test`.`t2`.`a`, `test`.`t3`.`a`)  è½¬æ¢è¿‡æ¥çš„
3ã€æ¶‰åŠè¡¨ä¸ªæ•°å¤§äº2çš„å¤„ç†ï¼ˆæå–å…¬å…±è¡¨ï¼‰ æ— 
4ã€æ¶‰åŠè¡¨ä¸ªæ•°ç­‰äº2çš„å¤„ç†ï¼ˆè·å– Item_func_eqï¼‰ æ— 



    if (ExtractConditions(where_cond, &where_conditions)) { // é€’å½’éå† condition ä¸­çš„æ¯ä¸ªä¸€ AND é¡¹ç›®ï¼Œç„¶åå­˜æ”¾åˆ° condition_parts æ•°ç»„ä¸­
      return true;
    }
-exec mysql Mem_root_array where_conditions

```
![alt text](pic/005.png)
```sh
    if (EarlyNormalizeConditions(thd, /*join=*/nullptr, &where_conditions,  // æ€»ä½“æ€æƒ³æ˜¯ï¼šæ¶ˆé™¤å¤šä½™çš„è¿‡æ»¤æ¡ä»¶
                                 where_is_always_false)) {
```
![alt text](pic/006.png)
å¯ä»¥çœ‹åˆ°orä¸­çš„å…¬å…±è¡¨è¾¾å¼è¢«æ¶ˆé™¤ï¼š   (`test`.`t1`.`b` = 1) and ((`test`.`t2`.`b` = 2) or (`test`.`t2`.`c` = 2))

    where_conditions = PushDownAsMuchAsPossible(   // éå† conditions æ•°ç»„ï¼Œå°½å¯èƒ½åœ°æŠŠè¿­ä»£å™¨ä¸‹æ¨
        thd, std::move(where_conditions), root,
        /*is_join_condition_for_expr=*/false, companion_collection,
        &table_filters, &cycle_inducing_edges, trace);

æŸ¥çœ‹ where_conditions å˜åŒ–ï¼Œå‘ç°å°‘äº† multiple equal
-exec mysql Mem_root_array where_conditions
![alt text](pic/007.png)
æŸ¥çœ‹ root å˜åŒ–
-exec mysql RelationalExpression root
![alt text](pic/008.png) 
å‘ç°åˆšæ‰å°‘äº†çš„æ¡ä»¶ï¼Œè¢«ä¸‹æ¨åˆ°äº† INNSER JOIN ä¸­

    UnflattenInnerJoins(root);  // æŠŠ RelationalExpression å±•å¼€æˆ å³æ·±äºŒå‰æ ‘
æ²¡å‘ç° root å˜åŒ–

    if (CanonicalizeConditions(thd, GetVisibleTables(root), // è§„èŒƒåŒ– Conditionsï¼šæŠŠ (A.x, B.x, D.x, E.x)ã€allowed_tables={A,B,C,D} è½¬æ¢æˆ  A.x = B.x and B.x = D.x (E.x is ignored). ç„¶åé‡æ–°æ‹†åˆ† conditions æˆæ–°çš„æ•°ç»„ï¼Œæ¯”å¦‚å‰é¢çš„ä¾‹å­æ‹†æˆ A.x = B.x å’Œ B.x = D.x
                               TablesBetween(0, MAX_TABLES),
                               &where_conditions)) {
æ²¡å‘ç° rootã€where_conditions å˜åŒ–

  LateConcretizeMultipleEqualities(thd, root); // ä» MultipleEqualities æ‰¾åˆ°ä¸€æ¡è¾¹è¿æ¥ expr->leftã€expr->right
æ²¡å‘ç° root å˜åŒ–

  PushDownJoinConditionsForSargable(thd, root); // éå†  expr->join_conditionsï¼Œå°è¯•ä¸‹æ¨æ¡ä»¶ï¼ˆç±»ä¼¼ PushDownCondition()ï¼‰æ”¾åˆ° expr->join_conditions_pushable_to_thisã€‚ç„¶åé€’å½’ expr->leftã€expr->right
-exec mysql RelationalExpression root
![alt text](pic/009.png)
å‘ç° RelationalExpression ä¸­çš„ join_conditions è¢«ä¸‹æ¨åˆ°å¶å­èŠ‚ç‚¹çš„ TABLE ä¸Š

  if (CanonicalizeJoinConditions(thd, root)) { // è§„èŒƒåŒ– JoinConditionsï¼šå…ˆè§„èŒƒåŒ– expr->join_conditionsï¼Œç„¶åéå† expr->join_conditionsï¼Œä¸å¤„ç†é‡Œé¢çš„å­æŸ¥è¯¢ã€æ ‡é‡ã€‚æœ€åé€’å½’è§„èŒƒåŒ– expr->left å’Œ expr->right
æ²¡å‘ç° root å˜åŒ–

  FindConditionsUsedTables(thd, root); // å¯¹ expr->conditions_used_tables èµ‹å€¼ï¼Œç„¶åé€’å½’
-exec mysql RelationalExpression root
![alt text]((pic/010.png)
INNER_JOIN çš„ conditions_used_tables è¢«èµ‹å€¼

  MakeHashJoinConditions(thd, root); // åœ¨ expr->join_conditions ä¸­æŸ¥æ‰¾ç¬¦åˆ hash join æ¡ä»¶çš„ itemï¼Œç„¶åæ·»åŠ åˆ° expr->equijoin_conditions ä¸­ï¼Œæ¥ç€åœ¨ expr->join_conditions ä¸­åˆ é™¤
-exec mysql RelationalExpression root
![alt text](pic/011.png)
å‘ç° INNER_JOIN ä¸­çš„ join_conditions è¢«ç§»åŠ¨åˆ° join_conditions

  ForEachOperator(root, [&](RelationalExpression *expr) {  // éå† RelationalExpression çš„ expr->leftã€expr->right ã€‚ç„¶åLAMBDAå‡½æ•°ä¸­ éå† expr->join_conditions_pushable_to_this ã€expr->equijoin_conditionsï¼Œæ›´æ–° expr->companion_set
-exec mysql RelationalExpression root
![alt text](pic/012.png)
å‘ç° companion_set ä¸­çš„å†…å®¹å‘ç°äº†å˜åŒ–

  MakeJoinGraphFromRelationalExpression(thd, root, trace, graph);  // 1ã€å¦‚æœ RelationalExpression æ˜¯è¡¨ï¼Œåˆ™æ›´æ–° JoinHypergraph çš„ graphã€nodesã€table_num_to_node_numï¼Œç„¶åæ›´æ–° RelationalExpression çš„ nodes_in_subtreeï¼Œç„¶åè¿”å›    // 2ã€å¦‚æœä¸æ˜¯è¡¨ï¼Œåˆ™é€’å½’å¤„ç†å®ƒçš„ left å’Œ rightï¼Œç„¶åæ›´æ–°å®ƒçš„ nodes_in_subtreeã€ç»™ expr->conflict_rules è®¡ç®—å¹¶èµ‹å€¼ã€graph->graph æ·»åŠ æ–°çš„è¾¹ã€è®¡ç®— expr çš„ selectivityï¼Œæœ€åæ„å»ºæ–°çš„ JoinPredicate æ”¾å…¥ graph->edges
æ‰§è¡Œä¹‹å‰
![alt text](pic/013.png)
æ‰§è¡Œä¹‹å
![alt text](pic/014.png)
ç»†çœ‹ root å˜åŒ– 
![alt text](pic/015.png)

  ClearImpossibleJoinConditions(root);  // éå† expr->equijoin_conditionsï¼Œå¦‚æœå‘ç°å®ƒæ¶‰åŠçš„è¡¨åªè¿”å›é›¶è¡Œæˆ–è€…åªè¿”å› NULL è¡Œï¼Œé‚£ä¹ˆæ¸…ç©º expr->equijoin_conditionsã€‚ç»§ç»­é€’å½’ expr->left å’Œ expr->right
æ²¡å‘ç°å˜åŒ–

  graph->tables_inner_to_outer_or_anti =
      GetTablesInnerToOuterJoinOrAntiJoin(root);  // è·å– expr çš„ LEFT_JOIN æˆ–è€… ANTIJOIN çš„å†…è¡¨
æ²¡å‘ç°å˜åŒ–

  if (!cycle_inducing_edges.empty()) {
    AddCycleEdges(thd, cycle_inducing_edges, companion_collection, graph, // éå† cycle_inducing_edges ä¸­çš„ Itemï¼Œå¦‚æœåœ¨ JoinHypergraph çš„ edges æ²¡æ‰¾åˆ°å¯¹åº”çš„è¾¹ï¼Œåˆ™æ„å»ºæ–°çš„ JoinPredicate å¹¶æ·»åŠ åˆ° JoinHypergraph çš„ edgesã€‚å¦‚æœæ‰¾åˆ°å¯¹åº”çš„è¾¹ï¼Œåˆ™æ›´æ–°å®ƒçš„ selectivityã€‚ æœ€å JoinHypergraph çš„å¯¹åº” nodes çš„ join_conditions_pushable_to_this æ·»åŠ  condï¼Œå½¢æˆå›ç¯ã€‚
                  trace);
  }
æ­¤æ—¶ cycle_inducing_edges ä¸ºç©ºï¼Œæ‰€ä»¥æ²¡å˜åŒ–

  ExtractCycleMultipleEqualitiesFromJoinConditions(root, companion_collection,  // éå† expr->equijoin_conditionsï¼Œå¦‚æœè¿­ä»£å™¨ source_multiple_equality ä¸ä¸ºç©ºï¼Œä¸”å®ƒæ»¡è¶³å…¨è¿æ¥ï¼Œåˆ™æŠŠ è¿­ä»£å™¨çš„ source_multiple_equality æ”¾å…¥  multiple_equalities æ•°ç»„
                                                   &multiple_equalities);
multiple_equalities ä¸­çš„ä¸¤ä¸ªå…ƒç´ é‡å¤
@startuml

map Item_0x7fff3ca6caa0 #header:Gold;back:orange{
         __dynamic_type => Item_equal
         __print => multiple equal(`test`.`t1`.`id`, `test`.`t3`.`id`, `test`.`t2`.`id`)
}

map Mem_root_array_Item_0x7fffcc161750 #header:Gold;back:Tomato {
         0x7fff3ca6caa0 => Item_equal *
         0x7fff3ca6caa0 => Item_equal *
}

Mem_root_array_Item_0x7fffcc161750::0x7fff3ca6caa0 -[#Tomato]-> Item_0x7fff3ca6caa0 : 0x7fff3ca6caa0
Mem_root_array_Item_0x7fffcc161750::0x7fff3ca6caa0 -[#Tomato]-> Item_0x7fff3ca6caa0 : 0x7fff3ca6caa0

@enduml


  ExtractCycleMultipleEqualities(where_conditions, companion_collection,  // éå† conditions æ•°ç»„ï¼Œå¦‚æœæ˜¯ = ç­‰å¼ï¼Œä¸”è¿­ä»£å™¨çš„ source_multiple_equality æ˜¯å…¨è¿æ¥ï¼Œåˆ™æŠŠè¯¥ source_multiple_equality æ”¾è¿› multiple_equalities æ•°ç»„
                                 &multiple_equalities);
æ­¤æ—¶ where_conditions ä¸­çš„å…ƒç´ çš„ source_multiple_equality ä¸ºç©ºï¼Œæ‰€ä»¥ multiple_equalities æ²¡å˜åŒ–

if (multiple_equalities.size() > 64) {  // multiple_equalities ä¸èƒ½è¶…è¿‡ 64 ä¸ªå…ƒç´ 
    multiple_equalities.resize(64);
  }
  std::sort(multiple_equalities.begin(), multiple_equalities.end());
  multiple_equalities.erase(
      std::unique(multiple_equalities.begin(), multiple_equalities.end()),
      multiple_equalities.end());
multiple_equalities å»é‡ 
@startuml

map Item_0x7fff3ca6caa0 #header:Gold;back:orange{
         __dynamic_type => Item_equal
         __print => multiple equal(`test`.`t1`.`id`, `test`.`t3`.`id`, `test`.`t2`.`id`)
}

map Mem_root_array_Item_0x7fffcc161750 #header:Gold;back:Tomato {
         0x7fff3ca6caa0 => Item_equal *
}

Mem_root_array_Item_0x7fffcc161750::0x7fff3ca6caa0 -[#Tomato]-> Item_0x7fff3ca6caa0 : 0x7fff3ca6caa0

@enduml

  CompleteFullMeshForMultipleEqualities(thd, multiple_equalities, // éå† multiple_equalities æ•°ç»„ï¼Œå¯¹å…¶ä¸­çš„æ¯ä¸ªå…ƒç´ çš„ multiple equality å…¨è¿æ¥çš„å…³ç³»ï¼Œæ‰§è¡Œ AddMultipleEqualityPredicate
                                        companion_collection, graph, trace);  // AddMultipleEqualityPredicate åŠŸèƒ½ï¼š1ã€å¦‚æœ right_node_idx å’Œ left_node_idx åœ¨è¶…å›¾ä¸­æ˜¯å¦å·²ç»å­˜åœ¨è¾¹ï¼Œåˆ™æŸ¥æ‰¾å¯¹åº”çš„ RelationalExpressionï¼ŒæŸ¥çœ‹ join_conditionsã€equijoin_conditionsï¼Œæ£€æŸ¥æ˜¯å¦æœ‰ Item_eq_base å±äº Item_equalï¼Œå¦‚æœæœ‰åˆ™è¿”å›ï¼Œå¦‚æœæ²¡å°±é‡æ–°è®¡ç®— å¯¹åº”çš„ graph->edges çš„ selectivity  2ã€å¦‚æœ right_node_idx å’Œ left_node_idx åœ¨è¶…å›¾ä¸­ä¸å­˜åœ¨å¯¹åº”çš„è¾¹ï¼Œåˆ™æ„å»ºæ–°çš„ JoinPredicate æ”¾å…¥ graph->edges  3ã€æœ€åæ„å»ºæ–°çš„ Item_func_eqï¼Œç„¶åæ”¾å…¥ expr->equijoin_conditions å¯¹åº”çš„ graph->nodes çš„ join_conditions_pushable_to_this

å˜åŒ–ä¹‹å‰
-exec mysql Hypergraph graph->graph
![alt text](pic/016.png)
å˜åŒ–ä¹‹å
-exec mysql Hypergraph graph->graph
![alt text](pic/017.png)
å‘ç° edges ä¸­æ·»åŠ äº†ä¸¤æ¡è¾¹

å˜åŒ–ä¹‹å‰
![alt text](pic/018.png)
å˜åŒ–ä¹‹å
![alt text](pic/019.png)
å‘ç° JoinPredicate æ·»åŠ äº†ä¸€ä¸ªæ–°å…ƒç´ ï¼Œå¯¹åº”åœ°å¤šäº†ä¸ª RelationalExpressioï¼Œå®ƒæ˜¯ INNER_JOIN


  if (graph->graph.edges.size() != old_graph_edges) {
    // We added at least one cycle-inducing edge.
    PromoteCycleJoinPredicates(thd, root, multiple_equalities, // éå† JoinHypergraph çš„ edgesï¼Œå¦‚æœå®ƒæœ‰å›ç¯ï¼Œåˆ™æŠŠ graph->edges[edge_idx / 2].expr çš„ equijoin_conditionsã€join_conditions æ·»åŠ åˆ° JoinHypergraph çš„ predicates
                               companion_collection, graph, trace);
  }
æ‰§è¡Œä¹‹å‰çš„ predicates å†…å®¹ä¸ºç©º
æ‰§è¡Œä¹‹åï¼Œpredicates æ·»åŠ äº† 3 ä¸ªå…ƒç´ ï¼Œä»–ä»¬æ¥è‡ª multiple_equalities çš„ Full Mesh è½¬æ¢
-exec mysql Mem_root_array graph->predicates
![alt text](pic/020.png)

  for (Item *condition : where_conditions) {  // éå† where_conditions (æ¥è‡ª query_block->join->where_cond çš„åŠ å·¥)
    AddPredicate(thd, condition, /*was_join_condition=*/false,  // æŠŠè¿™ä¸ªå‡½æ•°çš„å‚æ•°åˆå§‹åŒ– Predicate è°“è¯ï¼Œç„¶åæŠŠè¿™ä¸ªè°“è¯åŠ å…¥ JoinHypergraph çš„ predicatesã€‚è®¡ç®—å®ƒçš„ conditionã€used_nodesã€total_eligibility_setã€selectivityã€was_join_conditionã€source_multiple_equality_idxã€functional_dependencies_idxã€contained_subqueriesï¼Œç„¶åæ”¾åˆ° graph->predicates ä¸­
                 /*source_multiple_equality_idx=*/-1, root,
                 &companion_collection, graph, trace);
  }
æ‰§è¡Œå
-exec mysql Mem_root_array graph->predicates
æ‰§è¡Œä¹‹åï¼Œpredicates æ·»åŠ äº† 6 ä¸ªå…ƒç´ 
![alt text](pic/021.png)

  // Table filters should be applied at the bottom, without extending the TES.
  for (Item *condition : table_filters) { // æŠŠä¹‹å‰æ”¶é›†çš„ table_filters åŠ å…¥ JoinHypergraph çš„ predicates
    Predicate pred;
    pred.condition = condition;
    pred.used_nodes = pred.total_eligibility_set = GetNodeMapFromTableMap( // æ ¹æ® table_num è·å– node_num
        condition->used_tables() & ~(INNER_TABLE_BIT | OUTER_REF_TABLE_BIT),
        graph->table_num_to_node_num);
    assert(has_single_bit(pred.total_eligibility_set));
    pred.selectivity = EstimateSelectivity(
        thd, condition, *companion_collection.Find(condition->used_tables()),
        trace);
    pred.functional_dependencies_idx.init(thd->mem_root);
    graph->predicates.push_back(std::move(pred));
  }
å› ä¸º table_filters å†…å®¹ä¸ºç©ºï¼Œæ‰€ä»¥æ²¡å˜åŒ–

  SortPredicates(graph->predicates.begin() + num_cycle_predicates,
                 graph->predicates.end());

  graph->num_where_predicates = graph->predicates.size();

  return false;
}

æœ€åçš„ç»“æœï¼š
![alt text](pic/022.png)

è¿”å›åˆ°ä¸Šå±‚å‡½æ•°ä¸­
static AccessPath *FindBestQueryPlanInner(THD *thd, Query_block *query_block,
                                          bool *retry, int *subgraph_pair_limit,
                                          string *trace) {

  FindSargablePredicates(thd, trace, &graph); // 1ã€éå† graph->nodesã€éå† node.join_conditions_pushable_to_this 2ã€å¦‚æœ graph->predicates[i].condition å¯ä»¥åº”ç”¨ç´¢å¼•ï¼Œåˆ™æŠŠå®ƒ æ”¾åˆ° JoinHypergraph::Node->sargable_predicates
æ‰§è¡Œä¹‹å‰
-exec mysql Mem_root_array graph->nodes
![alt text](pic/023.png)
æ‰§è¡Œä¹‹å
-exec mysql Mem_root_array graph->nodes
![alt text](pic/024.png)
å‘ç° JoinHypergraph::Node->sargable_predicates ä¸­å¼€å§‹æœ‰å†…å®¹

  CacheCostInfoForJoinConditions(thd, query_block, &graph, trace);  // 1ã€éå† edge.expr->equijoin_conditionsï¼Œæ„é€  CachedPropertiesForPredicateï¼Œç„¶åæ”¾è¿› edge.expr->properties_for_equijoin_conditions  2ã€éå† edge.expr->join_conditionsï¼Œæ„é€  CachedPropertiesForPredicateï¼Œç„¶åæ”¾è¿› edge.expr->properties_for_join_conditions
-exec mysql Mem_root_array graph->edges
![alt text](pic/025.png)
å‘ç°  INNER JOIN ç±»å‹çš„ graph->edgesï¼Œå®ƒçš„ properties_for_equijoin_conditions æœ‰æ–°å†…å®¹


# ç»“è®º
```
1ã€RelationalExpression çš„ nodes_in_subtreeã€tables_in_subtree ä¸å— JOIN ç±»å‹ï¼ˆæ¯”å¦‚ SJã€AJï¼‰çš„å½±å“
2ã€å­æŸ¥è¯¢ å’Œ a+b=c éƒ½ä¸ä¼šå‡ºç°åœ¨ MULTI EQUAL ä¸­
3ã€MULTI_INNER_JOIN åªä¼šåœ¨ MakeJoinHypergraph çš„ä¸­é€”äº§ç”Ÿï¼Œå®ƒæ˜¯ç”± from t1,t2,t3 ... where è¿™ç§è¯­æ³•äº§ç”Ÿï¼Œå¦‚æœæ²¡ç¬›å¡å°”ç§¯åˆ™æœ€ç»ˆä¼šè¢«è½¬æ¢ä¸º INNER_JOINï¼Œç¬›å¡å°”ç§¯éƒ¨åˆ†ä¾ç„¶æ˜¯ MULTI_INNER_JOINã€‚åœ¨ MakeJoinHypergraph åï¼Œå…¨æ˜¯ INNER_JOINã€‚ç¬›å¡å°”è¡¨è·Ÿå…¶å®ƒè¡¨æ¯”è¾ƒï¼Œå°‘äº† join_conditions_pushable_to_thisï¼Œå…¨éƒ¨æœ‰ companion_set
```
![alt text](converted(1).png)

å…¶å®ƒå¯ä»¥ä¼˜åŒ–çš„åœ°æ–¹ï¼š
```
1ã€ multi equal(t1.a, t2.a, t2.b, t3.a) ä¼šè¢«è½¬æ¢æˆ t2.a=t2.b AND (original multi equal)ã€‚è¿™å¯ä»¥è®©æˆ‘ä»¬åç»­æŠŠ t2.a=t2.b ä¸‹æ¨ã€‚ å®ç°å‡½æ•°æ˜¯ ExpandSameTableFromMultipleEquals
    å¦‚æœæ˜¯ t1.id, t1.a, t1.b ï¼Œå®ƒåªä¼šè¢«è½¬æ¢æˆ  t1.id = t1.a å’Œ t1.a = t1.bï¼Œå…¶ä¸­ t1.id = t1.b ä¼šè¢« break



where t1.a=1 and t2.a=t1.a and t3.a=t1.a # å¸¸é‡æ›¿æ¢
      and ((t1.b = 1 and t2.b=2) or (t1.b=1 and t2.c=2)) # å…¬å…±å­è¡¨è¾¾å¼æ¶ˆé™¤åæ˜¯ (t1.b = 1 and ( t2.b= 2 or t2.c=2))
      and t3.id # æ ‡é‡å¤„ç†
       and t1.d=t2.d and t1.d=t3.d and t1.c=t2.d;

EarlyExpandMultipleEquals ä¹‹å‰
(
  (
    (
      multiple equal(1, `test`.`t1`.`b`) 
      and multiple equal(2, `test`.`t2`.`b`)
    ) 
    or 
    (
      multiple equal(1, `test`.`t1`.`b`) 
      and multiple equal(2, `test`.`t2`.`c`)
    )
  ) 
  and (0 <> `test`.`t3`.`id`) 
  and multiple equal(1, `test`.`t1`.`a`, `test`.`t2`.`a`, `test`.`t3`.`a`) 
  and multiple equal(`test`.`t1`.`d`, `test`.`t2`.`d`, `test`.`t3`.`d`, `test`.`t1`.`c`) 
  and multiple equal(`test`.`t1`.`id`, `test`.`t3`.`id`, `test`.`t2`.`id`)
)

EarlyExpandMultipleEquals ä¹‹å
(
  (
    (
      (`test`.`t1`.`b` = 1) 
      and (`test`.`t2`.`b` = 2)
    ) 
    or 
    (
      (`test`.`t1`.`b` = 1) 
      and (`test`.`t2`.`c` = 2)
    )
  ) 
  and (0 <> `test`.`t3`.`id`) 
  and (
        (`test`.`t1`.`a` = 1) 
        and (`test`.`t2`.`a` = 1) 
        and (`test`.`t3`.`a` = 1)
      )
  and (
        (`test`.`t1`.`d` = `test`.`t1`.`c`) 
        and multiple equal(`test`.`t1`.`d`, `test`.`t2`.`d`, `test`.`t3`.`d`, `test`.`t1`.`c`)
      ) 
  and multiple equal(`test`.`t1`.`id`, `test`.`t3`.`id`, `test`.`t2`.`id`)
)
```
```cpp
Query_block::prepare æµç¨‹
1ã€ å¤„ç† VALUES row_list ç±»å‹çš„ Query_blockï¼Œç„¶åç›´æ¥è¿”å›
2ã€ è®¾ç½® nullabilityã€‚  // æ¯”å¦‚ left join t1 on ...ï¼Œåˆ™è®¾ç½® t1 nullability
3ã€ è®¾ç½® allow_merge_derived
    å®ƒè¡¨ç¤ºæ˜¯å¦åˆå¹¶æ´¾ç”Ÿè¡¨ï¼Œåˆå¹¶æ´¾ç”Ÿè¡¨çš„è§„åˆ™æ˜¯ï¼š
    - å±äºæœ€å¤–å±‚ Query_block çš„DTsï¼šå§‹ç»ˆåˆå¹¶ã€‚åˆ¤æ–­æ˜¯å¦æœ€å¤–å±‚çš„æ–¹æ³•æ˜¯ï¼š master->master == nullptr
         ä¾‹å­ SELECT * FROM (SELECT * FROM table1) AS derived_table;  è¿™é‡Œçš„ derived_table å…è®¸è¢«åˆå¹¶
    - å±äºç¬¬ä¸€çº§å­æŸ¥è¯¢çš„DTsï¼šåˆ™åˆå¹¶ï¼Œ
         ä¾‹å­ SELECT * FROM table1 WHERE id IN (SELECT id FROM (SELECT * FROM table2) AS derived_table);  è¿™é‡Œå­æŸ¥è¯¢çš„ derived_table å…è®¸è¢«åˆå¹¶
    - æ‰€æœ‰å…¶ä»–æƒ…å†µç»§æ‰¿çˆ¶ Query_block çš„çŠ¶æ€ï¼Œè¦æ±‚ SQL ç±»å‹æ˜¯ SELECT æˆ–è€… SET
4ã€ å¦‚æœ thd æ²¡æœ‰æ­£åœ¨å¤„ç†æ´¾ç”Ÿè¡¨ï¼Œæˆ–è€… master çš„å­æŸ¥è¯¢ä¸ä¸º nullptrï¼Œåˆ™è®¾ç½®ä¸´æ—¶å˜é‡ check_privs ä¸º true
5ã€ thd->mark_used_columns = check_privs ? MARK_COLUMNS_READ : MARK_COLUMNS_NONE;
6ã€ ä¿å­˜ thd->want_privilegeï¼Œç„¶åè®¾ç½® thd->want_privilege = check_privs ? SELECT_ACL : 0;
7ã€ æ‰§è¡Œ Query_block::setup_tables(THD *thd, Table_ref *tables, bool select_insert) ï¼Œå®ƒä¼šæ£€æŸ¥æ‰€æœ‰è¡¨ã€å­—æ®µã€æ¡ä»¶ã€æ’åºæ˜¯å¦åˆæ³•
         7.1 éå† m_table_listï¼Œå­˜æ”¾åˆ° leaf_tables ä¸­
         7.2 éå† leaf_tables (æ›´æ–° Table_ref çš„ tablenoï¼ˆä» 0 å¼€å§‹é€’å¢ï¼‰ã€table çš„ ç´¢å¼•ä½¿ç”¨æƒ…å†µã€partitioned_table_count)
8ã€ å¤„ç† Query_block ä¸­çš„æ´¾ç”Ÿè¡¨ã€è¯•å›¾ã€è¡¨å‡½æ•°
         8.1 éå† m_table_list
             åªå¤„ç† æ´¾ç”Ÿè¡¨ã€è¯•å›¾ã€è¡¨å‡½æ•°
             å¦‚æœå·²ç»è¢«åˆå¹¶è¿‡æˆ–è€…ä½¿ç”¨ç‰©åŒ–ï¼Œåˆ™ continue
             å¤„ç†è¯¥ Table_ref çš„æ´¾ç”Ÿè¡¨ç”Ÿæˆ
             åˆå¹¶ä¸éœ€è¦ç‰©åŒ–çš„æ´¾ç”Ÿè¡¨ï¼Œæ•´ä¸ªTHDçš„ç”Ÿå‘½å‘¨æœŸï¼Œåªå¤„ç†ä¸€æ¬¡è¯¥åˆå¹¶å·¥ä½œ
             åˆå¹¶æ´¾ç”Ÿè¡¨æˆ–è€…è¯•å›¾åˆ°æœ¬ Query_blockï¼Œå¦‚æœæœ‰çº¦æŸå¯¼è‡´æ— æ³•åˆå¹¶ï¼Œåˆ™åœ¨åç»­çš„å·¥ä½œä¸­ç‰©åŒ–å®ƒ
             ä¸ºç‰©åŒ– table function åšé¢„å¤„ç†
             ä¸ºç‰©åŒ– ä¸å¯åˆå¹¶çš„æ´¾ç”Ÿè¡¨ã€è§†å›¾ åšé¢„å¤„ç†
9ã€ æ£€æŸ¥è§†å›¾çš„æƒé™
10ã€å¦‚æœ leaf_table_count >= 2ï¼Œåˆ™å¡«å…… natural join çš„å­—æ®µ
11ã€åˆå§‹åŒ– Mem_root_array<Item_exists_subselect *> sj_candidates ä¸ºç©º
12ã€å®‰è£… join conditions å’Œ WHERE clause è¯­å¥
         12.1 æŸ¥çœ‹ WHERE æ¡ä»¶æ˜¯å¦å¯ä»¥ç®€åŒ–ä¸º Item_func_true æˆ– Item_func_false
         12.2 éå† mem_root_deque<Table_ref *> m_table_nestï¼Œå¾ªç¯å˜é‡ä¸º tr
              å¦‚æœ tr->nested_join != nullptr åˆ™é€’å½’æ‰§è¡Œ setup_join_cond(thd, &tr->nested_join->m_tables, in_update)
              join æ¡ä»¶åœ¨ Table_ref çš„ m_join_cond å˜é‡ä¸­
              å¦‚æœ join æ¡ä»¶æ˜¯å¸¸é‡ï¼Œåˆ™ç®€åŒ–å®ƒä¸º Item_func_true æˆ– Item_func_false
13ã€å®‰è£… GROUP BY è¯­å¥
         13.1 å¦‚æœ group_list.elements ä¸ä¸º 0 åˆ™æ£€æŸ¥ GROUP BY è¯­æ³•æ˜¯å¦åˆæ³•
              ä¸‹é¢è¿™ä¸ªå‡½æ•°æ˜¯ ORDER BY æˆ– GROUP BY å­å¥ä¸­çš„åˆ—å¼•ç”¨è§£æ
              find_order_in_list(THD *thd, Ref_item_array ref_item_array, Table_ref *tables, ORDER *order, mem_root_deque<Item *> *fields, bool is_group_field, bool is_window_order)
              æ¯”å¦‚ GROUP BY çš„åˆ—è¡¨ä¸­æœ‰èšåˆå‡½æ•°ã€çª—å£å‡½æ•°ã€æˆ–è€…åµŒå¥— group byï¼Œè¿™äº›éƒ½æ˜¯ä¸åˆæ³•çš„
14ã€å®‰è£… HAVING è¯­å¥
         æ¯”å¦‚å¤„ç† rollupï¼Œç®€åŒ– having æ¡ä»¶ï¼Œç®€åŒ–çª—å£å‡½æ•°ä¸­çš„æ¡ä»¶ m_qualify_cond
15ã€å¤„ç† ORDER BY è¯­å¥
         ä¿®æ”¹ ORDER BY åˆ—è¡¨ä¸­çš„ item æŒ‡å‘ select list
         å¦‚æœ ORDER BY çš„ä¸æ˜¯æ•°å­—ï¼Œä¸”ä¸åœ¨ select list ä¸­ï¼Œåˆ™æŠŠå®ƒæ·»åŠ åˆ° field list
16ã€rollup å­—æ®µä¸èƒ½æ˜¯å…¨æ–‡æ£€ç´¢å­—æ®µ
17ã€å®‰è£… OFFSET å’Œ LIMIT è¯­å¥
19ã€å­æŸ¥è¯¢ä¸æ”¯æŒ LIMIT ,æ‰€ä»¥ä¼šç§»é™¤å®ƒçš„ ORDER BYã€DISTINCTï¼Œå¦‚æœæ²¡ã€€aggregate functionsã€€åˆ™ä¼šç§»é™¤ã€€GROUP BY å­å¥
20ã€Query_block æ­¤æ—¶å·²ç»å®Œå…¨ resolvedï¼Œå†æ¬¡å¤„ç† ORDER BY è¯­å¥
         æ£€æŸ¥ ORDER BY è¯­å¥æ˜¯å¦æœ‰å†—ä½™
         æ‹†åˆ†èšåˆå‡½æ•°
21ã€æ£€æŸ¥ DISTINCT è¯­å¥æ˜¯å¦å¯ä»¥è¢«æ¶ˆé™¤
22ã€æŠŠæ ‡é‡å­æŸ¥è¯¢è½¬æ¢ä¸º join æ´¾ç”Ÿè¡¨
         æ¯”å¦‚ SELECT (SELECT COUNT(a) FROM t2) + a FROM t1; # å­æŸ¥è¯¢åœ¨ join å¤–éƒ¨
         -->  SELECT derived.cnt + t1.a FROM t1 LEFT OUTER JOIN  (select COUNT(a) AS cnt FROM t2) AS derived ON TRUE;
         æ¯”å¦‚ SELECT * FROM t1 LEFT JOIN  t2 ON (SELECT COUNT(a) AS cnt FROM t2) = t1.a; # å­æŸ¥è¯¢åœ¨ join å†…éƒ¨
         -->  SELECT * FROM t1 LEFT JOIN (SELECT COUNT(t2.a) AS cnt FROM t2) derived_1_0 ON(TRUE) LEFT JOIN t2 ON derived_1_0.cnt = t1.a
         ä¸èƒ½è½¬æ¢ï¼šå­æŸ¥è¯¢è·Ÿ HAVING æ¡ä»¶ç›¸å…³
         æ¯”å¦‚ SELECT SUM(a), (SELECT SUM(b) FROM t3) scalar FROM t1 HAVING SUM(a) > scalar;
         æ¯”å¦‚ SELECT MAX(a) FROM t1 WHERE FALSE HAVING (SELECT MIN(a) FROM t1) > 0;
         TODOï¼š
         ä¸èƒ½è½¬æ¢çš„ä¾‹å­1ä¸­ï¼Œå…¶å®ƒå®ƒå¯ä»¥è½¬æ¢æˆ
         SELECT derived0.summ, derived1.scalar FROM (SELECT SUM(a) AS summ FROM t1) AS derived0 LEFT JOIN (SELECT SUM(b) AS scalar FROM t3) AS derived1 ON TRUE WHERE derived0.sum > derived1.scalar;
23ã€å¤„ç† If GROUPING function is present in having condition ï¼ˆæ²¡ç»†çœ‹ï¼‰
24ã€å¤„ç†å®Œ HAVING è¯­å¥åï¼Œå¤„ç† full-text å‡½æ•°
25ã€è®¾ç½® Query_block::m_query_result->unit = unit
26ã€å±•å¼€å¯ä»¥è½¬æ¢ä¸º semic join çš„å­æŸ¥è¯¢
         æ¯”å¦‚æŠŠ SELECT ... FROM ot, ...  WHERE oe IN (SELECT ie FROM it1 ... itN WHERE subq_where) AND outer_where
              è½¬æ¢ä¸º SELECT ... FROM ot SEMI JOIN (it1 ... itN), ... WHERE outer_where AND subq_where AND oe=ie
27ã€å¦‚æœæ˜¯æœ€å¤–å±‚ Query_blockï¼Œæˆ–è€… 
         (
            (parent_lex->sql_command == SQLCOM_SET_OPTION || parent_lex->sql_command == SQLCOM_END || parent_lex->sql_command == SQLCOM_LOAD) 
            && outer_query_block()->outer_query_block() == nullptr
         )
    åˆ™æ‰§è¡Œå‡½æ•° apply_local_transforms(thd, true)ï¼Œå®ƒåªé€‚ç”¨ä»¥ä¸‹åœºæ™¯
      1ã€å¦‚æœè¿™ä¸æ˜¯åˆ›å»ºè§†å›¾çš„è¯­å¥ï¼Œå› ä¸ºåœ¨åˆ›å»ºè§†å›¾æ—¶ä¸éœ€è¦è¿›è¡Œè½¬æ¢ã€‚
      2ã€å¦‚æœè¿™æ˜¯ SELECT æˆ–å¤šè¡¨ UPDATE/DELETE è¯­å¥çš„æœ€å¤–å±‚æŸ¥è¯¢å—ã€‚æ³¨æ„ï¼Œå¯¹äº UNIONï¼Œè¿™é€‚ç”¨äºæ‰€æœ‰æŸ¥è¯¢å—ã€‚å®ƒä¹Ÿé€‚ç”¨äº fake_query_block å¯¹è±¡ã€‚
      3ã€å¦‚æœè¿™æ˜¯æœ€é«˜çº§åˆ«çš„å­æŸ¥è¯¢ä¹‹ä¸€ï¼Œå¦‚æœè¯­å¥æ˜¯å…¶ä»–å†…å®¹ï¼›æ¯”å¦‚åœ¨ UPDATE t1 SET col1=(subq-1), col2=(subq-2); ä¸­çš„ subq-iã€‚
      4ã€å¦‚æœè¿™æ˜¯ SET å‘½ä»¤ä¸­çš„å­æŸ¥è¯¢ï¼Œæˆ–è€…ç”¨äº SP è¡¨è¾¾å¼ï¼ˆå¦‚ sp_instr_freturnï¼‰ä¸­çš„æ ‡é‡å­æŸ¥è¯¢ï¼ˆç”± SQLCOM_END æŒ‡ç¤ºï¼‰ã€‚
      5ã€å¦‚æœè¿™æ˜¯ LOAD å‘½ä»¤ä¸­çš„å­æŸ¥è¯¢ã€‚
      6ã€INSERT åœ¨æŸäº›æƒ…å†µä¸‹å¯èƒ½ä¼šé€šè¿‡åœ¨è°ƒç”¨ prepare() ä¹‹å‰è®¾ç½® skip_local_transforms æ ‡å¿—æ¥æ”¹å˜å‡†å¤‡è°ƒç”¨çš„é¡ºåºã€‚

      åœ¨æŸ¥è¯¢å—åˆå¹¶ä¹‹ååº”ç”¨æœ¬åœ°è½¬æ¢ã€‚è¿™æ„å‘³ç€æˆ‘ä»¬é¿å…äº†ä¸å¿…è¦çš„è°ƒç”¨ï¼Œå› ä¸ºæœ¬åœ°è½¬æ¢å¦åˆ™ä¼šåœ¨æŸ¥è¯¢å—åˆå¹¶ä¹‹å‰é¦–å…ˆæ‰§è¡Œï¼Œç„¶ååœ¨æŸ¥è¯¢å—åˆå¹¶ä¹‹åå†æ‰§è¡Œä¸€æ¬¡ã€‚å› æ­¤ï¼Œapply_local_transforms() å¯èƒ½åªåœ¨é¡¶çº§æŸ¥è¯¢å®ŒæˆæŸ¥è¯¢å—åˆå¹¶åè¿è¡Œã€‚
      è¿™å°±æ˜¯ä¸ºä»€ä¹ˆ apply_local_transforms() åªç”±é¡¶çº§æŸ¥è¯¢å¯åŠ¨ï¼Œç„¶åé€’å½’åˆ°å­æŸ¥è¯¢ã€‚

    å‡½æ•° apply_local_transforms(thd, true) çš„åŠŸèƒ½æ˜¯ï¼š
      1ã€åˆ é™¤æ´¾ç”Ÿè¡¨ä¸­å¤šä½™çš„å­—æ®µ
      2ã€å­æŸ¥è¯¢å†…éƒ¨ Query_block æ‰§è¡Œæœ¬åœ°è½¬æ¢
      3ã€å¦‚æœæ¡ä»¶å…è®¸ï¼Œåˆ™æŠŠ outer join è½¬æ¢ä¸º inner joinã€‚å»æ‰ join è¯­å¥ä¸­å¤šä½™çš„æ‹¬å·ï¼Œæ£€æŸ¥ join è°“è¯æ˜¯å¦åˆæ³•
      4ã€æ›´æ–° Table_ref çš„ outer_joinã€sj_inner_tablesã€sj_nests
      5ã€åˆ†åŒºè¡¨è£å‰ª
      6ã€æŠŠä¸€äº›æ¡ä»¶ä¸‹æ¨ç»™æ´¾ç”Ÿè¡¨ï¼Œè¿™æœ‰åŠ©äºæ´¾ç”Ÿè¡¨å†…éƒ¨å¯ä»¥æŠŠLEFT JOIN è½¬æ¢ä¸º INNSER JOIN
28ã€æ¶ˆé™¤æœªä½¿ç”¨çš„çª—å£å®šä¹‰ï¼Œå†—ä½™çš„æ’åºç­‰
29ã€åœ¨çª—å£å‡½æ•°å†…éƒ¨æŠŠ group by å­—æ®µçš„å¼•ç”¨æ›¿æ¢ä¸º ROLLUP çš„å¼•ç”¨
30ã€å¦‚æœæœ‰ CUBEï¼Œåˆ™æŠŠæœ‰ GROUP BY çš„è¡¨è¾¾å¼éœ€è¦æ ‡è®°ä¾èµ– grouping set
      CUBE çš„ SQL : SELECT Item, Color, SUM(Quantity) AS QtySum FROM Inventory GROUP BY Item, Color WITH CUBE;


Query_block::optimize(THD *thd, bool finalize_access_paths) æµç¨‹
1ã€join = new (thd->mem_root) JOIN(thd, this)
2ã€æ‰§è¡Œ join->optimize(finalize_access_paths)
3ã€éå† Query_block ä¸‹é¢æ‰€æœ‰çš„ Query_expression query_expressionï¼Œ
         æ‰§è¡Œ query_expression->optimize(thd, /*materialize_destination=*/nullptr, /*create_iterators=*/false, /*finalize_access_paths=*/true)


Query_expression::prepare æµç¨‹
1ã€åœ¨ Sql_cmd_select::prepare_inner æ‰§è¡Œè¿‡ç¨‹ä¸­ï¼Œå¦‚æœ Query_expression ä¸æ˜¯ç®€å•æŸ¥è¯¢ï¼ˆå¤šä¸ª Query_blockï¼‰,æ‰ä¼šè¿›å…¥è¯¥æµç¨‹ unit->prepare(thd, result, nullptr, SELECT_NO_UNLOCK, 0)
2ã€è®¾ç½® m_query_result ä¸ºå‚æ•°ä¸­çš„ result
3ã€è®¾ç½® thd->lex->m_current_query_block ä¸º first_query_block()
4ã€å¦‚æœ Query_expression ä¸æ˜¯ç®€å•æŸ¥è¯¢ï¼ˆå¤šä¸ª Query_blockï¼‰ï¼Œè®¾ç½® m_query_term->m_is_materialized
5ã€è®¾ç½® first_query_block()->context.resolve_in_select_list = true
6ã€éå† Query_expression ä¸‹é¢æ‰€æœ‰çš„ Query_block sl
         6.1 å¦‚æœ  Query_expression æ˜¯ç®€å•æŸ¥è¯¢ï¼Œåˆ™è®¾ç½® sl->m_query_result
         6.2 sl->make_active_options(added_options | SELECT_NO_UNLOCK, removed_options)
         6.3 thd->lex->set_current_query_block(sl)
         6.4 å¤„ç†é€’å½’æŸ¥è¯¢çš„ SQL ä¿¡æ¯
         6.5 æ‰§è¡Œ sl->prepare(thd, insert_field_list)
         6.6 å¦‚æœä¸æ˜¯  QT_UNION || type == QT_INTERSECT || type == QT_EXCEPTï¼Œ 
                  åˆ™æŠŠ first_query_block()->visible_fields() çš„æ‰€æœ‰å­—æ®µ push_back  åˆ° Query_expression ä¸­çš„ mem_root_deque<Item *> types
             å¦åˆ™ï¼Œå¦‚æœ sl == first_query_block()
                  åˆ™æŠŠ first_query_block()->visible_fields() çš„æ‰€æœ‰å­—æ®µ push_back  åˆ° Query_expression ä¸­çš„ mem_root_deque<Item *> typesï¼Œè¿™é‡Œä¼šæœ‰äº›å…¶å®ƒç‰¹æ®Šå¤„ç†ï¼Œæ¯”å¦‚é€’å½’æŸ¥è¯¢çš„ SQL
             å¦åˆ™ï¼Œç»§ç»­å¤„ç†å­—æ®µ
7ã€å¦‚æœæ˜¯é€’å½’æŸ¥è¯¢çš„ SQL åˆ™æ‰§è¡Œ check_materialized_derived_query_blocks(thd)
8ã€å¦‚æœä¸æ˜¯ simple_query_expression åˆ™æ‰§è¡Œ 
         Query_expression::prepare_query_term(thd, query_term(), /*common_result*/ nullptr, added_options, create_options, /*level*/ 0, nullable)
         å®ƒæ¶‰åŠå¦‚ä½•å‡†å¤‡æŸ¥è¯¢é¡¹èŠ‚ç‚¹ï¼Œè®¾ç½®åå¤„ç†æŸ¥è¯¢å—ï¼Œä»¥åŠåˆ›å»ºä¸´æ—¶è¡¨
9ã€è®¾ç½® prepared = true



Query_expression::optimize(THD *thd, TABLE *materialize_destination, bool create_iterators, bool finalize_access_paths)  æµç¨‹
1ã€ Sql_cmd_dml::execute_inner(THD *thd) è°ƒç”¨çš„æ˜¯ 
         unit->optimize(thd, /*materialize_destination=*/nullptr, /*create_iterators=*/true, /*finalize_access_paths=*/true)
2ã€ è®¾ç½®ä¸´æ—¶å˜é‡ estimated_rowcount = 0   estimated_cost = 0.0
3ã€ è®¾ç½® m_query_result->estimated_rowcount = 0
4ã€ éå† Query_expression ä¸‹é¢æ‰€æœ‰çš„ Query_block query_blockï¼Œ
          4.1 è®¾ç½® thd->lex->m_current_query_block = query_block
          4.2 è®¾ç½® Query_expression çš„ offset_limit_cnt å’Œ select_limit_cnt
          4.3 æ‰§è¡Œ query_block->optimize(thd, finalize_access_paths)
          4.4 ç´¯è®¡è¯„ä¼°çš„è¡Œæ•°
                 å¯¹äº INTERSECT æˆ– EXCEPTï¼Œåªéœ€è¦è€ƒè™‘å·¦ä¾§æŸ¥è¯¢çš„è¡Œæ•°
                 estimated_rowcount += query_block->join->best_rowcount
                 estimated_cost += query_block->join->best_read
                 m_query_result->estimated_rowcount = estimated_rowcount
                 m_query_result->estimated_cost = estimated_cost
5ã€ å¦‚æœä¸æ˜¯ç®€å•æŸ¥è¯¢ï¼ˆæ¯”å¦‚ UNIONã€INTERSECTã€EXCEPTï¼‰ï¼Œåˆ™æ‰§è¡Œ m_query_term->open_result_tables(thd, 0) åˆ›å»ºç»“æœä¸´æ—¶è¡¨
6ã€ å¦‚æœä¸æ˜¯ç®€å•æŸ¥è¯¢ï¼Œåˆ™æ‰§è¡Œ
          6.1 optimize_set_operand(thd, this, query_term())
              6.1.1 æ ¹æ® Query_term è®¾ç½® Query_expression çš„ LIMIT  
              6.1.2 å¦‚æœæ˜¯ (...) ORDER BY ... LIMIT ... è¿™ç§ç±»å‹çš„ SQLï¼Œæˆ–è€…å·²ç»ç‰©åŒ–ï¼Œåˆ™æ‰§è¡Œ m_query_block->optimize(thd, /*finalize_access_paths=*/true)ã€‚
                    å› ä¸ºæ²¡æœ‰ ORDER BY ... LIMIT ... çš„è¯ï¼Œæˆ‘ä»¬å¯ä»¥æŠ˜å å®ƒ
              6.1.3 éå† Query_term_set_op çš„ m_childrenï¼Œé€’å½’æ‰§è¡Œ optimize_set_operand
          6.2 set_limit(thd, query_term()->query_block())
              è®¾ç½®  Query_expression çš„ offset_limit_cntã€select_limit_cnt
          6.3 å¦‚æœä¸æ˜¯ union åˆ™æ‰§è¡Œ query_result()->set_limit(select_limit_cnt)
7ã€ è®¾ç½® m_query_result->estimated_rowcount = estimated_rowcount    m_query_result->estimated_cost = estimated_cost
8ã€ å¦‚æœ  estimated_rowcount <= 1 || use_iterator(materialize_destination, query_term()) åˆ™æ‰§è¡Œ create_access_paths(thd)
        å¦‚æœ materialize_destination != nullptr && can_materialize_directly_into_result() 
                   åˆ™æ‰§è¡Œ m_operands = set_operation()->setup_materialize_set_op( thd, materialize_destination, /*union_distinct_only=*/false, calc_found_rows)
            å…¶å®ƒæƒ…å†µæ‰§è¡Œ create_access_paths(thd)
9ã€ è®¾ç½® optimized = true
10ã€å¦‚æœ item != nullptrï¼Œå³æœ‰å­æŸ¥è¯¢çš„æ„æ€ï¼Œåˆ™æ‰§è¡Œ item->create_iterators(thd)
11ã€å¦‚æœ create_iterators && IteratorsAreNeeded(thd, m_root_access_path)ï¼Œåˆ™æ‰§è¡Œ
        JOIN *join = query_term()->query_block()->join;
        æ‰§è¡Œ m_root_iterator = CreateIteratorFromAccessPath(thd, m_root_access_path, join, /*eligible_for_batch_mode=*/true)
        å¦‚æœå¼€å¯ hypergraph_optimizerï¼Œä¸”å®Œæˆæ‰€æœ‰çš„å…¨æ–‡æœç´¢å‡½æ•°ï¼Œåˆ™è¿”å› true
12ã€å¦‚æœæ˜¯æœ€å¤–å±‚çš„ Query_expressionï¼Œä¸” EstimateRowAccesses(m_root_access_path, /*num_evaluations=*/1.0, std::numeric_limits<double>::infinity()) > static_cast<double>(thd->variables.max_join_size))ï¼Œåˆ™è¿”å› true
13ã€è¿”å› false


JOIN::optimize(bool finalize_access_paths) æµç¨‹
1ã€ æ‰§è¡Œå‡½æ•° count_field_types(query_block, &tmp_table_param, *fields, false, false) ä¸ºä¸´æ—¶è¡¨åˆ›å»ºå­—æ®µ
2ã€ å¦‚æœæœ‰çª—å£å‡½æ•°åˆ™æ‰§è¡Œ Window::setup_windows2(thd, &m_windows)
3ã€ ä¸ºæå‡ sum_func çš„è®¡ç®—æ•ˆç‡ï¼Œåˆ›å»º sum_functions æ•°ç»„
4ã€ æ‰§è¡Œå‡½æ•° query_block->get_optimizable_conditions(thd, &where_cond, &having_cond)
           4.1 æŠŠ query_block->m_where_cond æ‹·è´åˆ° JOIN::where_cond
           4.2 æŠŠ query_block->m_having_cond æ‹·è´åˆ° JOIN::having_cond
           4.3 æ‰§è¡Œå‡½æ•° get_optimizable_join_conditions(thd, /*mem_root_deque<Table_ref *> &*/m_table_nest)
                  4.3.1 éå†  query_block->m_table_nest table
                              NESTED_JOIN *const nested_join = table->nested_join
                              æ‰§è¡Œå‡½æ•° get_optimizable_join_conditions(thd, nested_join->m_tables)
                              å¦‚æœæ˜¯æ­£å¸¸SQLè¯­å¥ï¼ˆé prepared è¯­å¥ã€éå­˜å‚¨è¿‡ç¨‹è¯­å¥ï¼‰ï¼Œåˆ™æŠŠ table->m_join_cond æ‹·è´åˆ° table->m_join_cond_optim
                                  å¦åˆ™æŠŠ table->m_join_cond èµ‹å€¼ç»™ table->m_join_cond_optim
5ã€ éå† query_block->rollup_group_items item ç„¶å JOIN::rollup_group_items.push_back(item)
6ã€ éå† query_block->rollup_sums item ç„¶å JOIN::rollup_sums.push_back(item)
7ã€ è®¾ç½® optimized = true
8ã€ è®¾ç½® tables_list = query_block->leaf_tables
9ã€ ä¸º ref_itemsã€tmp_fields åˆ†é…å†…å­˜
10ã€è®¾ç½® ref_items[REF_SLICE_ACTIVE] = query_block->base_ref_items
11ã€éå†  query_block->leaf_tables tl
           tl->access_path_for_derived = nullptr
           å¦‚æœ tl æ˜¯è§†å›¾æˆ–è€…æ´¾ç”Ÿè¡¨ï¼Œåˆ™æ‰§è¡Œ tl->optimize_derived(thd)ï¼Œç„¶åè¿”å›
           å¦‚æœ t1 æ˜¯è¡¨å‡½æ•°ï¼Œåˆ™æ‰§è¡Œ setup_tmp_table_handler(thd, table, query_block->active_options() | TMP_TABLE_ALL_COLUMNS)
                              è®¾ç½® table->file->stats.records = 2
12ã€å¦‚æœå¼€å¯ hypergraph_optimizerï¼Œ
           éå† query_block ä¸‹é¢çš„ Query_expression unit
                  å¦‚æœ unit æ²¡æ‰§è¡Œè¿‡ optimizeï¼Œåˆ™æ‰§è¡Œ unit->optimize(thd, /*materialize_destination=*/nullptr, /*create_iterators=*/false, /*finalize_access_paths=*/false)           
           æ‰§è¡Œ query_block->add_active_options(OPTION_NO_CONST_TABLES | OPTION_NO_SUBQUERY_DURING_OPTIMIZATION)
                  å› ä¸º hypergraph optimizer ä¸ä¼šå¤„ç†å¸¸é‡è¡¨ä¹Ÿä¸ä¼šå¤„ç†å­æŸ¥è¯¢
13ã€è®¾ç½® has_lateral = false
14ã€è®¾ç½® row_limit = ((select_distinct || !order.empty() || !group_list.empty()) ? HA_POS_ERROR : query_expression()->select_limit_cnt)
15ã€è®¾ç½® m_select_limit = query_expression()->select_limit_cnt
16ã€å¦‚æœæ˜¯æœ€å¤–å±‚çš„ Query_block åˆ™è®¾ç½® calc_found_rows = m_select_limit != HA_POS_ERROR && (!query_expression()->is_set_operation() || query_block == set_operand_block)
17ã€å¦‚æœ query_expression()->select_limit_cnt == 0 && !calc_found_rows åˆ™æ‰§è¡Œå‡½æ•° set_root_access_path(create_access_paths_for_zero_rows())ï¼Œç„¶å goto setup_subq_exit
18ã€å¦‚æœ where_cond || query_block->outer_join
           18.1 æ‰§è¡Œ optimize_cond(thd, /*Item **cond*/&where_cond, /*COND_EQUAL **cond_equal*/&cond_equal, /*mem_root_deque<Table_ref *> *join_list*/&query_block->m_table_nest, 
                                           /*Item::cond_result *cond_value*/&query_block->cond_value)
                     18.1.1 æ„å»º multiple equality predicates
                     18.1.2 æ‰§è¡Œå¸¸é‡æ›¿æ¢å­—æ®µ
                     18.1.3 å¦‚æœæ¡ä»¶ç»“æœæ°¸è¿œæ˜¯ true æˆ–è€… falseï¼Œåˆ™åˆ é™¤æ¡ä»¶
                     18.1.4 åˆ é™¤æ‰€æœ‰çš„ item == item æ¡ä»¶ å’Œ  and-levels where CONST item != CONST item æ¡ä»¶
                     å¦‚æœ join_list åˆ™æ‰§è¡Œ 
                        build_equal_items(thd, /*Item *cond*/*cond, /* Item **retcond*/cond, /*COND_EQUAL *inherited*/nullptr, /*bool do_inherit*/true, 
                                           /*mem_root_deque<Table_ref *> *join_list*/join_list, /*COND_EQUAL **cond_equal_ref*/cond_equal)
                                           1ã€æ‰§è¡Œå‡½æ•° build_equal_items_for_cond(thd, cond, &cond, inherited, do_inherit) æ„å»ºå¤šé‡ç›¸ç­‰æ€§
                                           2ã€æ‰§è¡Œå‡½æ•° cond->update_used_tables()
                                           3ã€
           18.2 å¦‚æœ  query_block->cond_value == Item::COND_FALSE åˆ™æ‰§è¡Œ  set_root_access_path(create_access_paths_for_zero_rows()ï¼Œç„¶å goto setup_subq_exit
19ã€å¦‚æœ having_cond
           19.1 æ‰§è¡Œ optimize_cond(thd, /*Item **cond*/&having_cond, /*COND_EQUAL **cond_equal*/&cond_equal, /*mem_root_deque<Table_ref *> *join_list*/nullptr,  /*Item::cond_result *cond_value*/&query_block->having_value)
                     19.1.1 æ„å»º multiple equality predicates
                     19.1.2 æ‰§è¡Œå¸¸é‡æ›¿æ¢å­—æ®µ
                     19.1.3 å¦‚æœæ¡ä»¶ç»“æœæ°¸è¿œæ˜¯ true æˆ–è€… falseï¼Œåˆ™åˆ é™¤æ¡ä»¶
                     19.1.4 åˆ é™¤æ‰€æœ‰çš„ item == item æ¡ä»¶ å’Œ  and-levels where CONST item != CONST item æ¡ä»¶
           19.2 å¦‚æœ  query_block->having_value == Item::COND_FALSE åˆ™æ‰§è¡Œ  set_root_access_path(create_access_paths_for_zero_rows()ï¼Œç„¶å goto setup_subq_exit
20ã€æ‰§è¡Œå‡½æ•° prune_table_partitions() è¿›è¡Œåˆ†åŒºè¡¨è£å‰ª
21ã€æŠŠ count(*), min() å’Œ max() ä¼˜åŒ–æˆå¸¸é‡å­—æ®µ
21ã€å¦‚æœå¼€å¯ hypergraph_optimizer ä¸” query_block->is_table_value_constructorï¼Œå•¥éƒ½ä¸åš
        å¦åˆ™å¦‚æœ tables_list == nullptr 
                æ‰§è¡Œ make_tmp_tables_info()
                æ‰§è¡Œ count_field_types(query_block, &tmp_table_param, *fields, false, false)
                æ‰§è¡Œ set_plan_state(NO_TABLES)
                æ‰§è¡Œ create_access_paths()
                è¿”å›
22ã€åˆå§‹åŒ–çª—å£å‡½æ•°ç›¸å…³çš„æ•°æ®æˆå‘˜
23ã€å¦‚æœæ²¡å¼€å¯ hypergraph_optimizer åˆ™è®¾ç½® sort_by_table = get_sort_by_table(order.order, group_list.order, query_block->leaf_tables)
24ã€å¦‚æœ (where_cond || !group_list.empty() || !order.empty()) && substitute_gc(thd, query_block, where_cond, group_list.order, order.order) 
        åˆ™æ‰§è¡Œå‡½æ•° count_field_types(query_block, &tmp_table_param, query_block->fields, false, false)
            å…¶ä¸­å‡½æ•° substitute_gc çš„ä½œç”¨æ˜¯ï¼šå°† WHERE æ¡ä»¶å’Œ ORDER/GROUP åˆ—è¡¨ä¸­çš„æ‰€æœ‰è¡¨è¾¾å¼æ›¿æ¢ä¸º generated columns (GC)  å­—æ®µ
25ã€å¦‚æœå¼€å¯ hypergraph_optimizer
           25.1 æ‰§è¡Œ remove_in2exists_conds(where_cond) æŠŠ where_cond ä¸­çš„ IN-to-EXISTS æ¡ä»¶é¡¹ç­‰ä»·è½¬æ¢
           25.2 æ‰§è¡Œ remove_in2exists_conds(having_cond) æŠŠ having_cond ä¸­çš„ IN-to-EXISTS æ¡ä»¶ç­‰ä»·è½¬æ¢
           25.3 æ‰§è¡Œ SaveCondEqualLists(/*COND_EQUAL **/cond_equal)
                      List<Item_equal> copy
                      éå† cond_equal->current_level) itemï¼Œç„¶åæ‰§è¡Œ copy.push_back(&item)
                            å› ä¸ºè¶…å›¾ä¼˜åŒ–å™¨å¯ä»¥ä¿®æ”¹ Item_cond ä¸­çš„åˆ—è¡¨ï¼ˆé€šè¿‡è°ƒç”¨ compile()ï¼‰ï¼Œå¯¼è‡´ Item_equal è¢«æ›¿æ¢ä¸º Item_func_eqï¼Œå¹¶ä¸”è¿™å¯èƒ½å¯¼è‡´ List<Item_equal> ä¸å†åŒ…å« Item_equal æŒ‡é’ˆã€‚
                            ç”±äºè§£å¼€è¿™ä¸ªæ··ä¹±ä¼¼ä¹éå¸¸å›°éš¾ï¼Œæˆ‘ä»¬é€šè¿‡æš´åŠ›è§£å†³ï¼šå¤åˆ¶æ‰€æœ‰çš„ COND_EQUAL åˆ—è¡¨ï¼Œè¿™æ ·å®ƒä»¬å°±ä¸å†è¿›å…¥ Item_condã€‚è¿™å…è®¸æˆ‘ä»¬éšæ„ä¿®æ”¹ Item_condã€‚
                      è®¾ç½® cond_equal->current_level = std::move(copy)
                      é€’å½’æ‰§è¡Œ SaveCondEqualLists(cond_equal->upper_levels)
           25.4 æ‰§è¡Œ m_root_access_path = FindBestQueryPlan(thd, query_block, trace_ptr)
           25.5 æ‰§è¡Œ FinalizePlanForQueryBlock(thd, query_block) ç»“æŸæŸ¥è¯¢è®¡åˆ’
           25.6 å¦‚æœ where_cond != where_cond_no_in2exists || having_cond != having_cond_no_in2exists åˆ™
                      è®¾ç½® where_cond = where_cond_no_in2existsã€having_cond != having_cond_no_in2exists
                      æ‰§è¡Œ m_root_access_path_no_in2exists = FindBestQueryPlan(thd, query_block, trace_ptr)
                å¦åˆ™è®¾ç½® m_root_access_path_no_in2exists = nullptr
           25.7 è®¾ç½® set_plan_state(PLAN_READY)


Item_func_eq è½¬ Item_equal æµç¨‹ï¼š
1ã€å…¥å£æ˜¯å‡½æ•° build_equal_items_for_cond(THD *thd, Item *cond, Item **retcond, COND_EQUAL *inherited, bool do_inherit)ï¼Œå®ƒä¼šæŠŠæ¡ä»¶ä¸­çš„æ‰€æœ‰ç­‰å¼è½¬æ¢ä¸ºå¤šé‡ç­‰å¼
2ã€å®šä¹‰ä¸´æ—¶å˜é‡ Item_equal *item_equal;  COND_EQUAL cond_equal;  è®¾ç½® cond_equal.upper_levels = inherited
3ã€å¦‚æœ cond->type() == Item::FUNC_ITEM ï¼ˆå³ä¸æ˜¯ AND æˆ– OR æ¡ä»¶ï¼‰
           3.1 å®šä¹‰ä¸´æ—¶å˜é‡ List<Item> eq_list å’Œ bool equalityã€‚ï¼ˆç‹¬ç«‹ç­‰å¼çš„æ¦‚å¿µï¼šç­‰å¼è°“è¯å½¢æˆäº†æ•´ä¸ª AND çº§åˆ«ï¼‰
           3.2 æ‰§è¡Œå‡½æ•° check_equality(thd, cond, &cond_equal, &eq_list, &equality)
                     3.2.1 æ­¤å‡½æ•°æ£€æŸ¥é¡¹æ˜¯å¦æ˜¯ç®€å•ç­‰å¼ï¼Œå³å°†å­—æ®µä¸å¦ä¸€ä¸ªå­—æ®µæˆ–å¸¸é‡ï¼ˆfield=field_item æˆ– field=constant_itemï¼‰ç›¸ç­‰çš„é¡¹ï¼Œæˆ–è€…æ˜¯è¡Œç›¸ç­‰æ€§
                     3.2.2 å¯¹äºç®€å•ç­‰å¼ï¼Œè¯¥å‡½æ•°æŸ¥æ‰¾é€šè¿‡ cond_equal ç›´æ¥æˆ–é—´æ¥å¼•ç”¨çš„åˆ—è¡¨ä¸­çš„å¤šé‡ç­‰å¼ï¼Œæ¨æ–­ç»™å®šçš„ç®€å•ç­‰å¼ã€‚å¦‚æœæ‰¾ä¸åˆ°ä»»ä½•ç­‰å¼ï¼Œåˆ™æ„å»º/æ‰©å±•å¤šé‡ç­‰å¼ä»¥è¦†ç›–è°“è¯
                     3.2.3 è¡Œç›¸ç­‰æ€§è¢«æ¶ˆé™¤ï¼Œæ›¿æ¢ä¸ºä½œä¸ºåŸå§‹ç­‰å¼è°“è¯çš„è¿è¯è§„åˆ™ï¼Œä»¥ä¸åŸå§‹ç­‰å¼è°“è¯ç›¸åŒçš„æ–¹å¼å¤„ç†
                     3.3.3 æ³¨æ„ç‚¹ï¼šå¦‚æœç­‰å¼æ˜¯ç”± IN->EXISTS åˆ›å»ºçš„ï¼Œåˆ™å¯èƒ½ç¨åä¼šè¢«å­æŸ¥è¯¢å®ç°åˆ é™¤ã€‚å› æ­¤ï¼Œæˆ‘ä»¬ä¸å°†æ­¤å¯èƒ½æ˜¯ä¸´æ—¶æ€§ç­‰å¼ä¸å…¶ä»–ç­‰å¼æ··åˆ; å¦‚æœè®©å®ƒè¿›å…¥å¤šé‡ç­‰å¼ï¼ˆItem_equalï¼‰ä¸­ï¼Œé‚£ä¹ˆæˆ‘ä»¬ä»¥åå°±æ— æ³•åˆ é™¤å®ƒã€‚
                                  ç„¶è€Œï¼Œæœ‰ä¸€ä¸ªä¾‹å¤–ï¼šå¦‚æœå¤–éƒ¨è¡¨è¾¾å¼æ˜¯å¸¸é‡ï¼Œåˆ™å®‰å…¨åœ°å°†ç­‰å¼ç•™åœ¨ç‰©åŒ–è¡¨ä¸­ï¼›å®ƒæ‰€èƒ½åšçš„å°±æ˜¯é˜»æ­¢ NULL/FALSE åŒºåˆ†ï¼Œä½†å¦‚æœè¿™ç§åŒºåˆ†å¾ˆé‡è¦ï¼Œåˆ™ç­‰å¼å°†åœ¨è§¦å‘æ¡ä»¶ä¸­ï¼Œæ‰€ä»¥æˆ‘ä»¬ä¸ä¼šæ¥åˆ°è¿™ä¸ªå‡½æ•°ã€‚
                                  å¹¶ä¸”æ³¨å…¥å¸¸é‡æ˜¯å¥½çš„ï¼Œå› ä¸ºå®ƒä½¿ç‰©åŒ–çš„è¡¨æ›´å°ã€‚
                     check_equality(THD *thd, Item *item, COND_EQUAL *cond_equal, List<Item> *eq_list, bool *equality) çš„æµç¨‹ï¼š
                            1ã€è®¾ç½® *equality = falseï¼Œåˆ›å»ºä¸´æ—¶å˜é‡ Item_func *item_func
                            2ã€å¦‚æœæ˜¯æ™®é€šç­‰å¼ item->type() == Item::FUNC_ITEM && (item_func = down_cast<Item_func *>(item))->functype() == Item_func::EQ_FUNC
                                  è®¾ç½®ä¸´æ—¶å˜é‡ Item *left_item = item_func->arguments()[0]ï¼ŒItem *right_item = item_func->arguments()[1]
                                  å¦‚æœ item->created_by_in2exists() && !left_item->const_item() åˆ™è¿”å›
                                  å¦‚æœæ˜¯ ROW ç­‰å¼ left_item->type() == Item::ROW_ITEM && right_item->type() == Item::ROW_ITEM
                                            è®¾ç½® thd->lex->current_query_block()->cond_count--
                                            æ‰§è¡Œå‡½æ•° check_row_equality(thd, down_cast<Item_row *>(left_item), down_cast<Item_row *>(right_item), cond_equal, eq_list, equality)ï¼Œè¿”å›
                                  å¦‚æœæ˜¯é ROW ç­‰å¼ï¼Œåˆ™æ‰§è¡Œå‡½æ•° check_simple_equality(thd, left_item, right_item, item, cond_equal, equality)ï¼Œè¿”å›
                                            check_simple_equality(THD *thd, Item *left_item, Item *right_item, Item *item, COND_EQUAL *cond_equal, bool *simple_equality) æµç¨‹
                                                  1ã€è®¾ç½® *simple_equality = false
                                                  2ã€å¦‚æœ left_item æ˜¯è§†å›¾å¼•ç”¨(@è§†å›¾å­—æ®µ)
                                                        å¦‚æœæ˜¯å¤–è¿æ¥çš„å¼•ç”¨åˆ™è¿”å›æˆåŠŸï¼Œå¦åˆ™è®¾ç½® left_item = left_item->real_item()
                                                  3ã€åŒæ ·å¤„ç† right_item
                                                  4ã€å®šä¹‰ä¸´æ—¶å˜é‡ const Item_field *left_item_field, *right_item_field
                                                  6ã€å¦‚æœ left_item å’Œ right_item çš„å…³ç³»æ˜¯ å­—æ®µ=å­—æ®µï¼Œä¸”è¿™ä¸¤ä¸ªå­—æ®µéƒ½æ²¡ depended from åˆ«çš„ query_block
                                                        6.1 æŠŠ Item è½¬æ¢æˆ Item_fieldã€‚è®¾ç½® left_item_field = down_cast<const Item_field *>(left_item)ï¼Œright_item_field = down_cast<const Item_field *>(right_item)
                                                        6.2 è·å– Fieldã€‚å®šä¹‰ä¸´æ—¶å˜é‡ const Field *const left_field = left_item_field->fieldï¼Œright_field = right_item_field->field
                                                        6.3 å¦‚æœç­‰å¼å·¦å³ä¸¤è¾¹çš„æ•°æ®ç±»å‹ä¸ä¸€è‡´ï¼Œåˆ™è¿”å› false
                                                        6.4 åˆ›å»ºä¸´æ—¶å˜é‡ bool left_copyfl, right_copyfl
                                                        6.5 æœç´¢åŒ…å« left_item_field çš„å¤šé‡ç­‰å¼ Item_equal *left_item_equal = find_item_equal(cond_equal, left_item_field, &left_copyfl)
                                                                6.5.1 find_item_equal(COND_EQUAL *cond_equal, const Item_field *item_field, bool *inherited_fl) çš„æµç¨‹ï¼š
                                                                          6.5.1.1 éå† cond_equal->current_level æŸ¥æ‰¾ item_fieldï¼Œå¦‚æœæ‰¾ä¸åˆ°ï¼Œåˆ™åˆ° cond_equal->upper_levels ä¸­ç»§ç»­æŸ¥æ‰¾
                                                                          6.5.1.2 å¦‚æœä¸ cond_equal çš„ç¬¬ä¸€å±‚æŸ¥æ‰¾åˆ°ï¼Œåˆ™è®¾ç½® inherited_fl = trueï¼Œè¡¨ç¤ºç»§æ‰¿ä¸Šå±‚çš„ç­‰å¼
                                                        6.6 æœç´¢åŒ…å« right_item_field çš„å¤šé‡ç­‰å¼ Item_equal *right_item_equal = find_item_equal(cond_equal, right_item_field, &right_copyfl)
                                                        6.7 ç”±äº (NULL=NULL) != TRUEï¼Œæˆ‘ä»¬ä¸èƒ½ç®€å•åœ°åˆ é™¤è°“è¯ f=f
                                                        6.8 å¦‚æœ left_field->eq(right_field)ï¼Œå…¶ä¸­ eq å‡½æ•°ä¸­å·²ç»è¿‡æ»¤ NULL=NULL çš„åœºæ™¯
                                                                6.8.1 å¦‚æœä¹‹å‰æ²¡æ‰¾åˆ°å¯¹äºçš„å¤šé‡ç­‰å¼ï¼Œä¸”è¯¥å­—æ®µä¸ä¸º nullable: !((left_field->is_nullable() || left_field->table->is_nullable()) && !left_item_equal) åˆ™è®¾ç½® simple_equality = trueï¼Œè¿”å›
                                                        6.9 å¦‚æœä¹‹å‰æ‰¾åˆ°å¯¹åº”çš„å¤šé‡ç­‰å¼ left_item_equal && left_item_equal == right_item_equal åˆ™è®¾ç½® *simple_equality = trueï¼Œè¿”å›
                                                        6.10 å¦‚æœ left_copyfl åˆ™è®¾ç½® left_item_equal = new Item_equal(left_item_equal)ï¼Œç„¶å push_back åˆ° cond_equal->current_level
                                                        6.11 right_copyfl åŒç†
                                                        6.12 å¦‚æœ left_item_equal
                                                                  6.12.1 å¦‚æœ !right_item_equal åˆ™æŠŠ right_item æ·»åŠ è¿› left_item_equal
                                                                          å¦åˆ™åˆå¹¶ left_item_equal å’Œ right_item_equalï¼Œç„¶åä» cond_equal->current_level ä¸­åˆ é™¤ right_item_equal
                                                             å¦åˆ™å¦‚æœ right_item_equalï¼Œåˆ™æŠŠ left_item æ·»åŠ åˆ° right_item_equal 
                                                                     å¦åˆ™åˆ›å»ºæ–°çš„ Item_equal *item_equal = new Item_equal(down_cast<Item_field *>(left_item), down_cast<Item_field *>(right_item))
                                                                     ç„¶åæŠŠ item_equal push_back åˆ° cond_equal->current_level
                                                        6.13 è®¾ç½® *simple_equality = trueï¼Œè¿”å›
                                                  7ã€å¦‚æœ left_item å’Œ right_item çš„å…³ç³»æ˜¯ field=const/const=field
                                                        7.1 åˆ›å»ºä¸´æ—¶å˜é‡ Item *const_item = nullptrï¼ŒItem_field *field_item = nullptr
                                                        7.2 å¦‚æœ left_item æ˜¯å­—æ®µä¸”æ²¡æœ‰ depended from åˆ«çš„ query_blockï¼Œright_item æ˜¯å¸¸é‡è¡¨è¾¾å¼ï¼Œåˆ™è®¾ç½® const_item = right_item
                                                        7.3 right_item åŒç†
                                                        7.5 åˆ¤æ–­ const_item æ˜¯å¦éœ€è¦åœ¨ä¼˜åŒ–æœŸé—´è¯„ä¼°
                                                                7.5.1 å¦‚æœ const_item æ˜¯å¸¸é‡ï¼Œåˆ™è¡¨ç¤ºå®ƒä¸éœ€è¦è®¿é—®ä»»ä½•è¡¨ï¼Œåˆ™ä¸éœ€è¦åœ¨ä¼˜åŒ–æœŸé—´è¯„ä¼°
                                                                7.5.2 å¦‚æœ const_item æ²¡æœ‰å­æŸ¥è¯¢ï¼Œæˆ–è€…æŸ¥è¯¢å—æœªç¦ç”¨å­æŸ¥è¯¢ä¼˜åŒ–é€‰é¡¹ï¼Œåˆ™éœ€è¦åœ¨ä¼˜åŒ–æœŸé—´è¯„ä¼°
                                                            å¦‚æœä¸éœ€è¦åœ¨ä¼˜åŒ–æœŸé—´è¯„ä¼°ï¼Œåˆ™ç›´æ¥è¿”å›
                                                        7.6 å¦‚æœå¸¸é‡è¡¨è¾¾å¼åŒ…å«å¯¹å­—æ®µçš„å¼•ç”¨ï¼ˆä¾‹å¦‚ï¼Œa = (a IS NULL)ï¼Œåˆ™ç›´æ¥è¿”å›
                                                        7.7 å¦‚æœ field_item å’Œ const_item çš„ result_type() ä¸€è‡´
                                                                7.7.1 å¦‚æœæ˜¯ STRING_RESULT
                                                                          7.7.1.1 å¦‚æœ itemï¼ˆå®ƒæ˜¯ check_simple_equality å‡½æ•°ä¸­çš„å‚æ•°ï¼‰ ä¸ä¸ºç©ºï¼Œæ„å»º Item_func_eqï¼Œç„¶åèµ‹å€¼ç»™ item
                                                                          7.7.1.2 å¦‚æœ const_item çš„å­—ç¬¦é›†è·Ÿ item çš„å­—ç¬¦é›†ä¸ä¸€æ ·ï¼Œåˆ™è¿”å›
                                                                          7.7.1.3 å¦‚æœ field_item æˆ–è€… const_item æ˜¯ JSON æ•°æ®ç±»å‹ï¼Œåˆ™ä¸æ„å»º MESï¼Œè¿”å›
                                                                          7.7.1.4 å¦‚æœ const_item æ˜¯æ—¶é—´ç±»å‹ï¼Œå¦‚æœå­—æ®µç±»å‹ä¸æ˜¯æ—¶é—´ç±»å‹ï¼Œåˆ™è¿”å›
                                                                7.7.2 åˆ›å»ºä¸´æ—¶å˜é‡ bool copyfl
                                                                7.7.3 åœ¨ cond_equal ä¸­æŸ¥æ‰¾ field_itemï¼Œä»£ç ä¸º Item_equal *item_equal = find_item_equal(cond_equal, field_item, &copyfl)
                                                                7.7.4 å¦‚æœä¸æ˜¯åœ¨æœ¬å±‚ cond_equal ä¸­æŸ¥æ‰¾åˆ°ï¼Œåˆ™é‡æ–°åˆ›å»ºæ–°çš„ Item_equal å¹¶æŠŠå®ƒæ·»åŠ åˆ° cond_equal->current_level.push_back(item_equal)
                                                                7.7.5 å¦‚æœåœ¨ cond_equal ä¸­æ‰¾åˆ° field_itemï¼Œä¸”å¤šé‡ç­‰å¼ä¸­æœ‰å¸¸é‡ï¼Œåˆ™éœ€è¦ç¡®ä¿ç°æœ‰çš„å¸¸é‡å’Œæ–°çš„å¸¸é‡æ˜¯å¯æ¯”è¾ƒçš„æ’åºè§„åˆ™ï¼Œ
                                                                            å¦‚æœå¤šé‡ç­‰å¼å·²åŒ…å«å¸¸é‡å¹¶ä¸”å…¶å€¼ä¸ const_item çš„å€¼ä¸ç›¸ç­‰ï¼Œåˆ™å°†å¤šé‡ç­‰å¼çš„ cond_false æ ‡å¿—è®¾ç½®ä¸º 1ï¼Œ
                                                                            å¦åˆ™æŠŠ const_item å’Œ field_item æ·»åŠ åˆ°å¤šé‡ç­‰å¼ä¸­
                                                                      å¦åˆ™ä½¿ç”¨ const_item, field_item æ„å»ºæ–°çš„ Item_equal ç„¶åèµ‹å€¼ç»™ item_equalï¼Œåœ¨æŠŠå®ƒ push_back åˆ° cond_equal->current_level
                                                                7.7.6 è®¾ç½® *simple_equality = trueï¼Œè¿”å›
                                                  8ã€è¿”å›
                            3ã€è¿”å›
           3.3 å¦‚æœ equality ä¸æ˜¯ç©º
                     3.3.1 è®¾ç½®ä¸´æ—¶å˜é‡ int n = cond_equal.current_level.elements + eq_list.elements
                              å¦‚æœ n == 0 åˆ™è®¾ç½® *retcond = new Item_func_true()ï¼Œè¿”å›
                              å¦‚æœ n == 1 
                                          å¦‚æœ item_equal = cond_equal.current_level.pop()
                                                æ‰§è¡Œå‡½æ•° item_equal->resolve_type(thd)ï¼Œç›®çš„æ˜¯è®¾ç½® item_equal->eval_item çš„æ•°æ®ç±»å‹ã€å­—ç¬¦é›†ï¼Œå…¶ä¸­ item_equal->eval_item æ˜¯ç”¨æ¥è¾…åŠ©å­—æ®µä¹‹é—´çš„æ¯”è¾ƒ
                                                æ‰§è¡Œå‡½æ•° item_equal->update_used_tables()
                                                    å…¶ä¸­ update_used_tables() çš„æµç¨‹ï¼š
                                                          è®¾ç½® item_equal çš„ not_null_tables_cache = used_tables_cache = 0ï¼Œm_accum_properties = 0
                                                          éå† item_equal çš„ fields item
                                                                      item æ‰§è¡Œ item->update_used_tables()
                                                                      è®¾ç½® used_tables_cache |= item->used_tables()
                                                                      è®¾ç½® not_null_tables_cache |= item->not_null_tables()
                                                          å¦‚æœ item_equal çš„ m_const_arg != nullptrï¼Œåˆ™è®¾ç½® used_tables_cache |= m_const_arg->used_tables()
                                                è®¾ç½® *retcond = item_equalï¼Œè¿”å›
                                          è®¾ç½® *retcond = eq_list.pop()ï¼Œè¿”å›
                              å¦‚æœ n >=2  
                                          åˆ™å®šä¹‰ä¸´æ—¶å˜é‡ Item_cond_and *and_cond = new Item_cond_and(eq_list)
                                          æ‰§è¡Œ and_cond->fixed = true;
                                          è®¾ç½®ä¸´æ—¶å˜é‡ List<Item> *args = and_cond->argument_list()
                                          éå† cond_equal.current_level item_equal
                                                æ‰§è¡Œå‡½æ•° item_equal->resolve_type(thd)ï¼Œç›®çš„æ˜¯è®¾ç½® item_equal->eval_item çš„æ•°æ®ç±»å‹ã€å­—ç¬¦é›†ï¼Œå…¶ä¸­ item_equal->eval_item æ˜¯ç”¨æ¥è¾…åŠ©å­—æ®µä¹‹é—´çš„æ¯”è¾ƒ
                                                æ‰§è¡Œå‡½æ•° item_equal->update_used_tables()
                                          è®¾ç½® and_cond->cond_equal = cond_equal
                                          æ‰§è¡Œå‡½æ•° args->concat((List<Item> *)&cond_equal.current_level)
                                          è®¾ç½® *retcond = and_condï¼Œè¿”å›
           3.4 å¦‚æœ do_inherit == true 
                     è®¾ç½®ä¸´æ—¶å˜é‡ uchar *is_subst_valid = (uchar *)1;
                     æ‰§è¡Œå‡½æ•° cond = cond->compile(&Item::subst_argument_checker, &is_subst_valid, &Item::equal_fields_propagator, (uchar *)inherited)
                              å®ƒçš„åŠŸèƒ½æ˜¯ï¼šå¯¹äº cond ä¸­çš„æ¯ä¸ªå­—æ®µï¼ˆè¦æ±‚ä¸æ˜¯æ¥è‡ªå¤šé‡ç­‰å¼ã€è¦æ±‚å­—æ®µä¸æ˜¯ string ç±»å‹ï¼Œè¦æ±‚å­—æ®µå¼•ç”¨ä¸æ˜¯æ¥è‡ªæ¯”è¾ƒè°“è¯çš„å‚æ•°ï¼‰ï¼Œè®¾ç½®å®ƒå±äºå“ªä¸ª multiple equality
           3.5 æ‰§è¡Œ cond->update_used_tables()
4ã€è®¾ç½® *retcond = condï¼Œè¿”å›


ç­‰ä»·é€»è¾‘å˜æ¢æ•´ä½“æµç¨‹ï¼š
1ã€æ ¹æ® query_block->m_table_nest ç”Ÿæˆ RelationalExpression *root
  1.1 ç”Ÿæˆæ¯ä¸ªè°“è¯çš„ RelationalExpression åï¼Œå¦‚æœ Table_ref->m_join_cond_optim ä¸ä¸ºç©º
      1.1.1  æ‰§è¡Œ EarlyExpandMultipleEquals å‡½æ•°
          1.1.1.1  åªå¤„ç†æ¡ä»¶ä¸­çš„ MultipleEquals
          1.1.1.2  å¦‚æœ m_join_cond_optim çš„æ¡ä»¶ä¸­æ¶‰åŠè¡¨æ•°ä¸º 0ï¼ˆè¯´æ˜é‡åˆ°å¸¸é‡è¡¨ï¼‰ï¼Œä¸”æ¡ä»¶ä¸º FALSEï¼Œåˆ™ new Item_func_false
          1.1.1.3      å¦‚æœ MultipleEquals ä¸­æœ‰å¸¸é‡ Aï¼Œåˆ™ç”¨è¯¥å¸¸é‡ A å¡«å……æ‰€æœ‰å­—æ®µ
          1.1.1.4          å¦‚æœ MultipleEquals çš„ used_tables_cache æ¶‰åŠè¡¨æ•°è¶…è¿‡ 2ï¼Œåˆ™æ‰§è¡Œ ExpandSameTableFromMultipleEquals å‡½æ•°
                        1.1.1.4.1 æå– MultipleEquals çš„ä¸»è¦ä¿¡æ¯ï¼šæ¯”å¦‚ MultipleEquals(t1.a, t2.a, t2.b, t3.a) ä¼šè¢«è½¬æ¢æˆ t2.a=t2.b AND (original item)ã€‚è¿™å¯ä»¥è®©æˆ‘ä»¬åç»­æŠŠ t2.a=t2.b ä¸‹æ¨ã€‚
          1.1.1.5              å¦‚æœ  MultipleEquals çš„ used_tables_cache æ¶‰åŠè¡¨æ•°ä¸º 2
                            1.1.1.5.1 æ‰§è¡Œ ExpandSameTableFromMultipleEquals å‡½æ•°ï¼Œæå– MultipleEquals çš„ä¸»è¦ä¿¡æ¯ï¼šæ¯”å¦‚ MultipleEquals(t1.a, t2.a, t2.b, t3.a) ä¼šè¢«è½¬æ¢æˆ t2.a=t2.b AND (original item)ã€‚è¿™å¯ä»¥è®© æˆ‘ä»¬åç»­æŠŠ t2.a=t2.b ä¸‹æ¨ã€‚
                            1.1.1.5.2 è·å–ä¸¤å¼ è¡¨ä¹‹é—´çš„ä¸€ä¸ªç­‰å¼ A.X = B.Y
          1.1.1.6  æ‰§è¡Œ CreateConjunction å‡½æ•°ï¼ŒæŠŠ List<Item> è½¬æ¢æˆ Item_cond_and
      1.1.2  æ‰§è¡Œ ExtractConditions å‡½æ•°ï¼ŒæŠŠ Item_cond_and è½¬æ¢æˆ Mem_root_array<Item *>
      1.1.3  æ‰§è¡Œ EarlyNormalizeConditions å‡½æ•°
             1.1.3.1 æ‰§è¡Œ CSEConditions å‡½æ•°å¯¹æ¡ä»¶æ•°ç»„è¿›è¡Œå…¬å…±å­è¡¨è¾¾å¼æ¶ˆé™¤ï¼Œå¾—åˆ°æ–°çš„æ¡ä»¶æ•°ç»„
             1.1.3.2 å¯¹æ¡ä»¶æ•°ç»„ä¸­çš„æ¯ä¸ªæ¡ä»¶é¡¹è¿›è¡Œå¤„ç†
                     1.1.3.2.1 åˆ¤æ–­æ¡ä»¶é¡¹æ˜¯å¦æ˜¯è¿‡æ»¤å™¨ï¼šå¦‚æœæ¡ä»¶é¡¹æ¶‰åŠçš„è¡¨å°äº2ï¼Œé‚£ä¸ªè¿™ä¸ªæ¡ä»¶é¡¹æ˜¯ä¸ªè¿‡æ»¤å™¨
                     1.1.3.2.2 å¦‚æœæ˜¯æ¡ä»¶é¡¹æ˜¯è¿‡æ»¤å™¨æˆ–è€…æ¡ä»¶é¡¹ä¸æ˜¯ MULT_EQUAL_FUNCï¼Œåˆ™è®¡ç®— tables_in_subtree
                               å®ƒçš„è®¡ç®—æ–¹æ³•ï¼šå¦‚æœæ¡ä»¶é¡¹æ¶‰åŠçš„è¡¨åªæ˜¯åœ¨ RelationalExpression çš„å·¦è¾¹ï¼Œåˆ™è®¾ç½® tables_in_subtree ä¸º RelationalExpression->left->tables_in_subtreeï¼Œ
                               å³è¾¹åŒæ ·ï¼Œå¦åˆ™ä¸º RelationalExpression->tables_in_subtree
                               1.1.3.2.2.1 walk æ¡ä»¶é¡¹ä¸­çš„æ¯ä¸ªå­—æ®µ Aï¼Œ
                                           å¦‚æœå­—æ®µ A çš„ item_equalï¼ˆä¹Ÿå°±æ˜¯å¯¹åº”çš„ MultipleEqualsï¼‰ä¸ä¸ºç©ºï¼Œä¸” item_equal åŒ…å«å¸¸é‡ï¼Œä¸”å¸¸é‡è·Ÿå­—æ®µ A ç±»å‹å…¼å®¹ï¼Œåˆ™ç”¨è¯¥å¸¸é‡æ›¿æ¢å­—æ®µ A 
                                               å¦‚æœæ¡ä»¶é¡¹ä¸æ˜¯è¿‡æ»¤å™¨ï¼Œä¸”å­—æ®µ A çš„ item_equalï¼ˆæŒ‡å‘ MultipleEqualsï¼‰ æ²¡åŒ…å«å¸¸é‡ï¼Œåˆ™éå†å­—æ®µ A çš„ item_equal æ‰€æœ‰å­—æ®µ Xï¼Œå¦‚æœ X å¯¹åº”çš„è¡¨åœ¨ tables_in_subtree ä¸­ï¼Œåˆ™ä½¿ç”¨ X æ›¿æ¢ Aï¼Œç„¶åé€€å‡º
                     1.1.3.2.3 è¿è¡Œ remove_eq_conds å‡½æ•°æŠ˜å æ¡ä»¶: 
                                        1ã€åªå¤„ç† cond ç±»å‹ä¸º Item::FUNC_ITEM æˆ– Item::COND_ITEM çš„æƒ…å†µ 
                                        2ã€å¦‚æœæ˜¯ Item::COND_ITEMï¼Œåˆ™éå† cond->argument_list()ï¼Œå¯¹å…¶ä¸­çš„æ¯ä¸ªæ¡ä»¶é¡¹æ‰§è¡Œ fold_condition å‡½æ•°ï¼Œæœ€åæ›´æ–° used_tables_cache 
                                        3ã€å¦‚æœæ˜¯ Item::COND_ITEM ç±»å‹
                                           3.1 å¦‚æœä¸æ˜¯ <å­—æ®µ è¿ç®—ç¬¦ å¸¸é‡> è¿™ç§å½¢å¼åˆ™æ‰§è¡Œ fold_arguments å‡½æ•° 
                                           3.2 å¦‚æœæ˜¯ <å­—æ®µ è¿ç®—ç¬¦ å¸¸é‡> è¿™ç§å½¢å¼ï¼Œåˆ™å¯¹è¿ç®—ç¬¦ã€å¸¸é‡è¿›è¡Œè½¬æ¢ 
                                           3.3 æœ€åæŠŠ retcond æ„é€ æˆ Item_bool_func2
                               å¦‚æœæŠ˜å åæ˜¯ Item::COND_TRUE åˆ™åœ¨æ¡ä»¶æ•°ç»„ä¸­åˆ é™¤è¯¥æ¡ä»¶é¡¹
                               å¦‚æœæŠ˜å åæ˜¯ res == Item::COND_FALSE åˆ™æ¸…ç©ºæ¡ä»¶æ•°ç»„ï¼Œç„¶åå€¼ä¿ç•™ä¸Šé¢çš„ Item_bool_func2
                               å…¶å®ƒæƒ…å†µï¼šå¦‚æœæ¡ä»¶é¡¹æ˜¯ AND æ¡ä»¶è¡¨è¾¾å¼ï¼Œåˆ™ need_resplit = trueï¼Œç„¶åæ›´æ–°æ¡ä»¶é¡¹çš„ used_tables_cache
             1.1.3.3 å¦‚æœ need_resplit = true åˆ™æ‰§è¡Œ ResplitConditions å‡½æ•°ï¼Œé‡æ–°æ‹†åˆ†æ¡ä»¶æ•°ç»„
                     ä¾‹å¦‚ï¼šæŸä¸ªæ¡ä»¶é¡¹æ˜¯ A.x = B.x and B.x = D.x åˆ™è½¬æ¢æˆ Mem_root_array<Item *> æ•°ç»„ï¼Œé‡Œé¢åŒ…å«ä¸¤ä¸ªå…ƒç´  A.x = B.x å’Œ B.x = D.x
      1.1.4  æ‰§è¡Œ ReorderConditions å‡½æ•°ï¼Œé‡æ’åº Mem_root_array<Item *> æ•°ç»„ã€‚å› ä¸ºä¹‹å‰çš„ optimize_cond() ä¼šå¯¼è‡´ç­‰å¼æ”¾åœ¨æ•°ç»„åé¢ã€‚æˆ‘ä»¬æœ€å¥½æŠŠç­‰å¼è°ƒæ•´åˆ°æ•°ç»„å‰é¢
  1.2 CompanionSet å…±äº«çš„è¿æ¥ç±»å‹ï¼šINNER_JOIN çš„ leftã€rightï¼ŒLEFT_JOINã€SEMIJOINã€ANTIJOIN çš„ left
  1.3 æ‰§è¡Œ FlattenInnerJoins å‡½æ•°ï¼šå¦‚æœ RelationalExpression ç¬¦åˆè½¬æ¢æˆ MULTI_INNER_JOIN è¦æ±‚ï¼Œé‚£ä¹ˆæŸ¥çœ‹å®ƒå·¦å³å­©å­ï¼Œå¦‚æœä¹Ÿæ˜¯ MULTI_INNER_JOINï¼Œé‚£ä¹ˆåˆå¹¶æˆä¸€ä¸ªæ›´å¤§çš„ MULTI_INNER_JOIN
  1.4 new Mem_root_array<Item *> ç±»å‹çš„æ•°ç»„ï¼štable_filtersã€cycle_inducing_edges
  1.5 æ‰§è¡Œ PushDownJoinConditions(thd, root, companion_collection, &table_filters, &cycle_inducing_edges, trace) å‡½æ•°
        1.5.1 å¦‚æœæ˜¯ RelationalExpression::TABLE åˆ™è¿”å›
        1.5.2 å¦‚æœ RelationalExpression::join_conditions ä¸ä¸ºç©ºï¼Œåˆ™æ‰§è¡Œ
              å‡½æ•° expr->join_conditions = PushDownAsMuchAsPossible(thd, std::move(expr->join_conditions), expr,/*is_join_condition_for_expr=*/true, companion_collection,table_filters, cycle_inducing_edges, trace)
              åªæœ‰æ­¤æ—¶çš„ is_join_condition_for_expr æ˜¯ trueï¼Œä¸‹é¢çš„å­ç›®å½•ä¸­éƒ½æ˜¯ false
              1.5.2.1 éå†å‚æ•°ä¸­çš„æ¡ä»¶æ•°ç»„
                      å¦‚æœæ¡ä»¶é¡¹æ¶‰åŠçš„è¡¨å°‘äº2ï¼Œä¸” !is_join_condition_for_exprï¼Œåˆ™ä¸ä¼šä¸‹æ¨
                      å¦‚æœæ¡ä»¶é¡¹æ¶‰åŠçš„è¡¨é›†åˆä¸æ˜¯ RelationalExpression::tables_in_subtree çš„å­é›†ï¼Œæ¡ä»¶é¡¹ä¸æ˜¯ MultipleEqualsï¼Œä¸” is_join_condition_for_expr ä¸ºçœŸï¼Œåˆ™ä¸ä¼šä¸‹æ¨
                      å…¶å®ƒæƒ…å†µæ‰§è¡Œ PushDownCondition(item, expr, is_join_condition_for_expr, companion_collection, table_filters, cycle_inducing_edges, &remaining_parts, trace); å‡½æ•°
                      1.5.2.1.1  å¦‚æœ expr æ˜¯è¡¨ï¼Œç›´æ¥æŠŠ cond æ”¾åˆ° table_filters æ•°ç»„ä¸­ï¼Œç„¶åè¿”å›
                      1.5.2.1.2  è®¡ç®— cond->used_tables() å’Œ expr->tables_in_subtree çš„äº¤é›†ä¸º used_tables
                      1.5.2.1.3  å¦‚æœæ˜¯ MULTI_INNER_JOINï¼Œéå† expr->multi_children
                                 1.5.2.1.3.1 å¦‚æœ used_tables æ˜¯å¾ªç¯è¿­ä»£å™¨çš„ tables_in_subtree çš„å­é›†ï¼Œåˆ™æ‰§è¡Œå‡½æ•° PushDownConditionï¼ˆç»§ç»­ä¸‹æ¨ï¼‰ã€è¿”å›
                                 1.5.2.1.3.2 å¦‚æœ used_tables ä¸æ˜¯ä»»ä½•ä¸€ä¸ªå¾ªç¯è¿­ä»£å™¨çš„ tables_in_subtree çš„å­é›†ï¼Œåˆ™æ‰§è¡Œå‡½æ•°
                                             expr = PartiallyUnflattenJoinForCondition(used_tables, expr); 
                                             å®ƒæ ¹æ®æ¡ä»¶ï¼ŒæŠŠ MULTIJOIN ä¸­ç›¸å…³çš„è¡¨æ’¤ç¦»å‡ºæ¥ï¼Œæ¯”å¦‚ï¼šMULTIJOIN(t1, t2, t3, t4 LJ t5) é‡åˆ°æ¡ä»¶ t2.x = t5.xï¼Œé‚£ä¹ˆè½¬æ¢ä¸º MULTIJOIN(t1, t3, t2 JOIN (t4 LJ t5))
                      1.5.2.1.4  æŠŠæ¡ä»¶ä¸‹æ¨åˆ° RelationalExpression->left çš„å¿…è¦æ¡ä»¶ï¼šINNER_JOINã€STRAIGHT_INNER_JOINã€MULTI_INNER_JOINã€SEMIJOIN æˆ– !is_join_condition_for_exprï¼Œæ ‡è®°ä¸º can_push_into_left
                      1.5.2.1.5  å¦‚æœ used_tables æ˜¯ expr->left->tables_in_subtree çš„å­é›†
                                 1.5.2.1.5.1 å¦‚æœ can_push_into_left ä¸ºçœŸï¼Œåˆ™æ‰§è¡Œå‡½æ•° 
                                             PushDownCondition(cond, expr->left, /*is_join_condition_for_expr=*/false, companion_collection, table_filters, cycle_inducing_edges, remaining_parts, trace)ï¼Œè¿”å›
                                 1.5.2.1.5.1 å¦åˆ™ä¹Ÿè¿”å›
                      1.5.2.1.6  can_push_into_right åŒ 1.5.2.1.4
                      1.5.2.1.7  å¦‚æœ (AlreadyExistsOnJoin(cond, *expr) ä¸” !(expr->type == RelationalExpression::LEFT_JOIN || expr->type == RelationalExpression::ANTIJOIN)) ä¸ºçœŸï¼Œåˆ™è¿”å›
                                 å…¶ä¸­ AlreadyExistsOnJoin å‡½æ•°çš„åŠŸèƒ½æ˜¯æŸ¥çœ‹ RelationalExpression çš„ join_conditions æ˜¯å¦æœ‰ condï¼Œæˆ–è€…æœ‰ cond->source_multiple_equality
                                 ä¹Ÿå°±æ˜¯æŸ¥çœ‹å½“å‰çš„ expr æ˜¯å¦å·²ç»è•´å« condï¼Œå¦‚æœè•´å«ï¼Œåˆ™ç›´æ¥è¿”å›
                      1.5.2.1.8  å¦‚æœ can_push_into_left ä¸” used_tables è·Ÿ expr->left->tables_in_subtree æœ‰äº¤é›†
                                 1.5.2.1.8.1 æ‰§è¡Œ make_cond_for_table(current_thd, cond, expr->left->tables_in_subtree, /*used_table=*/0, /*exclude_expensive_cond=*/true) å‡½æ•°
                                             å®ƒçš„ä½œç”¨æ˜¯ï¼š å¦‚æœ used_table æ¶‰åŠçš„è¡¨æ˜¯ T1ï¼Œå¤§ä½“æ˜¯æŠŠ (T1.a = 1 and T2.b = 2) or (T1.a = 3 and T2.b = 4) è½¬æ¢æˆ T1.a = 1 or T1.a = 3
                                 1.5.2.1.8.2 å¦‚æœ make_cond_for_table çš„ç»“æœä¸ä¸ºç©ºï¼Œåˆ™æ‰§è¡Œ
                                             PushDownCondition(partial_cond, expr->left, /*is_join_condition_for_expr=*/false, companion_collection, table_filters, cycle_inducing_edges, /*remaining_parts=*/nullptr, trace) å‡½æ•°
                      1.5.2.1.9  can_push_into_right åŒ 1.5.2.1.8
                      1.5.2.1.10 å¦‚æœæ¡ä»¶æ˜¯ MultipleEquals
                                 1.5.2.1.10.1 å¦‚æœ left_tables = cond->used_tables() & expr->left->tables_in_subtree çš„ç»“æœ >= ä¸¤å¼ è¡¨, åˆ™æ‰§è¡Œ
                                              PushDownCondition(cond, expr->left, /*is_join_condition_for_expr=*/false, companion_collection, table_filters, cycle_inducing_edges, remaining_parts, trace) å‡½æ•°
                                 1.5.2.1.10.2 right_tables åŒ left_tables
                      1.5.2.1.11 åˆ°æ­¤ï¼Œæ‰€æœ‰çš„å±€éƒ¨ä¸‹æ¨å·¥ä½œå·²ç»å®Œæˆï¼Œç„¶åæ¢ç´¢æ˜¯å¦å¯ä»¥æŠŠåŸè¿‡æ»¤å™¨æ”¹é€ æˆ join condition
                      1.5.2.1.12 å¦‚æœ is_join_condition_for_expr ä¸ºçœŸåˆ™è¿”å›
                      1.5.2.1.13 å¦‚æœ expr->type å±äº LEFT_JOIN æˆ– ANTIJOIN
                                 1.5.2.1.13.1 bool need_flatten = falseï¼Œæ‰§è¡Œå‡½æ•° AddJoinConditionPossiblyWithRewrite(expr, cond, AssociativeRewritesAllowed::ANY, /*used_commutativity=*/false, &need_flatten, trace)
                                              å®ƒçš„ä½œç”¨æ˜¯æ—‹è½¬ exprï¼Œæ‰¾åˆ°åˆé€‚çš„ expr'ï¼Œç„¶åå°è¯•æŠŠ Item *cond æ·»åŠ è¿› expr'->join_conditions
                                 1.5.2.1.13.2 å¦‚æœæ­¤æ—¶ need_flatten ä¸ºçœŸï¼Œåˆ™æ‰§è¡Œ FlattenInnerJoins(expr)
                                              å®ƒçš„ä½œç”¨æ˜¯ï¼šå¦‚æœ RelationalExpression ç¬¦åˆè½¬æ¢æˆ MULTI_INNER_JOIN è¦æ±‚ï¼Œé‚£ä¹ˆæŸ¥çœ‹å®ƒå·¦å³å­©å­ï¼Œå¦‚æœä¹Ÿæ˜¯ MULTI_INNER_JOINï¼Œé‚£ä¹ˆåˆå¹¶æˆä¸€ä¸ªæ›´å¤§çš„ MULTI_INNER_JOIN        
                                 1.5.2.1.13.3 è¿”å›     
                      1.5.2.1.13 å¦‚æœ expr->type å±äº SEMIJOINï¼Œåˆ™ç›´æ¥æ‰§è¡Œ expr->join_conditions.push_back(cond)ï¼Œ ç„¶åè¿”å›
                      1.5.2.1.14 è®¾ç½® bool need_flatten = falseï¼Œæ‰§è¡Œå‡½æ•° AddJoinConditionPossiblyWithRewrite(expr, cond, AssociativeRewritesAllowed::ANY, /*used_commutativity=*/false, &need_flatten, trace)
                                 å¦‚æœå‡½æ•°è¿”å› false
                                 1.5.2.1.14.1 å¦‚æœ expr->type å±äº INNER_JOIN ä¸” IsCandidateForCycle(expr, cond, companion_collection) ä¸ºçœŸï¼Œ
                                              å…¶ä¸­ IsCandidateForCycle å‡½æ•°çš„ä½œç”¨æ˜¯ æ£€æŸ¥ cond->used_tables() æ˜¯å¦åœ¨ä¸€ä¸ª CompanionSet ä¸­
                                              1.5.2.1.14.1.1 å¦‚æœ cond æ˜¯ MultipleEqualsï¼Œåˆ›å»º Mem_root_array<Item *> possible_cycle_edges
                                                             1.5.2.1.4.1.1.1 æ‰§è¡Œå‡½æ•° FullyConcretizeMultipleEquals(down_cast<Item_equal *>(cond), expr->tables_in_subtree, &possible_cycle_edges)
                                                                             å®ƒçš„åŠŸèƒ½æ˜¯ï¼šæŠŠ (A.x, B.x, D.x, E.x)ã€allowed_tables={A,B,C,D} è½¬æ¢æˆ  A.x = B.x and B.x = D.x (E.x is ignored)
                                                             1.5.2.1.4.1.1.2 éå† possible_cycle_edgesï¼Œ
                                                                             æ‰§è¡Œå‡½æ•° PushDownCondition(sub_cond, expr,/*is_join_condition_for_expr=*/false, companion_collection, table_filters, cycle_inducing_edges, remaining_parts, trace)
                                              1.5.2.1.14.1.2 å¦‚æœ cond ä¸æ˜¯ MultipleEquals åˆ™æ‰§è¡Œå‡½æ•° 
                                                             cycle_inducing_edges->push_back(CanonicalizeCondition(cond, expr->tables_in_subtree, expr->tables_in_subtree))
                                                             å…¶ä¸­ CanonicalizeCondition å‡½æ•°çš„ä½œç”¨æ˜¯ walk cond, æŠŠå…¶ä¸­çš„ MultipleEquals (A.x, B.x, D.x, E.x)ã€allowed_tables={A,B,C,D} è½¬æ¢æˆ  A.x = B.x and B.x = D.x (E.x is ignored)
                                              1.5.2.1.14.1.3 å¦‚æœ need_flatten ä¸ºçœŸåˆ™æ‰§è¡Œå‡½æ•° FlattenInnerJoins(expr)
                                                             å®ƒçš„ä½œç”¨æ˜¯ï¼šå¦‚æœ RelationalExpression ç¬¦åˆè½¬æ¢æˆ MULTI_INNER_JOIN è¦æ±‚ï¼Œé‚£ä¹ˆæŸ¥çœ‹å®ƒå·¦å³å­©å­ï¼Œå¦‚æœä¹Ÿæ˜¯ MULTI_INNER_JOINï¼Œé‚£ä¹ˆåˆå¹¶æˆä¸€ä¸ªæ›´å¤§çš„ MULTI_INNER_JOIN
                                              1.5.2.1.14.1.4 è¿”å›
                                 1.5.2.1.14.2 å¦‚æœ cond æ˜¯ MultipleEquals ä¸” MultipleEqualityAlreadyExistsOnJoin(down_cast<Item_equal *>(cond), *expr) ä¸ºå‡ï¼Œ
                                              ï¼ˆå…¶ä¸­ MultipleEqualityAlreadyExistsOnJoin çš„ä½œç”¨æ˜¯ï¼šæŸ¥çœ‹ RelationalExpression çš„ join_conditionsã€equijoin_conditionsï¼Œæ£€æŸ¥æ˜¯å¦æœ‰ Item_eq_base å±äº Item_equalï¼‰
                                              åˆ™æ‰§è¡Œå‡½æ•°  expr->join_conditions.push_back(ConcretizeMultipleEquals(down_cast<Item_equal *>(cond), *expr))
                                              ï¼ˆå…¶ä¸­ ConcretizeMultipleEquals å‡½æ•°çš„ä½œç”¨æ˜¯ï¼šå…ˆåˆ° GetVisibleTables(expr.left æˆ– right) æŸ¥æ‰¾ item_field.used_tables() æ˜¯å¦èƒ½å½¢æˆè¾¹ï¼Œå¦‚æœæ²¡æœ‰åˆ™åˆ° expr.left->tables_in_subtree ä¸­æŸ¥æ‰¾ï¼‰
                                 1.5.2.1.14.3 å…¶å®ƒæƒ…å†µï¼Œå¦‚æœ used_tables æ˜¯ expr->tables_in_subtree å­é›†ï¼Œåˆ™æ‰§è¡Œ expr->join_conditions.push_back(cond)
                                 1.5.2.1.14.4 å…¶å®ƒæƒ…å†µï¼Œæ‰§è¡Œ remaining_parts->push_back(cond)
                      1.5.2.1.15 å¦‚æœ need_flatten ä¸ºçœŸåˆ™æ‰§è¡Œå‡½æ•° FlattenInnerJoins(expr)
```

```cpp
static AccessPath *FindBestQueryPlanInner(THD *thd, Query_block *query_block, bool *retry, int *subgraph_pair_limit, string *trace) æµç¨‹ï¼š
1ã€ åˆ¤æ–­å­˜å‚¨å¼•æ“æ˜¯å¦æ”¯æŒ hypergraph
2ã€ æŠŠ JOIN å¯¹è±¡è½¬å˜æˆ JoinHypergraph
       2.1 æŠŠ query_block èµ‹å€¼ç»™ ä¸´æ—¶å˜é‡ graph->m_query_blockï¼š JoinHypergraph graph(thd->mem_root, query_block)
       2.2 è®¾ç½®ä¸´æ—¶å˜é‡ bool where_is_always_false = false
       2.3 æ„å»º JoinHypergraph:  MakeJoinHypergraph(thd, trace, &graph, &where_is_always_false
3ã€ å¦‚æœ where_is_always_false åˆ™è¿”å› 0 è¡Œï¼š CreateZeroRowsForEmptyJoin(join, "WHERE condition is always false")
4ã€ æ‰§è¡Œå‡½æ•° FindSargablePredicates(thd, trace, &graph); 
       4.1 éå† graph->nodesã€å†…åµŒéå† graph->node.join_conditions_pushable_to_this 
       4.2 å¦‚æœ graph->predicates[i].condition å¯ä»¥åº”ç”¨ç´¢å¼•ï¼Œåˆ™æŠŠå®ƒ æ”¾åˆ° JoinHypergraph::Node->sargable_predicates
5ã€ æ‰§è¡Œå‡½æ•° CacheCostInfoForJoinConditions(thd, query_block, &graph, trace)ï¼Œç”¨äºç¼“å­˜ä¸€äº›å¤šæ¬¡ä½¿ç”¨çš„ä¿¡æ¯
       5.1 éå† graph->edge.expr->equijoin_conditionsï¼Œæ„é€  CachedPropertiesForPredicateï¼Œç„¶åæ”¾è¿› graph->edge.expr->properties_for_equijoin_conditions
       5.2 éå† graph->edge.expr->join_conditionsï¼Œæ„é€  CachedPropertiesForPredicateï¼Œç„¶åæ”¾è¿› edge.expr->properties_for_join_conditions
6ã€ å®šä¹‰ä¸´æ—¶å˜é‡ bool need_rowid = false
       6.1 å¦‚æœ SQL æ˜¯ groupã€orderã€distinctã€windows å…¶ä¸­ä»»ä½•ä¸€ä¸ªç±»å‹ï¼Œ
               6.1.1 éå† *join->fieldsï¼Œå¦‚æœæœ‰ blob å­—æ®µï¼Œåˆ™è¯¥ SQL éœ€è¦ rowid
               6.1.2 éå† query_block->leaf_tables tlï¼Œå¦‚æœ SortWillBeOnRowId(tl->table)ï¼Œåˆ™è¯¥ SQL éœ€è¦ rowid
7ã€ å®šä¹‰ä¸´æ—¶å˜é‡ MutableOverflowBitset materializable_predicates{thd->mem_root, graph.predicates.size()}
       7.1 éå† graph.predicatesï¼Œå¦‚æœ graph.predicates[i].condition åŒ…å«å­æŸ¥è¯¢ï¼Œåˆ™æ ‡è®°è¯¥è°“è¯éœ€è¦ç‰©åŒ–
       7.2 æŠŠ materializable_predicates æ·±æ‹·è´åˆ° graph.materializable_predicates
8ã€ æ£€æŸ¥è¯¥ SQL æ˜¯å¦ DELETE ç±»å‹ã€UPDATE ç±»å‹ã€æœ‰å…¨æ–‡æ£€ç´¢å‡½æ•°
        å®šä¹‰ä¸´æ—¶å˜é‡ const bool is_topmost_query_block = query_block->outer_query_block() == nullptrï¼Œä»£è¡¨æ˜¯å¦æœ€å¤–å±‚ query_block
        å®šä¹‰ä¸´æ—¶å˜é‡ const bool is_delete = is_topmost_query_block && IsDeleteStatement(thd)ï¼Œä»£è¡¨æ˜¯å¦ DELETE ç±»å‹ SQL
        å®šä¹‰ä¸´æ—¶å˜é‡ const bool is_update = is_topmost_query_block && IsUpdateStatement(thd)ï¼Œä»£è¡¨æ˜¯å¦ UPDATE ç±»å‹ SQL
        å®šä¹‰ä¸´æ—¶å˜é‡ table_map update_delete_target_tables = 0ï¼Œç”¨äºç»Ÿè®¡éœ€è¦ DELETE æˆ–è€… UPDATE çš„è¡¨ç¼–å·    
        å®šä¹‰ä¸´æ—¶å˜é‡  table_map immediate_update_delete_candidates = 0
        å¦‚æœè¯¥ SQL æ˜¯ DELETE æˆ–è€… UPDATE ç±»å‹ï¼Œåˆ™åˆ†åˆ«æ›´æ–° update_delete_target_tables å’Œ immediate_update_delete_candidates
        å®šä¹‰ä¸´æ—¶å˜é‡ NodeMap fulltext_tables = 0 å’Œ uint64_t sargable_fulltext_predicates = 0
        å¦‚æœè¯¥ query_block æœ‰å…¨æ–‡æ£€ç´¢å‡½æ•°ï¼Œåˆ™æ›´æ–° fulltext_tables å’Œ sargable_fulltext_predicates
9ã€ ä»  ORDER BY, GROUP BY, semijoins å’Œ windows ä¸­æ”¶é›† interesting orders
        å®šä¹‰ä¸´æ—¶å˜é‡
        LogicalOrderings orderings(thd)
        Mem_root_array<SortAheadOrdering> sort_ahead_orderings(thd->mem_root)
        Mem_root_array<ActiveIndexInfo> active_indexes(thd->mem_root)
        Mem_root_array<SpatialDistanceScanInfo> spatial_indexes(thd->mem_root)
        Mem_root_array<FullTextIndexInfo> fulltext_searches(thd->mem_root)
        int order_by_ordering_idx = -1
        int group_by_ordering_idx = -1
        int distinct_ordering_idx = -1
        æ‰§è¡Œå‡½æ•° BuildInterestingOrders(thd, &graph, query_block, &orderings, &sort_ahead_orderings, &order_by_ordering_idx, &group_by_ordering_idx, &distinct_ordering_idx, &active_indexes, &spatial_indexes, &fulltext_searches, trace)
10ã€æ‰§è¡Œå‡½æ•° (InjectCastNodes(&graph)
        å®ƒæŠŠ graph->predicates çš„ conditionï¼Œè¿˜æœ‰ graph->edges çš„ expr join_predicate_lastã€join_conditionsï¼Œè¿˜æœ‰çš„ join->fieldsã€join->group_list.orderã€join->having_cond ä¸å…¼å®¹çš„æ•°æ®ç±»å‹æ¯”è¾ƒè½¬æ¢æˆå…¼å®¹çš„ç±»å‹
11ã€éå†  graph.nodes nodeï¼Œæ‰§è¡Œå‡½æ•° node.table->init_cost_model(thd->cost_model())ï¼Œç”¨äºåˆå§‹åŒ–æ¯ä¸ª graph.nodes.table çš„ä»£ä»·æ¨¡å‹
12ã€å®šä¹‰ä¸´æ—¶å˜é‡  CostingReceiver receiver(thd, query_block, graph, &orderings, &sort_ahead_orderings, &active_indexes, &spatial_indexes, &fulltext_searches, fulltext_tables,
                                          sargable_fulltext_predicates, update_delete_target_tables, immediate_update_delete_candidates, need_rowid, EngineFlags(thd), 
                                          *subgraph_pair_limit, secondary_engine_cost_hook, secondary_engine_optimizer_request_state_hook, trace)
       12.1 å¦‚æœ graph.nodes.size() == 1 åˆ™æ‰§è¡Œå‡½æ•° receiver.FoundSingleNode(0)ï¼ŒæŸ¥æ‰¾å•è¡¨æŸ¥è¯¢çš„æœ€ä½³è·¯å¾„
       12.2 å¦‚æœ graph.nodes.size() > 1 åˆ™æ‰§è¡Œå‡½æ•° EnumerateAllConnectedPartitions(graph.graph, &receiver) ç”¨äºæŸ¥æ‰¾æœ€ä½³çš„ join order
            å¦‚æœæ‰§è¡Œå¤±è´¥ä¸” join->zero_result_cause == nullptrï¼Œåˆ™ç®€åŒ–è¶…å›¾ã€‚å®šä¹‰ä¸´æ—¶å˜é‡ GraphSimplifier simplifier(&graph, thd->mem_root)
            do {
                å®šä¹‰ä¸´æ—¶å˜é‡ *subgraph_pair_limit = receiver.subgraph_pair_limit()
                æ‰§è¡Œå‡½æ•° SetNumberOfSimplifications(0, &simplifier)
                æ‰§è¡Œå‡½æ•° SimplifyQueryGraph(thd, *subgraph_pair_limit, &graph, &simplifier, trace) ç®€åŒ–è¶…å›¾
                é‡ç½® receiver = CostingReceiver(thd, query_block, graph, &orderings, &sort_ahead_orderings, &active_indexes, &spatial_indexes, &fulltext_searches, fulltext_tables, 
                                          sargable_fulltext_predicates, update_delete_target_tables, immediate_update_delete_candidates, need_rowid, EngineFlags(thd),
                                          *subgraph_pair_limit, secondary_engine_cost_hook, secondary_engine_optimizer_request_state_hook, trace)
            }while (EnumerateAllConnectedPartitions(graph.graph, &receiver) && (join->zero_result_cause == nullptr) && (!thd->is_error()))
13ã€å¦‚æœ join->zero_result_cause != nullptr åˆ™è¿”å› 0 è®°å½•çš„è·¯å¾„ CreateZeroRowsForEmptyJoin(join, join->zero_result_cause)
14ã€è·å– root candidatesï¼Œå› ä¸ºç¬¬äºŒä¸ªå¼•æ“å¯èƒ½ hook å¯¼è‡´æ²¡æœ‰ candidatesã€‚
       14.1 å®šä¹‰ä¸´æ—¶å˜é‡ Prealloced_array<AccessPath *, 4> root_candidates = receiver.root_candidates()
       14.2 å¦‚æœè¯¥ SQL æ˜¯ value_constructor ç±»å‹ï¼Œåˆ™å®šä¹‰ä¸´æ—¶å˜é‡ AccessPath *path = NewTableValueConstructorAccessPath(thd, join)ï¼Œå¹¶åˆå§‹åŒ–å®ƒã€‚
            ç„¶åæ‰§è¡Œå‡½æ•° receiver.ProposeAccessPath(path, &root_candidates, /*obsolete_orderings=*/0, /*description_for_trace=*/"")
       14.3 root_candidates ä¸ºç©ºï¼Œåˆ™æ‰“å°é”™è¯¯ä¿¡æ¯
15ã€å¦‚æœ receiver.always_empty()ï¼Œåˆ™éå† root_candidates root_pathï¼Œå¦‚æœæ˜¯ 0 è®°å½•çš„è·¯å¾„ï¼Œåˆ™è¿”å› CreateZeroRowsForEmptyJoin(join, root_path->zero_rows().cause)
17ã€ç°åœ¨ï¼Œæˆ‘ä»¬è‡³å°‘æœ‰ä¸€æ¡æŠŠæ‰€æœ‰è¡¨ join åœ¨ä¸€èµ·çš„è·¯å¾„ã€‚æ¥ç€æˆ‘ä»¬éœ€è¦æ‰¾å‡ºæœ€ä½æˆæœ¬çš„è·¯å¾„ã€‚
    æˆ‘ä»¬å¿½ç•¥ LIMIT åç»­çš„ init_costï¼Œæ‰€ä»¥åœ¨æ¯ä¸ªæ­¥éª¤ä¸­æˆ‘ä»¬åªå‰©ä¸‹å¾ˆå°‘çš„ candidatesï¼Œä½†æ˜¯è¿™éƒ¨åˆ†æˆæœ¬å¾ˆä½ï¼Œä¸å€¼å¾—ä¼˜åŒ–ã€‚
       17.1 å®šä¹‰ä¸´æ—¶å˜é‡  FunctionalDependencySet fd_set = receiver.active_fds_at_root()ã€ool has_final_predicates = false
       17.2 éå† graph.num_where_predicates iï¼Œå¦‚æœ graph.predicates[i].total_eligibility_set è·Ÿ TablesBetween(0, graph.nodes.size()) ä¸ç›¸äº¤
            åˆ™è®¾ç½® fd_set |= graph.predicates[i].functional_dependenciesã€has_final_predicates = true
       17.3 åœ¨æ‰€æœ‰çš„ candidates è·¯å¾„ä¸­ï¼Œæ·»åŠ  final predicatesï¼Œç„¶åå±•å¼€ è¿‡æ»¤è·¯å¾„ã€‚å¦‚æœæ²¡æœ‰è¿‡æ»¤è·¯å¾„çš„è¯ï¼Œå°±æ²¡å¿…è¦æ·»åŠ ã€‚å› ä¸ºå®ƒå¼€é”€ä¸æ˜‚è´µï¼Œæ‰€ä»¥ä¸å€¼å¾—èŠ±å¤ªå¤šç²¾åŠ›å»æ‰¾åˆ°å®ƒæ˜¯å¦å¯ä»¥ç”¨å¿½ç•¥ã€‚
              å¦‚æœ has_final_predicates æˆ–è€…  !(root_candidates.size() == 1 && root_candidates[0]->type == AccessPath::EQ_REF && IsEmpty(root_candidates[0]->filter_predicates))
                  å®šä¹‰ä¸´æ—¶å˜é‡  Prealloced_array<AccessPath *, 4> new_root_candidates(PSI_NOT_INSTRUMENTED)
                  éå† root_candidates root_path
                      å†…åµŒéå† for (bool materialize_subqueries : {false, true})
                          å®šä¹‰ä¸´æ—¶å˜é‡ AccessPath path = *root_pathã€double init_once_cost = 0.0ã€ MutableOverflowBitset filter_predicates = path.filter_predicates.Clone(thd->mem_root)
                          éå† graph.num_where_predicates i
                              å¦‚æœ (!Overlaps(graph.predicates[i].total_eligibility_set, TablesBetween(0, graph.nodes.size())) || Overlaps(graph.predicates[i].total_eligibility_set, RAND_TABLE_BIT)
                                  åˆ™ filter_predicates.SetBit(i)
                                  ç„¶åè¯„ä¼°è¿‡æ»¤çš„ä»£ä»·ï¼šFilterCost cost = EstimateFilterCost(thd, root_path->num_output_rows(), graph.predicates[i].contained_subqueries)
                                  å¦‚æœ materialize_subqueries åˆ™è®¾ç½® path.set_cost(path.cost() + cost.cost_if_materialized)ã€init_once_cost += cost.cost_to_materialize
                                  å¦åˆ™è®¾ç½® path.set_cost(path.cost() + cost.cost_if_not_materialized)
                          è®¾ç½® path.ordering_state = orderings.ApplyFDs(path.ordering_state, fd_set)
                               path.filter_predicates = std::move(filter_predicates)
                               const bool contains_subqueries = Overlaps(path.filter_predicates, graph.materializable_predicates)
                          ç°åœ¨æˆ‘ä»¬éœ€è¦ full planï¼Œæ‰€ä»¥éœ€è¦å±•å¼€æ‰€æœ‰çš„è¿‡æ»¤æ¡ä»¶åˆ°å¯¹åº”çš„è¿‡æ»¤èŠ‚ç‚¹ä¸­
                               æ‰§è¡Œå‡½æ•° ExpandFilterAccessPaths(thd, &path, join, graph.predicates, graph.num_where_predicates)
                          å¦‚æœ materialize_subqueries åˆ™è®¾ç½®
                               path.filter().materialize_subqueries = true
                               path.set_cost(path.cost() + init_once_cost)  // Will be subtracted back for rescans.
                               path.set_init_cost(path.init_cost() + init_once_cost)
                               path.set_init_once_cost(path.init_once_cost() + init_once_cost)
                          æ‰§è¡Œå‡½æ•° receiver.ProposeAccessPath(&path, &new_root_candidates, /*obsolete_orderings=*/0, materialize_subqueries ? "mat. subq" : "")
                          å¦‚æœä¸åŒ…å«å­æŸ¥è¯¢ï¼Œåˆ™è·³å‡ºå¾ªç¯
                  è®¾ç½® root_candidates = std::move(new_root_candidates)
18ã€åº”ç”¨ GROUP BYã€‚æˆ‘ä»¬å…ˆæ“ä½œ sortingï¼Œç„¶åå†ä½¿ç”¨æµå¼èšåˆã€‚
       18.1 æ£€æŸ¥èšåˆæ˜¯å¦éœ€è¦æ’åº const bool aggregation_is_unordered = Overlaps(EngineFlags(thd), MakeSecondaryEngineFlags(SecondaryEngineFlag::AGGREGATION_IS_UNORDERED))
       18.2 åº”ç”¨æµå¼èšåˆ ApplyAggregation(thd, &graph, receiver, group_by_ordering_idx, need_rowid, aggregation_is_unordered, orderings, sort_ahead_orderings, fd_set, query_block, root_candidates, trace)
19ã€åº”ç”¨ HAVING æ¡ä»¶ä¹‹å‰ï¼Œéœ€è¦ç¡®ä¿ used_tables() cache å·²ç»è¢«æ˜¯æœ€æ–°ã€‚è¯¥æ¡ä»¶å¯èƒ½ä¼šè¢«å‡½æ•° FinalizePlanForQueryBlock() æ”¹å†™æˆä¸´æ—¶è¡¨
       19.1 å¦‚æœ join->having_cond != nullptrï¼Œåˆ™æ‰§è¡Œå‡½æ•° join->having_cond->update_used_tables()
       19.2 å¦‚æœæ²¡æœ‰ window-related in2exists çš„éƒ¨åˆ†ï¼Œåˆ™æ‰§è¡Œä¸‹é¢æ­¥éª¤
            å®šä¹‰ä¸´æ—¶å˜é‡ Item *having_condã€Item *having_cond_wf
            æ‰§è¡Œå‡½æ•°  SplitHavingCondition(thd, join->having_cond, &having_cond, &having_cond_wf)
            æ‰§è¡Œå‡½æ•° ApplyHavingOrQualifyCondition(thd, having_cond, query_block, "Applying filter for HAVING\n", trace, &root_candidates, &receiver)
20ã€åº”ç”¨ çª—å£å‡½æ•°ä¸­çš„ GROUP BYï¼Œå¦‚æœæœ‰ ORDER BY çš„è¯ï¼Œæˆ‘ä»¬åˆ™éœ€è¦åœ¨æ’åºä¹‹å‰å…ˆç‰©åŒ–
       20.1 å¦‚æœ query_block->is_explicitly_grouped() && !join->m_windows.is_empty()
            å®šä¹‰ä¸´æ—¶å˜é‡ Prealloced_array<AccessPath *, 4> new_root_candidates(PSI_NOT_INSTRUMENTED)
            éå† root_candidates root_path
                  è®¾ç½® root_path = CreateMaterializationOrStreamingPath(thd, join, root_path, need_rowid, /*copy_items=*/true)
                  æ‰§è¡Œå‡½æ•° receiver.ProposeAccessPath(root_path, &new_root_candidates, /*obsolete_orderings=*/0, "")
            è®¾ç½® root_candidates = std::move(new_root_candidates)
       20.2 è®¾ç½® join->m_windowing_steps = !join->m_windows.is_empty()
            å¦‚æœ join->m_windowing_steps
                  åˆ™è®¾ç½® root_candidates = ApplyWindowFunctions(thd, receiver, orderings, fd_set, aggregation_is_unordered, order_by_ordering_idx, distinct_ordering_idx, graph,
                                                                sort_ahead_orderings, query_block, graph.num_where_predicates, need_rowid, std::move(root_candidates), trace)
21ã€è¿‡æ»¤èŠ‚ç‚¹éœ€è¦æ·»åŠ åˆ°çª—å£å‡½æ•°ä¸­
       21.1 å®šä¹‰ä¸´æ—¶å˜é‡  Item *post_window_filter = nullptr
            å¦‚æœ having_cond_wf != nullptrï¼Œåˆ™è®¾ç½® post_window_filter = having_cond_wf
22ã€å¦‚æœ query_block->qualify_cond() != nullptrï¼Œ
       åˆ™è®¾ç½® query_block->qualify_cond()->update_used_tables()
       å¦‚æœ post_window_filter == nullptr åˆ™è®¾ç½® post_window_filter = query_block->qualify_cond()
            å¦åˆ™è®¾ç½® 
            post_window_filter = new Item_cond_and(post_window_filter, query_block->qualify_cond())
            post_window_filter->quick_fix_field()
            post_window_filter->update_used_tables()
            post_window_filter->apply_is_true()
23ã€æ‰§è¡Œå‡½æ•° ApplyHavingOrQualifyCondition(thd, post_window_filter, query_block, description_for_trace.c_str(), trace, &root_candidates, &receiver)
24ã€å¦‚æœ join->select_distinct || join->order.order != nullptr
       åˆ™è®¾ç½®
       const bool force_sort_rowids = update_delete_target_tables != 0
       root_candidates = ApplyDistinctAndOrder(thd, receiver, orderings, aggregation_is_unordered, order_by_ordering_idx, distinct_ordering_idx, sort_ahead_orderings,
                                               fd_set, query_block, need_rowid, force_sort_rowids, std::move(root_candidates), trace)
25ã€åº”ç”¨ LIMIT and OFFSETã€‚å¦‚æœ query block æœ‰æ’åºï¼Œé‚£ä¹ˆä»–ä»¬å·²ç»åœ¨å‡½æ•° ApplyDistinctAndOrder() ä¸­è¢«åº”ç”¨
       25.1 å®šä¹‰ä¸´æ—¶å˜é‡  Query_expression *query_expression = join->query_expression()
       25.2 å¦‚æœæ²¡æœ‰æ’åº join->order.order == nullptr && (query_expression->select_limit_cnt != HA_POS_ERROR || query_expression->offset_limit_cnt != 0)
            åˆ™å®šä¹‰ä¸´æ—¶å˜é‡ Prealloced_array<AccessPath *, 4> new_root_candidates(PSI_NOT_INSTRUMENTED)
            éå† root_candidates root_path
                 å®šä¹‰ä¸´æ—¶å˜é‡  AccessPath *limit_path = NewLimitOffsetAccessPath(thd, root_path, query_expression->select_limit_cnt, query_expression->offset_limit_cnt, join->calc_found_rows,
                                                                                /*reject_multiple_rows=*/false, /*send_records_override=*/nullptr)
                 æ‰§è¡Œå‡½æ•°  receiver.ProposeAccessPath(limit_path, &new_root_candidates, /*obsolete_orderings=*/0, "")
            è®¾ç½® root_candidates = std::move(new_root_candidates);
26ã€å¦‚æœæ˜¯æœ€å¤–å±‚çš„ query blockï¼Œä¸”æ˜¯ DELETE æˆ–è€… UPDATE çš„ SQL ç±»å‹ï¼Œåˆ™æ·»åŠ  DELETE_ROWS æˆ–è€… UPDATE_ROWS è·¯å¾„
27ã€å®šä¹‰ä¸´æ—¶å˜é‡ AccessPath *root_path = *std::min_element(root_candidates.begin(), root_candidates.end(), [](const AccessPath *a, const AccessPath *b) { return a->cost() < b->cost();})
28ã€å¦‚æœæœ€å¤–å±‚ query block æœ‰ SQL_BUFFER_RESULTï¼Œåˆ™ç‰©åŒ–å®ƒçš„æŸ¥è¯¢ç»“æœ
       28.1 å¦‚æœ query_block->active_options() & OPTION_BUFFER_RESULT && is_topmost_query_block && !IsMaterializationPath(root_path) && IteratorsAreNeeded(thd, root_path)
            å¦‚æœæœ‰çª—å£å‡½æ•°ï¼Œæˆ‘ä»¬éœ€è¦æŠŠæœ€åçš„çª—å£å‡½æ•°ç‰©åŒ–
                 å®šä¹‰ä¸´æ—¶å˜é‡ bool copy_items = join->m_windows.is_empty()
                 è®¾ç½® root_path = CreateMaterializationPath(thd, join, root_path, /*temp_table=*/nullptr, /*temp_table_param=*/nullptr, copy_items)
29ã€è®¾ç½® join->needs_finalize = trueï¼Œjoin->best_rowcount = lrint(root_path->num_output_rows())ï¼Œjoin->best_read = root_path->cost()
30ã€å¦‚æœç»“æœä¸è¶…è¿‡1è¡Œï¼Œä¸”æœ‰ LIMIT å’Œ OFFSETï¼Œåˆ™ä»£è¡¨å®ƒæ˜¯å¸¸é‡è¡¨
       å¦‚æœ join->best_rowcount <= 1 && query_expression->select_limit_cnt - query_expression->offset_limit_cnt > 1
              åˆ™è®¾ç½® join->best_rowcount = PLACEHOLDER_TABLE_ROW_ESTIMATE
31ã€è¿”å› root_path





2ã€å¦‚æœ RelationalExpression ç¬¦åˆè½¬æ¢æˆ MULTI_INNER_JOIN è¦æ±‚ï¼Œé‚£ä¹ˆæŸ¥çœ‹å®ƒå·¦å³å­©å­ï¼Œå¦‚æœä¹Ÿæ˜¯ MULTI_INNER_JOINï¼Œé‚£ä¹ˆåˆå¹¶æˆä¸€ä¸ªæ›´å¤§çš„ MULTI_INNER_JOIN
1ã€walk where_cond
  1.1ã€å¦‚æœæ˜¯å¸¸é‡è¡¨ï¼Œ
  1ã€å±•å¼€ multiple equal é¡¹
  1.1 å¦‚æœ multiple equal é¡¹åªæœ‰ä¸¤å¼ è¡¨ Aã€Bï¼Œåˆ™æ„å»º A.X=B.Y ç­‰å¼

ä¸‹æ¨æ–¹å‘çš„ç ”ç©¶
2ã€    
A SJ B ON (A.ID=9 AND XXXX), å…¶ä¸­ A.ID=9  å¯ä»¥ä¸‹æ¨ç»™è¡¨ A

3ã€
å±€éƒ¨ä¸‹æ¨ï¼š
T1 JOIN T2 ON (T1.a = 1 and T2.b = 2) or (T1.a = 3 and T2.b = 4) 
å¯ä»¥æŠŠ JOIN æ¡ä»¶è½¬æ¢æˆ T1.a = 1 or T1.a = 3ï¼Œç„¶åä¸‹æ¨ç»™ T1

ON æ¡ä»¶çš„ä¸‹æ¨åˆ†æ
4ã€
T1 SJ T2 ON XX1 WHERE XX2
XX1 å¯ä»¥ä¸‹æ¨åˆ°å·¦è¾¹

T1 ANTIJ T2 ON XX1 WHERE XX2
XX1 ä¸å¯ä»¥ä¸‹æ¨åˆ°å·¦è¾¹

on ä¸­çš„æ¡ä»¶ï¼š
5ã€INNER JOIN ï¼Œä¸¤è¾¹éƒ½å¯ä»¥ä¸‹æ¨
6ã€LEFT JOIN ï¼Œå³è¾¹å¯ä»¥ä¸‹æ¨ ï¼ˆå¾…é˜…æºç æ ¸å¯¹ï¼‰
7ã€FULL JOIN ï¼Œéƒ½ä¸å¯ä»¥ä¸‹æ¨ ï¼ˆå¾…é˜…æºç æ ¸å¯¹ï¼‰

WHERE æ¡ä»¶çš„ä¸‹æ¨åˆ†æ
T1 SJ T2 ON XX1 WHERE XX2

8ã€T1 LEFT JOIN T2 ON ä¸­çš„è¿‡æ»¤æ¡ä»¶å¯¹ T1 ä¸å…·æœ‰ä»»ä½•æ•ˆæœï¼Œä½†å¯¹ T2 å…¨éƒ¨æœ‰æ•ˆã€‚ä¾‹å­ï¼š
```sql
create table t1 (id int,a int);
create table t2 (id int,a int);
insert into t1 values(1,null);
insert into t2 values(1,1);

select t1.* from t1 left join t2 on t1.id=t2.id;
+----+------+
| id | a    |
+----+------+
|  1 | NULL |
+----+------+

select t1.* from t1 left join t2 on t1.id=t2.id and t1.id>1;   
+----+------+
| id | a    |
+----+------+
|  1 | NULL |
+----+------+

select t1.* from t1 left join t2 on t1.id=t2.id and t1.a is not null;
+----+------+
| id | a    |
+----+------+
|  1 | NULL |
+----+------+

select t2.* from t1 left join t2 on t1.id=t2.id and t2.id>1;
+------+------+
| id   | a    |
+------+------+
| NULL | NULL |
+------+------+

select t2.* from t1 left join t2 on t1.id=t2.id and t1.id>1;
+------+------+
| id   | a    |
+------+------+
| NULL | NULL |
+------+------+
```
ä½† INNER JOIN æ˜¯å·¦å³ä¸¤è¾¹éƒ½èµ·æ•ˆã€‚


è¿‡æ»¤æ¡ä»¶ï¼š å­—æ®µ ï¼Ÿ å¸¸é‡
å…³ç³»æ¡ä»¶ï¼š å­—æ®µ ï¼Ÿ å­—æ®µ
multiple equality æ¡ä»¶ï¼š å­—æ®µã€å­—æ®µã€â€¦â€¦ å­—æ®µ ï¼ˆæ²¡æœ‰å¸¸é‡ï¼‰

æ€»ç»“ï¼š
on ä¸­çš„å…³ç³»ã€è¿‡æ»¤æ¡ä»¶ï¼š
1ã€INNER JOIN : ä¸¤è¾¹éƒ½å¯ä»¥ä¸‹æ¨
2ã€LEFT JOIN  : å¯ä»¥ä¸‹æ¨åˆ°å³è¾¹ ï¼ˆå¾…é˜…æºç æ ¸å¯¹ï¼‰
3ã€FULL JOIN  : éƒ½ä¸å¯ä»¥ä¸‹æ¨   ï¼ˆå¾…é˜…æºç æ ¸å¯¹ï¼‰
4ã€SEMI JOIN  : å¯ä»¥ä¸‹æ¨åˆ°å·¦è¾¹ ï¼ˆå¾…é˜…æºç æ ¸å¯¹ï¼‰
5ã€ANTI JION  : éƒ½ä¸å¯ä»¥ä¸‹æ¨   ï¼ˆå¾…é˜…æºç æ ¸å¯¹ï¼‰
6ã€MULTI_INNER_JOIN ï¼š

where ä¸­çš„è¿‡æ»¤æ¡ä»¶ï¼š
1ã€INNER JOIN : æœ¬çº§ã€ä¸¤è¾¹éƒ½å¯ä»¥ä¸‹æ¨
2ã€LEFT JOIN  : å¯ä»¥ä¸‹æ¨åˆ°å·¦è¾¹  è·Ÿå·¦è¾¹ç›¸äº¤å¯ä»¥ä¸‹æ¨åˆ°æœ¬çº§ï¼ˆå¾…é˜…æºç æ ¸å¯¹ï¼‰ã€‚å¦‚æœè·Ÿå³è¾¹ç›¸äº¤ï¼Œåˆ™è¢«è½¬æ¢æˆ INNER JOIN
3ã€FULL JOIN  : å·¦å³ä¸¤è¾¹ã€æœ¬çº§éƒ½ä¸å¯ä»¥ä¸‹æ¨   ï¼ˆå¾…é˜…æºç æ ¸å¯¹ï¼‰ã€‚å¦‚æœè·Ÿå…¶ä¸­ä¸€ä¾§ç›¸äº¤ï¼Œåˆ™è¢«è½¬æ¢æˆ LEFT JOINï¼Œå¦‚æœåŒæ—¶ç›¸äº¤ï¼Œåˆ™è¢«è½¬æ¢æˆ INNER JOIN
4ã€SEMI JOIN  : å¯ä»¥ä¸‹æ¨åˆ°å·¦è¾¹ ï¼Œåªèƒ½è·Ÿå·¦è¾¹ç›¸äº¤ï¼Œå»ºè®®ç›´æ¥ä¸‹æ¨åˆ°å·¦è¾¹ï¼Œæ²¡å¿…è¦ä¸‹æ¨åˆ°æœ¬çº§ï¼ˆå¾…é˜…æºç æ ¸å¯¹ï¼‰
5ã€ANTI JION  : å¯ä»¥ä¸‹æ¨åˆ°å·¦è¾¹ ï¼Œåªèƒ½è·Ÿå·¦è¾¹ç›¸äº¤ï¼Œå»ºè®®ç›´æ¥ä¸‹æ¨åˆ°å·¦è¾¹ï¼Œæ²¡å¿…è¦ä¸‹æ¨åˆ°æœ¬çº§ï¼ˆå¾…é˜…æºç æ ¸å¯¹ï¼‰
6ã€MULTI_INNER_JOIN ï¼š

where ä¸­çš„å…³ç³»æ¡ä»¶ï¼š
1ã€INNER JOIN : æœ¬çº§ã€ä¸¤è¾¹éƒ½å¯ä»¥ä¸‹æ¨
2ã€LEFT JOIN  : å¯ä»¥ä¸‹æ¨åˆ°å·¦è¾¹ ï¼ˆå¾…é˜…æºç æ ¸å¯¹ï¼‰ã€‚å¦‚æœè·Ÿå³è¾¹ç›¸äº¤ï¼Œåˆ™è¢«è½¬æ¢æˆ INNER JOIN
3ã€FULL JOIN  : å·¦å³ä¸¤è¾¹ã€æœ¬çº§éƒ½ä¸å¯ä»¥ä¸‹æ¨   ï¼ˆå¾…é˜…æºç æ ¸å¯¹ï¼‰ã€‚å¦‚æœè·Ÿå…¶ä¸­ä¸€ä¾§ç›¸äº¤ï¼Œåˆ™è¢«è½¬æ¢æˆ LEFT JOINï¼Œå¦‚æœåŒæ—¶ç›¸äº¤ï¼Œåˆ™è¢«è½¬æ¢æˆ INNER JOIN
4ã€SEMI JOIN  : å¯ä»¥ä¸‹æ¨åˆ°å·¦è¾¹ï¼Œå› ä¸ºä¸ä¼šè·Ÿå³è¾¹ç›¸äº¤ ï¼ˆå¾…é˜…æºç æ ¸å¯¹ï¼‰
5ã€ANTI JION  : å¯ä»¥ä¸‹æ¨åˆ°å·¦è¾¹ï¼Œå› ä¸ºä¸ä¼šè·Ÿå³è¾¹ç›¸äº¤ ï¼ˆå¾…é˜…æºç æ ¸å¯¹ï¼‰
6ã€MULTI_INNER_JOIN ï¼š

multiple equality ä¸‹æ¨
æ¯”å¦‚ (A.ID,B.ID,C.ID) é‡åˆ° (A JOIN B) JOIN C
å¯ä»¥æŠŠ (A.ID,B.ID) ä¸‹æ¨åˆ°å·¦è¾¹ï¼Œä¹Ÿå°±æ˜¯ (A JOIN B) 

å¤šå±‚ join çš„ç­‰ä»·ä¸‹æ¨ç ”ç©¶ï¼š
```sql
mysql> select * from t1;
+----+------+------+------+------+
| id | a    | b    | c    | d    |
+----+------+------+------+------+
|  0 |    0 |    0 |    0 |    0 |
|  1 |    1 |    0 |    0 |    0 |
|  8 |    8 |    0 |    0 |    0 |
+----+------+------+------+------+
3 rows in set (0.00 sec)

mysql> select * from t2;
+----+------+------+------+------+
| id | a    | b    | c    | d    |
+----+------+------+------+------+
|  0 |    0 |    0 |    0 |    0 |
|  1 |    1 |    0 |    0 |    0 |
|  2 |    2 |    0 |    0 |    0 |
+----+------+------+------+------+
3 rows in set (0.00 sec)

mysql> select * from t3;
+----+------+------+------+------+
| id | a    | b    | c    | d    |
+----+------+------+------+------+
|  1 |    1 |    0 |    0 |    0 |
|  2 |    2 |    0 |    0 |    0 |
|  3 |    3 |    0 |    0 |    0 |
|  8 |    8 |    0 |    0 |    0 |
+----+------+------+------+------+
4 rows in set (0.00 sec)

mysql> select t1.*,t2.*,t3.* from t1 left join t2 on 1=1 left join t3 on t1.id=t2.id and t1.id=t3.id;
+----+------+------+------+------+------+------+------+------+------+------+------+------+------+------+
| id | a    | b    | c    | d    | id   | a    | b    | c    | d    | id   | a    | b    | c    | d    |
+----+------+------+------+------+------+------+------+------+------+------+------+------+------+------+
|  0 |    0 |    0 |    0 |    0 |    2 |    2 |    0 |    0 |    0 | NULL | NULL | NULL | NULL | NULL |
|  0 |    0 |    0 |    0 |    0 |    1 |    1 |    0 |    0 |    0 | NULL | NULL | NULL | NULL | NULL |
|  0 |    0 |    0 |    0 |    0 |    0 |    0 |    0 |    0 |    0 | NULL | NULL | NULL | NULL | NULL |
|  1 |    1 |    0 |    0 |    0 |    2 |    2 |    0 |    0 |    0 | NULL | NULL | NULL | NULL | NULL |
|  1 |    1 |    0 |    0 |    0 |    1 |    1 |    0 |    0 |    0 |    1 |    1 |    0 |    0 |    0 |
|  1 |    1 |    0 |    0 |    0 |    0 |    0 |    0 |    0 |    0 | NULL | NULL | NULL | NULL | NULL |
|  8 |    8 |    0 |    0 |    0 |    2 |    2 |    0 |    0 |    0 | NULL | NULL | NULL | NULL | NULL |
|  8 |    8 |    0 |    0 |    0 |    1 |    1 |    0 |    0 |    0 | NULL | NULL | NULL | NULL | NULL |
|  8 |    8 |    0 |    0 |    0 |    0 |    0 |    0 |    0 |    0 | NULL | NULL | NULL | NULL | NULL |
+----+------+------+------+------+------+------+------+------+------+------+------+------+------+------+
9 rows in set (0.00 sec)
```
å¯ä»¥çœ‹å‡ºå¦‚æœ t1.id=t2.id ä¸‹æ¨ç»™ t1 left join t2 å°±ä¸ç­‰ä»·äº†


CertainlyUsedTablesForCondition ä¾‹å­
// éå† expr.join_conditionsï¼Œè·å–æ¡ä»¶ä¸­ä½¿ç”¨çš„è¡¨ã€‚å› ä¸º multiple equalities çš„ used_tables() æ²¡æœ‰è®¾ç½®ï¼Œæ‰€ä»¥éœ€è¦ç‰¹æ®Šå¤„ç†
// å¦‚æœ cond æ˜¯ multiple equalitiesï¼Œæ ¹æ® leftã€right çš„ RelationalExpression::type æ¥è·å– used_tables
// GetVisibleTablesï¼šSEMIJOINã€ANTIJOIN è¿”å›å·¦è¾¹ RelationalExpression çš„ tables_in_subtreeï¼Œå…¶ä»–è¿”å› å·¦å³ä¸¤è¾¹ RelationalExpression çš„ tables_in_subtree
ä¹Ÿå°±æ˜¯å„ç§JOINç±»å‹ï¼Œåªæœ‰ SEMIJOINã€ANTIJOIN å³è¾¹çš„è¡¨ï¼Œå¯¹äºä¸Šå±‚æ¥è¯´ä¸å¯è§


expr->companion_set 
å¦‚æœ expr æ˜¯è¡¨ ï¼Œåˆ™éå† expr->join_conditions_pushable_to_thisï¼ŒæŠŠé‡Œé¢çš„ç­‰å¼æ·»åŠ åˆ° expr->companion_set
å…¶å®ƒæƒ…å†µï¼Œåˆ™éå† expr->equijoin_conditionsï¼ŒæŠŠé‡Œé¢çš„ç­‰å¼æ·»åŠ åˆ° expr->companion_set

select t1.* from t1
left join t2 on t1.id=t2.a
left join t3 on t1.b=t3.c
where t1.a=1 and t2.a=t1.a and t3.a=t1.a # å¸¸é‡æ›¿æ¢
      and ((t1.b = 1 and t2.b=2) or (t1.b=1 and t2.c=2)) # å…¬å…±å­è¡¨è¾¾å¼æ¶ˆé™¤åæ˜¯ (t1.b = 1 and ( t2.b= 2 or t2.c=2))
      and t3.id # æ ‡é‡å¤„ç†
      and t1.b=t3.id
      ;
å¾—åˆ°çš„ expr->companion_set æ˜¯
Mem_root_array_Field_0x7fff3411b840
0x7fff340ac530   Field_long * ---- field_name:t1.b 
0x7fff34018cc0   Field_long * ---- field_name:t3.id


Selectivity æ¢ç´¢
æ„æ€ï¼šç»™å‡ºä¸€ä¸ªå¸¸é‡ï¼Œè®¡ç®—å®ƒåœ¨è¡¨ä¸­çš„å‘½ä¸­ç‡
  EstimateEqualPredicateSelectivity(const EqualFieldArray &equal_fields, const CompanionSet &companion_set, string *trace)

å¦‚æœ WHERE æ¡ä»¶ä¸­å‡ºç° å­—æ®µA=å­—æ®µBï¼Œåˆ™å®ƒä¸€å®šæ˜¯ INNER|ANTI|SJ JOIN çš„æ¡ä»¶


select t1.* from t1
left join t2 on t1.id=t2.a
left join t3 on t1.d=t3.c
where t1.a=1 and t2.a=t1.a and t3.a=t1.a # å¸¸é‡æ›¿æ¢
      and ((t1.b = t2.d and t2.b=2) or (t2.d=t1.b and t2.c=2)) # å…¬å…±å­è¡¨è¾¾å¼æ¶ˆé™¤åæ˜¯ (t1.b = t2.d and ( t2.b= 2 or t2.c=2))
	  ;

æ£€æŸ¥èƒ½ä¸èƒ½è¯†åˆ« t1.b = t2.d è·Ÿ t2.d=t1.b æ˜¯ä¸€æ ·
æœ‰ BUG
```sql
select t1.* from t1
left join t2 on t1.id=t2.a
left join t3 on t1.d=t3.c
where t1.a=1 and t2.a=t1.a and t3.a=t1.a # å¸¸é‡æ›¿æ¢
      and ((t1.b = t2.d and t2.b=2) or (t2.d=t1.b and t2.c=2)) # å…¬å…±å­è¡¨è¾¾å¼æ¶ˆé™¤åæ˜¯ (t1.b = t2.d and ( t2.b= 2 or t2.c=2))
	  ;
è¯¥SQL åœ¨è¿™é‡Œ  (((`test`.`t1`.`b` = `test`.`t2`.`d`) and (`test`.`t2`.`b` = 2)) or ((`test`.`t2`.`d` = `test`.`t1`.`b`) and (`test`.`t2`.`c` = 2))) æ²¡ç”Ÿæˆå¯¹åº”çš„ multiple_equalityï¼Œå¯¼è‡´æ²¡æœ‰è§¦å‘ å…¬å…±å­è¡¨è¾¾å¼æ¶ˆé™¤

å¦‚æœæŠŠ left join t3 on t1.d=t3.c æ”¹å†™æˆ left join t3 on t1.b=t3.c
å®ƒä¼šç”Ÿæˆ å¯¹åº”çš„ multiple_equalityï¼Œç„¶åè§¦å‘ å…¬å…±å­è¡¨è¾¾å¼æ¶ˆé™¤
```
