
# CSE (Common Subexpression Elimination)
**公共子表达式消除**（Common Subexpression Elimination，简称 CSE）的概念。假设我们有以下两个条件：
```sql
`SELECT * FROM 
EMP, DEPT 
WHERE 
(EMP.DEPTNO = DEPT.DEPTNO AND LOC = 'DALLAS' AND SAL > 100000) OR 
(EMP.DEPTNO = DEPT.DEPTNO AND LOC = 'DALLAS' AND JOB_TITLE = 'VICE PRESIDENT')`
```
在这里，`EMP.DEPTNO = DEPT.DEPTNO AND LOC = 'DALLAS'` 就是共子表达式，改写后变成：

```sql
SELECT * FROM 
EMP, DEPT 
WHERE 
EMP.DEPTNO = DEPT.DEPTNO AND LOC = 'DALLAS' AND 
(SAL > 100000 OR JOB_TITLE = 'VICE PRESIDENT');
```

改写之前，从 `DEPT` 吐出的每一行数据都会计算两次 `LOC='DALLAS'` 表达式，改写后只需要计算一次。这样，我们避免了重复计算，提高了查询性能。这就是公共子表达式消除的基本思想！🚀

这个技术在编译器和数据库优化器中都有广泛应用，它可以有效地减少冗余计算，提高代码执行效率。

# Item 类关系图
[官方 Item_bool_func 类关系图](https://dev.mysql.com/doc/dev/mysql-server/latest/classItem__bool__func__inherit__graph_org.svg)

[Item_basic_constant 类关系图](https://www.plantuml.com/plantuml/uml/lLVDZjis4BxhAOZDnKwoGD0UMcJR8bvRTLnu9KUsc-o9eAMnpKQYL9BQsDW6Q2y5-WfzXnRehJ-Fqotw6gKeYQNbTUJj1WtWI1f-C_FDS6R8VIOauJ9FOgSV4o7GX701M780pD98lILPlJIIa5mxIFrxfD_HGmORYPSAgwKFq5HoobP8I8wlI9n31HxC-caS4qbJXiBwpJA46Ka0YrAPre93W9JJbGt8APCVVe0Iii4ni9LSMufFdsfp2U6lWQFoOTlb8F9OeZ39S9WogSAnZA9YVQaMSbQB5saQAp5P41Qb3A9Ah7I5B1Ufm5cHGeuBpvQrZvLUH2J1SflLrFkfaFvIvp9HViIEcoNTGBHZ88AG9YGMMdXQas6vokWY1bkta9ajCDAS2RfIhF4o9glTY1JjDrJ5z0OlSnPQ-wFNrpIAW3Kq60xN4Bx6EdXE54CC6mXnA3SLGI69f66PdIg4IU1Fy7H-_cBk1fTdRRYP7xW3hDw7GU-Y3TqR3WDts9kDVAyD-dBa3VoN-FEvrpy67lZZyNo2tLUJe0qw3FpvPEGDjUq2_C1iFWd3FC4PJpFWae8uSzuwB9M0L3slvTEofVx-vO-RNt_ww-SVRtxxuURtxu7b2PgfWldps-_qkt8OLLLRYrJkhw1esfH7m1qdDCsA5qJGiDmWmYIwTWhgiYWMd90CvG8YR3uL7Ljt3PkwumgzHyXmGKK5TxfLyAbopca4w1fna3bdwCjUS3xoy6ZcNfoXjqwpsSe7RZ4odGL56WDtEX_FQZC2vByzrBcudBuOuzdbnCNAPVzvB-WsObXGPc9eB7qbKbOb96Vqwnnm9ZcEGC7JBKvPl4M9wQ3su9kyxU2lKXgXJB6GdL9hzdo07Zwkf-L3vVAnTe0L3RxLmJKTdFqlQVnYwdkD7EhnWgxVhUVDn-EkXfZfZJv5Nk_2nIM1paa1EUdUBPU5plikesPm2RhU5LL3LeVy02LR8wYU_wKe1cv_TD6xNop6oh6RwRalAutcbYxZbDJJmBDErapn02Rhu_aHYj9y4GCo4HzsDl3dvsFtZliRk5PE6XHp5kACbYGh0pPLlSwKG7iqNvsTcijeftlIrQJkst-Aj8ATVaQo35ZKCGwx-zILdwfVufIjYjyn2Hpxth3utJ658szspwfI5WwsXpxg6_sHc_XsxnEguINFOJyP-4a5tzcR9oVDgZI3shhRX0AB34Awf10TUGBSSrg__ncJ4IvfqL9bKGko11Dh8zrnkcWRjUTZ__oEGMgzv_vuu0Rxx239v7QVpsGsmZ6Lm4cCSnO15s7A0OThmXKrVR0gzyShh65JArZEorjKvLsdfm7G6IjkDofzjrLHjLIqkRElICFyNSfcsHYmOf6maNL0vLbWxlSVBQZKWh7xgZA6AkHX6_h3olC152iIPc_7RN-FeK--EJtLSJh5V-QpUU5pRf4Pi7t3SnhV1cHVeLgi5HUg5aXnbMY594xzOiJcK6ukcSFCCQ-MiVeGkKsBrjcXjdizy6wJvtjuQxorX6Hbpqvlst1mMjPjrcfk70-tMtwVrf6TVwnUSm3iwnqO1Cu1kQLa3uTZuLRFxrDfTgFJ53HX-wtThhBVvuxp35YK9_4_)

[Item_ident、Item_result_field 类关系图](https://www.plantuml.com/plantuml/uml/jLZTRjl85RxdKmpYcqHn2ZG5Yi9UBDQr5LUe8pbQgMwxM0n6vA4qDJd3p0njgMg0zgP0xtlL1Ve63T2x_lTXciNkNL-XCsT83IdJFtRg0B66v-VZTywSCp_yJ1kcJ9bdqM76j2QdJ6cWHW5G8HCxoejQDJ2GhoDY_pt7CUa9M1gQMbkKxf3FZU9YJhHHz89b9LJ6HvD3cMNCS2b8N8yQG5Im7AZsphmMN6SW5Pyt3KekpFTUafmjQGPYRXODnxqzXCkPEWT5_4yJLu4kCqFYlA2n5CQ6qm0bJfzQHIbgyKpAp8hPZ8b42aWgiVNLnYkvfeLBeQBkpGsq7rY_X1b6pQgegHzARKOfvZAtxz6jrwHy2KaB886OvopJA7nHan6bpUWiWwQla-4KjAIbq7nkMTCqO_DsH9Rs9RSnNTAq5B6Vdw1Vy2G1iUKXQBo0-9nYy8fPXXIM4DFOB2k2sZ33Ov-TAeJJyUYKVZxzuPjfV_op_Tli9gDn_uZQyV7uuFLjrWV7n-F-yS5aC1hUPdes61wDpkYhwV3mBkRZqSd9z9JsVtewlitqU3oQdWw6nuZjZ7Ssay_YkCnfeMG1od3G-z6xI4W3nDRpmkpvblhcpt__y9S_VVt-3n_--hiFV_ijY38d4rim__drRt1iNvXKLLkBZ68Nu9fMgWHKr6ZMof2c7B9aZMHUkI7fDHMMHiC7vz_QxbGjtcDgRWlkHVMOKyXda2IGKAieSn16V_7oowXk6Iki6sQdKOfIO9aweJVBCdc96CuyqqvXN17Jd1Mar5Q5Zvh6p5PPMosaGRIsYMMmoHPnFVRqMJKzqgP7yGJ8cYWmfHB4JGuTJFglzyaxvtZ1bIbPvW5UkGPm82aE0b3mdmv_F1oT3Vqajo5yckPWN6nFCLZ-B7YwR7x1lsmxUVXkLw-x5a3oX1JAcZxrTfCV7P6UMIIxzLhSqqRjOc3qRGbgHJ6qCDnEKXkLok8ZWHrU4z3nlnaI0q-LpE-2tcwXJT-qP_A___YAVFl-Nz_yyxrLrRNnxRz___LNVmobq6e2Im4RWQpVDSMkeEi62Gjmh80PIEXiPVrUmf9hexUQofAj6l34QZzniaz9PeSeGnmsayg4HY7FxrJ9XwFXKQZaHwc8_OvOAFFnFFS4-c-c1oS45V2sP4Y_kvbkZUN0_g_RAcojyO8fqdCOkFFV0FB4CdjYdRj8IqNM7q5jDFuuPb9r4CDyhVsk4eh3hyoV4lpHg0qhi7i1DfANu-c5emxibe_3IdE0osjUCCMCLCwmUNJ0dAGiqz2IeZrGfjrn1NGuBZLUdieiiRM4ApzvK4PVJqyclcuQINrGMlCoCxp8W60gdmGaMHYUyr-2Bt0D6SI6ri9cTpphW1sTJWQl1p_lUuu1zD7xAomoBt75w9x4xaMZVQpTJ6Nt9cQ1lkCscxRLFTUHkuT9rk5yiRUtsLqGqI4rNPjj4hmgfbnBiRKkmriwOnfySuUsiXHbgMAWTObuCJUhBdJKFNI1Q5To9_h3ePkuNVSpyiclNlZb8N9_mYDjdVEkID0mS8ms8rIqTy8eFBKCGhb6xKSq2Ojlj1bjAIYxIIbL9soOusvrku-YhMSqwgohg4k8vgr2YveFMsXMVBCQMKTnux2HW33Owwt5BwTuqqrck09UfyOpy8qMEDN1ehx2PfnfAbCAoq95M9b3Q-BgGsQbkm3MDsBIgmPNThr0hIr7Jjqg91DK4xHKa98UdkBziT_htk1wCCjaV6vV1GM8nEhTmV2H3ZfaxV4wrwHTugErWn3Ui__VgMktAxDkaz_jJYtggWXm1ma55UvxhGIRUeYAwYA8fX6UPZkkXasvXJTKAbkGe0qN34kaswhRmd-deOPSZqHpoEDYvOXskDng7gvHNczR05kGyeseUMulb3GGLoTt9bRL1vChcmZVZ9qAINtt-yGpu2A1vGqUb6KP_ONaWWfmruBmXKPIfCk4SKGADiV0DcyW2tO1LiClU0PpQ7XQfftoc0bQQkS3AL_ISrYXxkwNua7_9DmbMXM51RGEhofARNiraPU2jXlpsZeAtnCGp1zIxyTlt7_r-3UTLjHiFbTWvmKQyOyjUMJhehY5SVr5gayjzwj9bQK1jO5-qLxmyA2IhcmOKJX-Rpn2nUdIohbmltuN3jyFPIaIwbJ-v8lNpVk6C9fE-kDk-iuRFyCi82j0OH0xNeLyPlwzblMb0BMTsmiEbo7svZgLSgMDXR1EVZVOlpVhdmpwPmtIuL0Kzjie38FALskd2hDU3u8ur4Y7GPZb3cLN3jicxKH5du58oZpx7m00)

# Field 类关系图
[官方 Field 类关系图](https://dev.mysql.com/doc/dev/mysql-server/latest/classField__inherit__graph_org.svg)

[cmp_item 类关系图]
https://www.plantuml.com/plantuml/svg/rLPDQnin4BtlhvXJM3inz5XmABHfId983OdlGjwTnDlgmvMqDiPjVdlHpieL6rab9X1y2B5cthoPUUEHTIMujG2LNB76eIns1S3vltEvraqzcfBnEMbTDyQrNC12Qm5S25rnXspDHOkiqdB53NVQsFBk-exTpsPp65_iwVtds-x_aCrd0EkqwQdADAnHpfDbl5G2bfLMraM9Hz1P-WZhk6kgo0qADr7vvVpcQoYM6RIjS7JmHgA-klby_t0zPxVVlyrUb18pI_uJcUKIWupPnjbYonpAbU0EowHkVufYC4LcAowuANPG04o0HYEPQeKWqYav-cJe8bVfmQCfUDhAqqQipZJgAR1Irm-T3SPKgq7RKvFzI_luYERouuTF4ELD2kQpL4jkBBeETJxCMwPb9knh9auH-IzQcbYkqjxST5D2_h1Q5JiQGQkQNosobJEiHkkCtZAjn1PaFwd_ePPQr6W85gRHIHRYeuKEkSi3T1U7yWnl0AAX3e_UkRTRzVm44WDebElr5rez-Jy8QhtNBNHyCpLtw1g9NKUfdW0yEwMc4ZVSg2wuTz8DiUIs8ml6OOPGVjHcTfC6k8nQhrrX2ZbIBuDSxBMgTRiGI4gTQaCrLesCUfBRO3hjlepUX9wYo77qg9ZstjRNei8f9Y3sK4ViYN_IOPo6n0SuEzk3dW-dUAFdq6dCZ917FrreNWEfGaIirc1Mz6K9X9U_9vCNJv_1cK235qKUHB_IUKYZN0uHNPrP6Dr9UKXOwNJVj2n_0G00

# 表达式优化研究
```sql
drop table if exists t1;
drop table if exists t2;
drop table if exists t3;
drop table if exists t4;
drop table if exists t5;
drop table if exists t6;

create table t1 (id int primary key, a int, b int default 0, c int default 0, d int default 0);
create table t2 (id int primary key, a int, b int default 0, c int default 0, d int default 0);
create table t3 (id int primary key, a int, b int default 0, c int default 0, d int default 0);
create table t4 (id int primary key, a int, b int default 0, c int default 0, d int default 0);
create table t5 (id int primary key, a int, b int default 0, c int default 0, d int default 0);
create table t6 (id int primary key, a int, b int default 0, c int default 0, d int default 0);
insert into t1 (id,a) values (0,0),(1,1),(8,8);
insert into t2 (id,a) values (0,0),(1,1),(2,2);
insert into t3 (id,a) values (1,1),(2,2),(3,3),(8,8);
insert into t4 (id,a) values (2,2),(3,3),(4,4);
insert into t5 (id,a) values (2,2),(3,3),(4,4),(5,5);
insert into t6 (id,a) values (2,2),(3,3),(4,4),(5,5),(6,6);


((SELECT * FROM t1 UNION SELECT * FROM t2 UNION ALL SELECT * FROM t3
             ORDER BY a LIMIT 5) INTERSECT
            (((SELECT * FROM t3 ORDER BY a LIMIT 4) ) EXCEPT SELECT * FROM t4)
            ORDER BY a LIMIT 4) ORDER BY -a LIMIT 3;

set optimizer_switch="hypergraph_optimizer=on";

select t1.* from t1
left join t2 on t1.id=t2.id
left join t3 on t1.id=t3.id
where t1.a=1 and t2.a=t1.a and t3.a=t1.a # 常量替换
      and ((t1.b = 1 and t2.b=2) or (t1.b=1 and t2.c=2)) # 公共子表达式消除后是 (t1.b = 1 and ( t2.b= 2 or t2.c=2))
      and t3.id # 标量处理
      ;

      
# 查看 SJ 和 AJ
select * from t1 where exists (select 1 from t2 where t1.id=t2.id) and not exists (select 1 from t3 where t1.id=t3.id) and t1.id=(select min(id) from t4) and t1.id=t1.a;

-exec source /data/ldc_docker/mysql-server/study/object2.py
-exec mysql join_graph graph
-exec mysql Mem_root_array graph->edges
```
# 查看 BLOCK 的 MULTI EQUAL
## 等式中有子查询
```sql
 select * from t1 where exists (select 1 from t2 where t1.id=t2.id) and not exists (select 1 from t3 where t1.id=t3.id) and t1.id=(select min(id) from t4) and t1.id=t1.a;

MakeJoinHypergraph 前

SELECT `test`.`t1`.`id` AS `id`,
       `test`.`t1`.`a` AS `a`,
       `test`.`t1`.`b` AS `b`,
       `test`.`t1`.`c` AS `c`,
       `test`.`t1`.`d` AS `d`
FROM `test`.`t1` semi
JOIN (`test`.`t2`) anti
JOIN (`test`.`t3`) on((`test`.`t1`.`id` = `test`.`t3`.`id`))
WHERE ((`test`.`t1`.`id` =
          (SELECT min(`test`.`t4`.`id`)
           FROM `test`.`t4`))
       AND (`test`.`t1`.`id` = `test`.`t1`.`a`)
       AND (`test`.`t1`.`id` = `test`.`t2`.`id`))

MakeJoinHypergraph 后

 SELECT `test`.`t1`.`id` AS `id`,
       `test`.`t1`.`a` AS `a`,
       `test`.`t1`.`b` AS `b`,
       `test`.`t1`.`c` AS `c`,
       `test`.`t1`.`d` AS `d`
FROM `test`.`t1` semi
JOIN (`test`.`t2`) anti
JOIN (`test`.`t3`) on(multiple equal(`test`.`t1`.`id`, `test`.`t1`.`a`, `test`.`t2`.`id`, `test`.`t3`.`id`))
WHERE ((`test`.`t1`.`id` =
          (SELECT min(`test`.`t4`.`id`)
           FROM `test`.`t4`))
       AND ((`test`.`t1`.`id` = `test`.`t1`.`a`)
            AND (`test`.`t1`.`id` = `test`.`t2`.`id`)))
end note
```
## 等式中有没有子查询
```sql
select * from t1 where exists (select 1 from t2 where t1.id=t2.id) and not exists (select 1 from t3 where t1.id=t3.id)  and t1.id=t1.a;

MakeJoinHypergraph 前

SELECT `test`.`t1`.`id` AS `id`,
       `test`.`t1`.`a` AS `a`,
       `test`.`t1`.`b` AS `b`,
       `test`.`t1`.`c` AS `c`,
       `test`.`t1`.`d` AS `d`
FROM `test`.`t1` semi
JOIN (`test`.`t2`) anti
JOIN (`test`.`t3`) on(multiple equal(`test`.`t1`.`id`, `test`.`t1`.`a`, `test`.`t2`.`id`, `test`.`t3`.`id`))
WHERE multiple equal(`test`.`t1`.`id`, `test`.`t1`.`a`, `test`.`t2`.`id`)

MakeJoinHypergraph 后

SELECT `test`.`t1`.`id` AS `id`,
       `test`.`t1`.`a` AS `a`,
       `test`.`t1`.`b` AS `b`,
       `test`.`t1`.`c` AS `c`,
       `test`.`t1`.`d` AS `d`
FROM `test`.`t1` semi
JOIN (`test`.`t2`) anti
JOIN (`test`.`t3`) on(multiple equal(`test`.`t1`.`id`, `test`.`t1`.`a`, `test`.`t2`.`id`, `test`.`t3`.`id`))
WHERE multiple equal(`test`.`t1`.`id`, `test`.`t1`.`a`, `test`.`t2`.`id`)
```
## 等式中有 a+b=c
```sql
select * from t1 where exists (select 1 from t2 where t1.id=t2.id) and not exists (select 1 from t3 where t1.id=t3.id)  and t1.id=t1.a and t1.b=t1.c+t1.d and t1.b=2;

MakeJoinHypergraph 前

SELECT `test`.`t1`.`id` AS `id`,
       `test`.`t1`.`a` AS `a`,
       `test`.`t1`.`b` AS `b`,
       `test`.`t1`.`c` AS `c`,
       `test`.`t1`.`d` AS `d`
FROM `test`.`t1` semi
JOIN (`test`.`t2`) anti
JOIN (`test`.`t3`) on(multiple equal(`test`.`t1`.`id`, `test`.`t1`.`a`, `test`.`t2`.`id`, `test`.`t3`.`id`))
WHERE ((2 = (`test`.`t1`.`c` + `test`.`t1`.`d`))
       AND multiple equal(`test`.`t1`.`id`, `test`.`t1`.`a`, `test`.`t2`.`id`)
       AND multiple equal(2, `test`.`t1`.`b`))

MakeJoinHypergraph 后

SELECT `test`.`t1`.`id` AS `id`,
       `test`.`t1`.`a` AS `a`,
       `test`.`t1`.`b` AS `b`,
       `test`.`t1`.`c` AS `c`,
       `test`.`t1`.`d` AS `d`
FROM `test`.`t1` semi
JOIN (`test`.`t2`) anti
JOIN (`test`.`t3`) on(multiple equal(`test`.`t1`.`id`, `test`.`t1`.`a`, `test`.`t2`.`id`, `test`.`t3`.`id`))
WHERE ((2 = (`test`.`t1`.`c` + `test`.`t1`.`d`))
       AND ((`test`.`t1`.`id` = `test`.`t1`.`a`)
            AND (`test`.`t1`.`id` = `test`.`t2`.`id`))
       AND (`test`.`t1`.`b` = 2))
```

# 查看 MULTI JOIN
## 没有笛卡尔积
```sql
select t1.* from t1,t2,t3,t4 where t1.id=t2.id and t1.id=t3.id and t1.id=t4.id;

MakeJoinHypergraph 前

SELECT `test`.`t1`.`id` AS `id`,
       `test`.`t1`.`a` AS `a`,
       `test`.`t1`.`b` AS `b`,
       `test`.`t1`.`c` AS `c`,
       `test`.`t1`.`d` AS `d`
FROM `test`.`t1`
JOIN `test`.`t2`
JOIN `test`.`t3`
JOIN `test`.`t4`
WHERE multiple equal(`test`.`t1`.`id`, `test`.`t2`.`id`, `test`.`t3`.`id`, `test`.`t4`.`id`)

MakeJoinHypergraph 后

SELECT `test`.`t1`.`id` AS `id`,
       `test`.`t1`.`a` AS `a`,
       `test`.`t1`.`b` AS `b`,
       `test`.`t1`.`c` AS `c`,
       `test`.`t1`.`d` AS `d`
FROM `test`.`t1`
JOIN `test`.`t2`
JOIN `test`.`t3`
JOIN `test`.`t4`
WHERE multiple equal(`test`.`t1`.`id`, `test`.`t2`.`id`, `test`.`t3`.`id`, `test`.`t4`.`id`)

MakeJoinHypergraph 中途
PushDownAsMuchAsPossible 之前是 MULTI_INNER_JOIN
PushDownAsMuchAsPossible 之后是 INNER_JOIN，没有 MULTI_INNER_JOIN

@startuml

map RelationalExpression_0x7fff3ca626c0 #header:Gold;back:lightgreen{
         type => <RelationalExpression::Type> RelationalExpression::MULTI_INNER_JOIN
         tables_in_subtree => <table_map> 0000000000001111
         nodes_in_subtree => <hypergraph::NodeMap> 1000111110001111100011111000111110001111100011111000111110001111
         table => <const Table_ref *> 0x8f8f8f8f8f8f8f8f
         join_conditions_pushable_to_this.address => <Mem_root_array<Item*>> 0x7fff3ca626e0
         companion_set => <CompanionSet *> 0x7fff3ca62920
         left => <RelationalExpression *> 0x0
         right => <RelationalExpression *> 0x0
         multi_children.address => <Mem_root_array<RelationalExpression*>> 0x7fff3ca62718
         join_conditions.address => <Mem_root_array<Item*>> 0x7fff3ca62738
         equijoin_conditions.address => <Mem_root_array<Item_eq_base*>> 0x7fff3ca62758
         properties_for_join_conditions.address => <Mem_root_array<CachedPropertiesForPredicate>> 0x7fff3ca62778
         properties_for_equijoin_conditions.address => <Mem_root_array<CachedPropertiesForPredicate>> 0x7fff3ca62798
         join_conditions_reject_all_rows => <bool> false
         conditions_used_tables => <table_map> 0000000000000000
         join_predicate_first => <int> 0
         join_predicate_last => <int> 0
         conflict_rules.address => <Mem_root_array<ConflictRule>> 0x7fff3ca627d0
}

map Mem_root_array_RelationalExpression_0x7fff3ca62718 #header:Gold;back:Tomato {
         0x7fff3ca620d0 => RelationalExpression *
         0x7fff3ca62330 => RelationalExpression *
         0x7fff3ca62590 => RelationalExpression *
         0x7fff3ca627f0 => RelationalExpression *
}


map CompanionSet_0x7fff3ca62920 #header:Gold;back:lightgreen{
         m_equal_terms.address => <Mem_root_array<CompanionSet::EqualTerm>> 0x7fff3ca62920
}

RelationalExpression_0x7fff3ca626c0::multi_children.address --> Mem_root_array_RelationalExpression_0x7fff3ca62718 : multi_children.address
RelationalExpression_0x7fff3ca626c0::companion_set --> CompanionSet_0x7fff3ca62920 : companion_set

@enduml
```
## 有笛卡尔积
```sql
select t1.* from t1,t2,t3,t4 where t1.id=t2.id and t1.id=t3.id ;

MakeJoinHypergraph 前

SELECT `test`.`t1`.`id` AS `id`,
       `test`.`t1`.`a` AS `a`,
       `test`.`t1`.`b` AS `b`,
       `test`.`t1`.`c` AS `c`,
       `test`.`t1`.`d` AS `d`
FROM `test`.`t1`
JOIN `test`.`t2`
JOIN `test`.`t3`
JOIN `test`.`t4`
WHERE multiple equal(`test`.`t1`.`id`, `test`.`t2`.`id`, `test`.`t3`.`id`)

MakeJoinHypergraph 后

SELECT `test`.`t1`.`id` AS `id`,
       `test`.`t1`.`a` AS `a`,
       `test`.`t1`.`b` AS `b`,
       `test`.`t1`.`c` AS `c`,
       `test`.`t1`.`d` AS `d`
FROM `test`.`t1`
JOIN `test`.`t2`
JOIN `test`.`t3`
JOIN `test`.`t4`
WHERE multiple equal(`test`.`t1`.`id`, `test`.`t2`.`id`, `test`.`t3`.`id`)

MakeJoinHypergraph 中途
PushDownAsMuchAsPossible 之前是 MULTI_INNER_JOIN
PushDownAsMuchAsPossible 之后是 MULTI_INNER_JOIN、和 INNER_JOIN 的混合

在 MakeJoinHypergraph 后 继续查看
-exec mysql Mem_root_array graph->edges
发现没有 MULTI_INNER_JOIN，其中表 t4 跟其它表比较，少了 join_conditions_pushable_to_this，全部有 companion_set

```

# 跟踪一次
```sql
select t1.* from t1
left join t2 on t1.id=t2.id
left join t3 on t1.id=t3.id
where t1.a=1 and t2.a=t1.a and t3.a=t1.a # 常量替换
      and ((t1.b = 1 and t2.b=2) or (t1.b=1 and t2.c=2)) # 公共子表达式消除后是 (t1.b = 1 and ( t2.b= 2 or t2.c=2))
      and t3.id # 标量处理
      ;

select t1.* from t1
left join t2 on t1.id=t2.a
left join t3 on t1.b=t3.c
where t1.a=1 and t2.a=t1.a and t3.a=t1.a # 常量替换
      and ((t1.b = 1 and t2.b=2) or (t1.b=1 and t2.c=2)) # 公共子表达式消除后是 (t1.b = 1 and ( t2.b= 2 or t2.c=2))
      and t3.id # 标量处理
      and t1.b=t3.id
      ;

select 
	t1.* 
from t1
left join t2 on t1.id=t2.id
left join t3 on t1.id=t3.id
where t1.a=1 and t2.a=t1.a and t3.a=t1.a # 常量替换
      and ((t1.b = 1 and t2.b=2) or (t1.b=1 and t2.c=2)) # 公共子表达式消除后是 (t1.b = 1 and ( t2.b= 2 or t2.c=2))
      and t3.id # 标量处理
       and t1.d=t2.d and t1.d=t3.d and t1.c=t2.d;
      
MakeJoinHypergraph 之前
-exec mysql expr thd->lex->unit
SELECT `test`.`t1`.`id` AS `id`,
       `test`.`t1`.`a` AS `a`,
       `test`.`t1`.`b` AS `b`,
       `test`.`t1`.`c` AS `c`,
       `test`.`t1`.`d` AS `d`
FROM `test`.`t1`
JOIN `test`.`t2`
JOIN `test`.`t3`
WHERE (
      (
            (multiple equal(1, `test`.`t1`.`b`) AND multiple equal(2, `test`.`t2`.`b`))
            OR (multiple equal(1, `test`.`t1`.`b`) AND multiple equal(2, `test`.`t2`.`c`))
      )
      AND (0 <> `test`.`t3`.`id`)
      AND multiple equal(1, `test`.`t1`.`a`, `test`.`t2`.`a`, `test`.`t3`.`a`)
      AND multiple equal(`test`.`t1`.`id`, `test`.`t3`.`id`, `test`.`t2`.`id`))

  RelationalExpression *root =  // 后续遍历 join_list，1、如果是 sj 或者 aj，则递归 2、如果不是 sj 或者 aj，则直接生成 RelationalExpression 3、拿到优化后的 <Item *> Table_ref->m_join_cond_optim，如果是 multiple equalities，则 3.1、标量处理，3.2、常量处理（每个字段填充常量），3.3、涉及表个数大于2的处理（提取公共表），3.4、涉及表个数等于2的处理（获取 Item_func_eq）
      MakeRelationalExpressionFromJoinList(thd, query_block->m_table_nest); // 递归遍历 join_cond 中的每个一 AND 项目，然后存放到 Mem_root_array<Item *> join->join_conditions 数组中，消除多余的过滤条件，重排序 Mem_root_array<Item *> 数组

-exec mysql RelationalExpression root
对应的图
```
![alt text](pic/001.png)
可以观察到，因为 WHERE 条件中会对 LEFT JOIN 右边的表拒绝 NULL，所以连接被转换成了 INNER JOIN
```sql
  CompanionSetCollection companion_collection(thd, root);
```
![alt text](pic/002.png)
```sql
  FlattenInnerJoins(root);  // 如果 RelationalExpression 符合转换成 MULTI_INNER_JOIN 要求，那么查看它左右孩子，如果也是 MULTI_INNER_JOIN，那么合并成一个更大的 MULTI_INNER_JOIN
```
![alt text](pic/003.png)

```sql
  PushDownJoinConditions(thd, root, companion_collection, &table_filters, // 把整个 expr->join_conditions 下推，递归 expr->left、expr->right 或者 expr->multi_children
                         &cycle_inducing_edges, trace);
```
该例子中所有 expr->join_conditions 都是 空数组，所以没变化
![alt text](pic/004.png)

```sql
查看 query_block->join->where_cond
-exec mysql Item graph->query_block()->join->where_cond
@startuml

map Item_0x7fff3ca6c238 #header:Gold;back:orange{
         __dynamic_type => Item_cond_and
         __print => (
            (
                  (multiple equal(1, `test`.`t1`.`b`) and multiple equal(2, `test`.`t2`.`b`)) 
               or (multiple equal(1, `test`.`t1`.`b`) and multiple equal(2, `test`.`t2`.`c`))
            ) 
            and (0 <> `test`.`t3`.`id`) 
            and multiple equal(1, `test`.`t1`.`a`, `test`.`t2`.`a`, `test`.`t3`.`a`) 
            and multiple equal(`test`.`t1`.`id`, `test`.`t3`.`id`, `test`.`t2`.`id`)
            )
}


Item *where_cond = EarlyExpandMultipleEquals(join->where_cond, // 在 join 下推前展开 multiple equalities，返回 AND conjunction。1、标量处理，2、常量处理（每个字段填充常量），3、涉及表个数大于2的处理（提取公共表），4、涉及表个数等于2的处理（获取 Item_func_eq）

-exec mysql Item where_cond
@startuml

map Item_0x7fff3ca6c238 #header:Gold;back:orange{
         __dynamic_type => Item_cond_and
         __print => (
            (
                  ((`test`.`t1`.`b` = 1) and (`test`.`t2`.`b` = 2)) 
               or ((`test`.`t1`.`b` = 1) and (`test`.`t2`.`c` = 2))
            ) 
            and (0 <> `test`.`t3`.`id`) 
            and ((`test`.`t1`.`a` = 1) and (`test`.`t2`.`a` = 1) and (`test`.`t3`.`a` = 1)) 
            and multiple equal(`test`.`t1`.`id`, `test`.`t3`.`id`, `test`.`t2`.`id`)
            )
}
@enduml
1、标量处理   无
2、常量处理   可以看到已经 and ((`test`.`t1`.`a` = 1) and (`test`.`t2`.`a` = 1) and (`test`.`t3`.`a` = 1))  这里是从常量填充 multiple equal(1, `test`.`t1`.`a`, `test`.`t2`.`a`, `test`.`t3`.`a`)  转换过来的
3、涉及表个数大于2的处理（提取公共表） 无
4、涉及表个数等于2的处理（获取 Item_func_eq） 无



    if (ExtractConditions(where_cond, &where_conditions)) { // 递归遍历 condition 中的每个一 AND 项目，然后存放到 condition_parts 数组中
      return true;
    }
-exec mysql Mem_root_array where_conditions

```
![alt text](pic/005.png)
```sh
    if (EarlyNormalizeConditions(thd, /*join=*/nullptr, &where_conditions,  // 总体思想是：消除多余的过滤条件
                                 where_is_always_false)) {
```
![alt text](pic/006.png)
可以看到or中的公共表达式被消除：   (`test`.`t1`.`b` = 1) and ((`test`.`t2`.`b` = 2) or (`test`.`t2`.`c` = 2))

    where_conditions = PushDownAsMuchAsPossible(   // 遍历 conditions 数组，尽可能地把迭代器下推
        thd, std::move(where_conditions), root,
        /*is_join_condition_for_expr=*/false, companion_collection,
        &table_filters, &cycle_inducing_edges, trace);

查看 where_conditions 变化，发现少了 multiple equal
-exec mysql Mem_root_array where_conditions
![alt text](pic/007.png)
查看 root 变化
-exec mysql RelationalExpression root
![alt text](pic/008.png) 
发现刚才少了的条件，被下推到了 INNSER JOIN 中

    UnflattenInnerJoins(root);  // 把 RelationalExpression 展开成 右深二叉树
没发现 root 变化

    if (CanonicalizeConditions(thd, GetVisibleTables(root), // 规范化 Conditions：把 (A.x, B.x, D.x, E.x)、allowed_tables={A,B,C,D} 转换成  A.x = B.x and B.x = D.x (E.x is ignored). 然后重新拆分 conditions 成新的数组，比如前面的例子拆成 A.x = B.x 和 B.x = D.x
                               TablesBetween(0, MAX_TABLES),
                               &where_conditions)) {
没发现 root、where_conditions 变化

  LateConcretizeMultipleEqualities(thd, root); // 从 MultipleEqualities 找到一条边连接 expr->left、expr->right
没发现 root 变化

  PushDownJoinConditionsForSargable(thd, root); // 遍历  expr->join_conditions，尝试下推条件（类似 PushDownCondition()）放到 expr->join_conditions_pushable_to_this。然后递归 expr->left、expr->right
-exec mysql RelationalExpression root
![alt text](pic/009.png)
发现 RelationalExpression 中的 join_conditions 被下推到叶子节点的 TABLE 上

  if (CanonicalizeJoinConditions(thd, root)) { // 规范化 JoinConditions：先规范化 expr->join_conditions，然后遍历 expr->join_conditions，不处理里面的子查询、标量。最后递归规范化 expr->left 和 expr->right
没发现 root 变化

  FindConditionsUsedTables(thd, root); // 对 expr->conditions_used_tables 赋值，然后递归
-exec mysql RelationalExpression root
![alt text]((pic/010.png)
INNER_JOIN 的 conditions_used_tables 被赋值

  MakeHashJoinConditions(thd, root); // 在 expr->join_conditions 中查找符合 hash join 条件的 item，然后添加到 expr->equijoin_conditions 中，接着在 expr->join_conditions 中删除
-exec mysql RelationalExpression root
![alt text](pic/011.png)
发现 INNER_JOIN 中的 join_conditions 被移动到 join_conditions

  ForEachOperator(root, [&](RelationalExpression *expr) {  // 遍历 RelationalExpression 的 expr->left、expr->right 。然后LAMBDA函数中 遍历 expr->join_conditions_pushable_to_this 、expr->equijoin_conditions，更新 expr->companion_set
-exec mysql RelationalExpression root
![alt text](pic/012.png)
发现 companion_set 中的内容发现了变化

  MakeJoinGraphFromRelationalExpression(thd, root, trace, graph);  // 1、如果 RelationalExpression 是表，则更新 JoinHypergraph 的 graph、nodes、table_num_to_node_num，然后更新 RelationalExpression 的 nodes_in_subtree，然后返回    // 2、如果不是表，则递归处理它的 left 和 right，然后更新它的 nodes_in_subtree、给 expr->conflict_rules 计算并赋值、graph->graph 添加新的边、计算 expr 的 selectivity，最后构建新的 JoinPredicate 放入 graph->edges
执行之前
![alt text](pic/013.png)
执行之后
![alt text](pic/014.png)
细看 root 变化 
![alt text](pic/015.png)

  ClearImpossibleJoinConditions(root);  // 遍历 expr->equijoin_conditions，如果发现它涉及的表只返回零行或者只返回 NULL 行，那么清空 expr->equijoin_conditions。继续递归 expr->left 和 expr->right
没发现变化

  graph->tables_inner_to_outer_or_anti =
      GetTablesInnerToOuterJoinOrAntiJoin(root);  // 获取 expr 的 LEFT_JOIN 或者 ANTIJOIN 的内表
没发现变化

  if (!cycle_inducing_edges.empty()) {
    AddCycleEdges(thd, cycle_inducing_edges, companion_collection, graph, // 遍历 cycle_inducing_edges 中的 Item，如果在 JoinHypergraph 的 edges 没找到对应的边，则构建新的 JoinPredicate 并添加到 JoinHypergraph 的 edges。如果找到对应的边，则更新它的 selectivity。 最后 JoinHypergraph 的对应 nodes 的 join_conditions_pushable_to_this 添加 cond，形成回环。
                  trace);
  }
此时 cycle_inducing_edges 为空，所以没变化

  ExtractCycleMultipleEqualitiesFromJoinConditions(root, companion_collection,  // 遍历 expr->equijoin_conditions，如果迭代器 source_multiple_equality 不为空，且它满足全连接，则把 迭代器的 source_multiple_equality 放入  multiple_equalities 数组
                                                   &multiple_equalities);
multiple_equalities 中的两个元素重复
@startuml

map Item_0x7fff3ca6caa0 #header:Gold;back:orange{
         __dynamic_type => Item_equal
         __print => multiple equal(`test`.`t1`.`id`, `test`.`t3`.`id`, `test`.`t2`.`id`)
}

map Mem_root_array_Item_0x7fffcc161750 #header:Gold;back:Tomato {
         0x7fff3ca6caa0 => Item_equal *
         0x7fff3ca6caa0 => Item_equal *
}

Mem_root_array_Item_0x7fffcc161750::0x7fff3ca6caa0 -[#Tomato]-> Item_0x7fff3ca6caa0 : 0x7fff3ca6caa0
Mem_root_array_Item_0x7fffcc161750::0x7fff3ca6caa0 -[#Tomato]-> Item_0x7fff3ca6caa0 : 0x7fff3ca6caa0

@enduml


  ExtractCycleMultipleEqualities(where_conditions, companion_collection,  // 遍历 conditions 数组，如果是 = 等式，且迭代器的 source_multiple_equality 是全连接，则把该 source_multiple_equality 放进 multiple_equalities 数组
                                 &multiple_equalities);
此时 where_conditions 中的元素的 source_multiple_equality 为空，所以 multiple_equalities 没变化

if (multiple_equalities.size() > 64) {  // multiple_equalities 不能超过 64 个元素
    multiple_equalities.resize(64);
  }
  std::sort(multiple_equalities.begin(), multiple_equalities.end());
  multiple_equalities.erase(
      std::unique(multiple_equalities.begin(), multiple_equalities.end()),
      multiple_equalities.end());
multiple_equalities 去重 
@startuml

map Item_0x7fff3ca6caa0 #header:Gold;back:orange{
         __dynamic_type => Item_equal
         __print => multiple equal(`test`.`t1`.`id`, `test`.`t3`.`id`, `test`.`t2`.`id`)
}

map Mem_root_array_Item_0x7fffcc161750 #header:Gold;back:Tomato {
         0x7fff3ca6caa0 => Item_equal *
}

Mem_root_array_Item_0x7fffcc161750::0x7fff3ca6caa0 -[#Tomato]-> Item_0x7fff3ca6caa0 : 0x7fff3ca6caa0

@enduml

  CompleteFullMeshForMultipleEqualities(thd, multiple_equalities, // 遍历 multiple_equalities 数组，对其中的每个元素的 multiple equality 全连接的关系，执行 AddMultipleEqualityPredicate
                                        companion_collection, graph, trace);  // AddMultipleEqualityPredicate 功能：1、如果 right_node_idx 和 left_node_idx 在超图中是否已经存在边，则查找对应的 RelationalExpression，查看 join_conditions、equijoin_conditions，检查是否有 Item_eq_base 属于 Item_equal，如果有则返回，如果没就重新计算 对应的 graph->edges 的 selectivity  2、如果 right_node_idx 和 left_node_idx 在超图中不存在对应的边，则构建新的 JoinPredicate 放入 graph->edges  3、最后构建新的 Item_func_eq，然后放入 expr->equijoin_conditions 对应的 graph->nodes 的 join_conditions_pushable_to_this

变化之前
-exec mysql Hypergraph graph->graph
![alt text](pic/016.png)
变化之后
-exec mysql Hypergraph graph->graph
![alt text](pic/017.png)
发现 edges 中添加了两条边

变化之前
![alt text](pic/018.png)
变化之后
![alt text](pic/019.png)
发现 JoinPredicate 添加了一个新元素，对应地多了个 RelationalExpressio，它是 INNER_JOIN


  if (graph->graph.edges.size() != old_graph_edges) {
    // We added at least one cycle-inducing edge.
    PromoteCycleJoinPredicates(thd, root, multiple_equalities, // 遍历 JoinHypergraph 的 edges，如果它有回环，则把 graph->edges[edge_idx / 2].expr 的 equijoin_conditions、join_conditions 添加到 JoinHypergraph 的 predicates
                               companion_collection, graph, trace);
  }
执行之前的 predicates 内容为空
执行之后，predicates 添加了 3 个元素，他们来自 multiple_equalities 的 Full Mesh 转换
-exec mysql Mem_root_array graph->predicates
![alt text](pic/020.png)

  for (Item *condition : where_conditions) {  // 遍历 where_conditions (来自 query_block->join->where_cond 的加工)
    AddPredicate(thd, condition, /*was_join_condition=*/false,  // 把这个函数的参数初始化 Predicate 谓词，然后把这个谓词加入 JoinHypergraph 的 predicates。计算它的 condition、used_nodes、total_eligibility_set、selectivity、was_join_condition、source_multiple_equality_idx、functional_dependencies_idx、contained_subqueries，然后放到 graph->predicates 中
                 /*source_multiple_equality_idx=*/-1, root,
                 &companion_collection, graph, trace);
  }
执行后
-exec mysql Mem_root_array graph->predicates
执行之后，predicates 添加了 6 个元素
![alt text](pic/021.png)

  // Table filters should be applied at the bottom, without extending the TES.
  for (Item *condition : table_filters) { // 把之前收集的 table_filters 加入 JoinHypergraph 的 predicates
    Predicate pred;
    pred.condition = condition;
    pred.used_nodes = pred.total_eligibility_set = GetNodeMapFromTableMap( // 根据 table_num 获取 node_num
        condition->used_tables() & ~(INNER_TABLE_BIT | OUTER_REF_TABLE_BIT),
        graph->table_num_to_node_num);
    assert(has_single_bit(pred.total_eligibility_set));
    pred.selectivity = EstimateSelectivity(
        thd, condition, *companion_collection.Find(condition->used_tables()),
        trace);
    pred.functional_dependencies_idx.init(thd->mem_root);
    graph->predicates.push_back(std::move(pred));
  }
因为 table_filters 内容为空，所以没变化

  SortPredicates(graph->predicates.begin() + num_cycle_predicates,
                 graph->predicates.end());

  graph->num_where_predicates = graph->predicates.size();

  return false;
}

最后的结果：
![alt text](pic/022.png)

返回到上层函数中
static AccessPath *FindBestQueryPlanInner(THD *thd, Query_block *query_block,
                                          bool *retry, int *subgraph_pair_limit,
                                          string *trace) {

  FindSargablePredicates(thd, trace, &graph); // 1、遍历 graph->nodes、遍历 node.join_conditions_pushable_to_this 2、如果 graph->predicates[i].condition 可以应用索引，则把它 放到 JoinHypergraph::Node->sargable_predicates
执行之前
-exec mysql Mem_root_array graph->nodes
![alt text](pic/023.png)
执行之后
-exec mysql Mem_root_array graph->nodes
![alt text](pic/024.png)
发现 JoinHypergraph::Node->sargable_predicates 中开始有内容

  CacheCostInfoForJoinConditions(thd, query_block, &graph, trace);  // 1、遍历 edge.expr->equijoin_conditions，构造 CachedPropertiesForPredicate，然后放进 edge.expr->properties_for_equijoin_conditions  2、遍历 edge.expr->join_conditions，构造 CachedPropertiesForPredicate，然后放进 edge.expr->properties_for_join_conditions
-exec mysql Mem_root_array graph->edges
![alt text](pic/025.png)
发现  INNER JOIN 类型的 graph->edges，它的 properties_for_equijoin_conditions 有新内容


# 结论
```
1、RelationalExpression 的 nodes_in_subtree、tables_in_subtree 不受 JOIN 类型（比如 SJ、AJ）的影响
2、子查询 和 a+b=c 都不会出现在 MULTI EQUAL 中
3、MULTI_INNER_JOIN 只会在 MakeJoinHypergraph 的中途产生，它是由 from t1,t2,t3 ... where 这种语法产生，如果没笛卡尔积则最终会被转换为 INNER_JOIN，笛卡尔积部分依然是 MULTI_INNER_JOIN。在 MakeJoinHypergraph 后，全是 INNER_JOIN。笛卡尔表跟其它表比较，少了 join_conditions_pushable_to_this，全部有 companion_set
```
![alt text](converted(1).png)

其它可以优化的地方：
```
1、 multi equal(t1.a, t2.a, t2.b, t3.a) 会被转换成 t2.a=t2.b AND (original multi equal)。这可以让我们后续把 t2.a=t2.b 下推。 实现函数是 ExpandSameTableFromMultipleEquals
    如果是 t1.id, t1.a, t1.b ，它只会被转换成  t1.id = t1.a 和 t1.a = t1.b，其中 t1.id = t1.b 会被 break



where t1.a=1 and t2.a=t1.a and t3.a=t1.a # 常量替换
      and ((t1.b = 1 and t2.b=2) or (t1.b=1 and t2.c=2)) # 公共子表达式消除后是 (t1.b = 1 and ( t2.b= 2 or t2.c=2))
      and t3.id # 标量处理
       and t1.d=t2.d and t1.d=t3.d and t1.c=t2.d;

EarlyExpandMultipleEquals 之前
(
  (
    (
      multiple equal(1, `test`.`t1`.`b`) 
      and multiple equal(2, `test`.`t2`.`b`)
    ) 
    or 
    (
      multiple equal(1, `test`.`t1`.`b`) 
      and multiple equal(2, `test`.`t2`.`c`)
    )
  ) 
  and (0 <> `test`.`t3`.`id`) 
  and multiple equal(1, `test`.`t1`.`a`, `test`.`t2`.`a`, `test`.`t3`.`a`) 
  and multiple equal(`test`.`t1`.`d`, `test`.`t2`.`d`, `test`.`t3`.`d`, `test`.`t1`.`c`) 
  and multiple equal(`test`.`t1`.`id`, `test`.`t3`.`id`, `test`.`t2`.`id`)
)

EarlyExpandMultipleEquals 之后
(
  (
    (
      (`test`.`t1`.`b` = 1) 
      and (`test`.`t2`.`b` = 2)
    ) 
    or 
    (
      (`test`.`t1`.`b` = 1) 
      and (`test`.`t2`.`c` = 2)
    )
  ) 
  and (0 <> `test`.`t3`.`id`) 
  and (
        (`test`.`t1`.`a` = 1) 
        and (`test`.`t2`.`a` = 1) 
        and (`test`.`t3`.`a` = 1)
      )
  and (
        (`test`.`t1`.`d` = `test`.`t1`.`c`) 
        and multiple equal(`test`.`t1`.`d`, `test`.`t2`.`d`, `test`.`t3`.`d`, `test`.`t1`.`c`)
      ) 
  and multiple equal(`test`.`t1`.`id`, `test`.`t3`.`id`, `test`.`t2`.`id`)
)
```
```cpp
Query_block::prepare 流程
1、 处理 VALUES row_list 类型的 Query_block，然后直接返回
2、 设置 nullability。  // 比如 left join t1 on ...，则设置 t1 nullability
3、 设置 allow_merge_derived
    它表示是否合并派生表，合并派生表的规则是：
    - 属于最外层 Query_block 的DTs：始终合并。判断是否最外层的方法是： master->master == nullptr
         例子 SELECT * FROM (SELECT * FROM table1) AS derived_table;  这里的 derived_table 允许被合并
    - 属于第一级子查询的DTs：则合并，
         例子 SELECT * FROM table1 WHERE id IN (SELECT id FROM (SELECT * FROM table2) AS derived_table);  这里子查询的 derived_table 允许被合并
    - 所有其他情况继承父 Query_block 的状态，要求 SQL 类型是 SELECT 或者 SET
4、 如果 thd 没有正在处理派生表，或者 master 的子查询不为 nullptr，则设置临时变量 check_privs 为 true
5、 thd->mark_used_columns = check_privs ? MARK_COLUMNS_READ : MARK_COLUMNS_NONE;
6、 保存 thd->want_privilege，然后设置 thd->want_privilege = check_privs ? SELECT_ACL : 0;
7、 执行 Query_block::setup_tables(THD *thd, Table_ref *tables, bool select_insert) ，它会检查所有表、字段、条件、排序是否合法
         7.1 遍历 m_table_list，存放到 leaf_tables 中
         7.2 遍历 leaf_tables (更新 Table_ref 的 tableno（从 0 开始递增）、table 的 索引使用情况、partitioned_table_count)
8、 处理 Query_block 中的派生表、试图、表函数
         8.1 遍历 m_table_list
             只处理 派生表、试图、表函数
             如果已经被合并过或者使用物化，则 continue
             处理该 Table_ref 的派生表生成
             合并不需要物化的派生表，整个THD的生命周期，只处理一次该合并工作
             合并派生表或者试图到本 Query_block，如果有约束导致无法合并，则在后续的工作中物化它
             为物化 table function 做预处理
             为物化 不可合并的派生表、视图 做预处理
9、 检查视图的权限
10、如果 leaf_table_count >= 2，则填充 natural join 的字段
11、初始化 Mem_root_array<Item_exists_subselect *> sj_candidates 为空
12、安装 join conditions 和 WHERE clause 语句
         12.1 查看 WHERE 条件是否可以简化为 Item_func_true 或 Item_func_false
         12.2 遍历 mem_root_deque<Table_ref *> m_table_nest，循环变量为 tr
              如果 tr->nested_join != nullptr 则递归执行 setup_join_cond(thd, &tr->nested_join->m_tables, in_update)
              join 条件在 Table_ref 的 m_join_cond 变量中
              如果 join 条件是常量，则简化它为 Item_func_true 或 Item_func_false
13、安装 GROUP BY 语句
         13.1 如果 group_list.elements 不为 0 则检查 GROUP BY 语法是否合法
              下面这个函数是 ORDER BY 或 GROUP BY 子句中的列引用解析
              find_order_in_list(THD *thd, Ref_item_array ref_item_array, Table_ref *tables, ORDER *order, mem_root_deque<Item *> *fields, bool is_group_field, bool is_window_order)
              比如 GROUP BY 的列表中有聚合函数、窗口函数、或者嵌套 group by，这些都是不合法的
14、安装 HAVING 语句
         比如处理 rollup，简化 having 条件，简化窗口函数中的条件 m_qualify_cond
15、处理 ORDER BY 语句
         修改 ORDER BY 列表中的 item 指向 select list
         如果 ORDER BY 的不是数字，且不在 select list 中，则把它添加到 field list
16、rollup 字段不能是全文检索字段
17、安装 OFFSET 和 LIMIT 语句
19、子查询不支持 LIMIT ,所以会移除它的 ORDER BY、DISTINCT，如果没　aggregate functions　则会移除　GROUP BY 子句
20、Query_block 此时已经完全 resolved，再次处理 ORDER BY 语句
         检查 ORDER BY 语句是否有冗余
         拆分聚合函数
21、检查 DISTINCT 语句是否可以被消除
22、把标量子查询转换为 join 派生表
         比如 SELECT (SELECT COUNT(a) FROM t2) + a FROM t1; # 子查询在 join 外部
         -->  SELECT derived.cnt + t1.a FROM t1 LEFT OUTER JOIN  (select COUNT(a) AS cnt FROM t2) AS derived ON TRUE;
         比如 SELECT * FROM t1 LEFT JOIN  t2 ON (SELECT COUNT(a) AS cnt FROM t2) = t1.a; # 子查询在 join 内部
         -->  SELECT * FROM t1 LEFT JOIN (SELECT COUNT(t2.a) AS cnt FROM t2) derived_1_0 ON(TRUE) LEFT JOIN t2 ON derived_1_0.cnt = t1.a
         不能转换：子查询跟 HAVING 条件相关
         比如 SELECT SUM(a), (SELECT SUM(b) FROM t3) scalar FROM t1 HAVING SUM(a) > scalar;
         比如 SELECT MAX(a) FROM t1 WHERE FALSE HAVING (SELECT MIN(a) FROM t1) > 0;
         TODO：
         不能转换的例子1中，其它它可以转换成
         SELECT derived0.summ, derived1.scalar FROM (SELECT SUM(a) AS summ FROM t1) AS derived0 LEFT JOIN (SELECT SUM(b) AS scalar FROM t3) AS derived1 ON TRUE WHERE derived0.sum > derived1.scalar;
23、处理 If GROUPING function is present in having condition （没细看）
24、处理完 HAVING 语句后，处理 full-text 函数
25、设置 Query_block::m_query_result->unit = unit
26、展开可以转换为 semic join 的子查询
         比如把 SELECT ... FROM ot, ...  WHERE oe IN (SELECT ie FROM it1 ... itN WHERE subq_where) AND outer_where
              转换为 SELECT ... FROM ot SEMI JOIN (it1 ... itN), ... WHERE outer_where AND subq_where AND oe=ie
27、如果是最外层 Query_block，或者 
         (
            (parent_lex->sql_command == SQLCOM_SET_OPTION || parent_lex->sql_command == SQLCOM_END || parent_lex->sql_command == SQLCOM_LOAD) 
            && outer_query_block()->outer_query_block() == nullptr
         )
    则执行函数 apply_local_transforms(thd, true)，它只适用以下场景
      1、如果这不是创建视图的语句，因为在创建视图时不需要进行转换。
      2、如果这是 SELECT 或多表 UPDATE/DELETE 语句的最外层查询块。注意，对于 UNION，这适用于所有查询块。它也适用于 fake_query_block 对象。
      3、如果这是最高级别的子查询之一，如果语句是其他内容；比如在 UPDATE t1 SET col1=(subq-1), col2=(subq-2); 中的 subq-i。
      4、如果这是 SET 命令中的子查询，或者用于 SP 表达式（如 sp_instr_freturn）中的标量子查询（由 SQLCOM_END 指示）。
      5、如果这是 LOAD 命令中的子查询。
      6、INSERT 在某些情况下可能会通过在调用 prepare() 之前设置 skip_local_transforms 标志来改变准备调用的顺序。

      在查询块合并之后应用本地转换。这意味着我们避免了不必要的调用，因为本地转换否则会在查询块合并之前首先执行，然后在查询块合并之后再执行一次。因此，apply_local_transforms() 可能只在顶级查询完成查询块合并后运行。
      这就是为什么 apply_local_transforms() 只由顶级查询启动，然后递归到子查询。

    函数 apply_local_transforms(thd, true) 的功能是：
      1、删除派生表中多余的字段
      2、子查询内部 Query_block 执行本地转换
      3、如果条件允许，则把 outer join 转换为 inner join。去掉 join 语句中多余的括号，检查 join 谓词是否合法
      4、更新 Table_ref 的 outer_join、sj_inner_tables、sj_nests
      5、分区表裁剪
      6、把一些条件下推给派生表，这有助于派生表内部可以把LEFT JOIN 转换为 INNSER JOIN
28、消除未使用的窗口定义，冗余的排序等
29、在窗口函数内部把 group by 字段的引用替换为 ROLLUP 的引用
30、如果有 CUBE，则把有 GROUP BY 的表达式需要标记依赖 grouping set
      CUBE 的 SQL : SELECT Item, Color, SUM(Quantity) AS QtySum FROM Inventory GROUP BY Item, Color WITH CUBE;


Query_block::optimize(THD *thd, bool finalize_access_paths) 流程
1、join = new (thd->mem_root) JOIN(thd, this)
2、执行 join->optimize(finalize_access_paths)
3、遍历 Query_block 下面所有的 Query_expression query_expression，
         执行 query_expression->optimize(thd, /*materialize_destination=*/nullptr, /*create_iterators=*/false, /*finalize_access_paths=*/true)


Query_expression::prepare 流程
1、在 Sql_cmd_select::prepare_inner 执行过程中，如果 Query_expression 不是简单查询（多个 Query_block）,才会进入该流程 unit->prepare(thd, result, nullptr, SELECT_NO_UNLOCK, 0)
2、设置 m_query_result 为参数中的 result
3、设置 thd->lex->m_current_query_block 为 first_query_block()
4、如果 Query_expression 不是简单查询（多个 Query_block），设置 m_query_term->m_is_materialized
5、设置 first_query_block()->context.resolve_in_select_list = true
6、遍历 Query_expression 下面所有的 Query_block sl
         6.1 如果  Query_expression 是简单查询，则设置 sl->m_query_result
         6.2 sl->make_active_options(added_options | SELECT_NO_UNLOCK, removed_options)
         6.3 thd->lex->set_current_query_block(sl)
         6.4 处理递归查询的 SQL 信息
         6.5 执行 sl->prepare(thd, insert_field_list)
         6.6 如果不是  QT_UNION || type == QT_INTERSECT || type == QT_EXCEPT， 
                  则把 first_query_block()->visible_fields() 的所有字段 push_back  到 Query_expression 中的 mem_root_deque<Item *> types
             否则，如果 sl == first_query_block()
                  则把 first_query_block()->visible_fields() 的所有字段 push_back  到 Query_expression 中的 mem_root_deque<Item *> types，这里会有些其它特殊处理，比如递归查询的 SQL
             否则，继续处理字段
7、如果是递归查询的 SQL 则执行 check_materialized_derived_query_blocks(thd)
8、如果不是 simple_query_expression 则执行 
         Query_expression::prepare_query_term(thd, query_term(), /*common_result*/ nullptr, added_options, create_options, /*level*/ 0, nullable)
         它涉及如何准备查询项节点，设置后处理查询块，以及创建临时表
9、设置 prepared = true



Query_expression::optimize(THD *thd, TABLE *materialize_destination, bool create_iterators, bool finalize_access_paths)  流程
1、 Sql_cmd_dml::execute_inner(THD *thd) 调用的是 
         unit->optimize(thd, /*materialize_destination=*/nullptr, /*create_iterators=*/true, /*finalize_access_paths=*/true)
2、 设置临时变量 estimated_rowcount = 0   estimated_cost = 0.0
3、 设置 m_query_result->estimated_rowcount = 0
4、 遍历 Query_expression 下面所有的 Query_block query_block，
          4.1 设置 thd->lex->m_current_query_block = query_block
          4.2 设置 Query_expression 的 offset_limit_cnt 和 select_limit_cnt
          4.3 执行 query_block->optimize(thd, finalize_access_paths)
          4.4 累计评估的行数
                 对于 INTERSECT 或 EXCEPT，只需要考虑左侧查询的行数
                 estimated_rowcount += query_block->join->best_rowcount
                 estimated_cost += query_block->join->best_read
                 m_query_result->estimated_rowcount = estimated_rowcount
                 m_query_result->estimated_cost = estimated_cost
5、 如果不是简单查询（比如 UNION、INTERSECT、EXCEPT），则执行 m_query_term->open_result_tables(thd, 0) 创建结果临时表
6、 如果不是简单查询，则执行
          6.1 optimize_set_operand(thd, this, query_term())
              6.1.1 根据 Query_term 设置 Query_expression 的 LIMIT  
              6.1.2 如果是 (...) ORDER BY ... LIMIT ... 这种类型的 SQL，或者已经物化，则执行 m_query_block->optimize(thd, /*finalize_access_paths=*/true)。
                    因为没有 ORDER BY ... LIMIT ... 的话，我们可以折叠它
              6.1.3 遍历 Query_term_set_op 的 m_children，递归执行 optimize_set_operand
          6.2 set_limit(thd, query_term()->query_block())
              设置  Query_expression 的 offset_limit_cnt、select_limit_cnt
          6.3 如果不是 union 则执行 query_result()->set_limit(select_limit_cnt)
7、 设置 m_query_result->estimated_rowcount = estimated_rowcount    m_query_result->estimated_cost = estimated_cost
8、 如果  estimated_rowcount <= 1 || use_iterator(materialize_destination, query_term()) 则执行 create_access_paths(thd)
        如果 materialize_destination != nullptr && can_materialize_directly_into_result() 
                   则执行 m_operands = set_operation()->setup_materialize_set_op( thd, materialize_destination, /*union_distinct_only=*/false, calc_found_rows)
            其它情况执行 create_access_paths(thd)
9、 设置 optimized = true
10、如果 item != nullptr，即有子查询的意思，则执行 item->create_iterators(thd)
11、如果 create_iterators && IteratorsAreNeeded(thd, m_root_access_path)，则执行
        JOIN *join = query_term()->query_block()->join;
        执行 m_root_iterator = CreateIteratorFromAccessPath(thd, m_root_access_path, join, /*eligible_for_batch_mode=*/true)
        如果开启 hypergraph_optimizer，且完成所有的全文搜索函数，则返回 true
12、如果是最外层的 Query_expression，且 EstimateRowAccesses(m_root_access_path, /*num_evaluations=*/1.0, std::numeric_limits<double>::infinity()) > static_cast<double>(thd->variables.max_join_size))，则返回 true
13、返回 false


JOIN::optimize(bool finalize_access_paths) 流程
1、 执行函数 count_field_types(query_block, &tmp_table_param, *fields, false, false) 为临时表创建字段
2、 如果有窗口函数则执行 Window::setup_windows2(thd, &m_windows)
3、 为提升 sum_func 的计算效率，创建 sum_functions 数组
4、 执行函数 query_block->get_optimizable_conditions(thd, &where_cond, &having_cond)
           4.1 把 query_block->m_where_cond 拷贝到 JOIN::where_cond
           4.2 把 query_block->m_having_cond 拷贝到 JOIN::having_cond
           4.3 执行函数 get_optimizable_join_conditions(thd, /*mem_root_deque<Table_ref *> &*/m_table_nest)
                  4.3.1 遍历  query_block->m_table_nest table
                              NESTED_JOIN *const nested_join = table->nested_join
                              执行函数 get_optimizable_join_conditions(thd, nested_join->m_tables)
                              如果是正常SQL语句（非 prepared 语句、非存储过程语句），则把 table->m_join_cond 拷贝到 table->m_join_cond_optim
                                  否则把 table->m_join_cond 赋值给 table->m_join_cond_optim
5、 遍历 query_block->rollup_group_items item 然后 JOIN::rollup_group_items.push_back(item)
6、 遍历 query_block->rollup_sums item 然后 JOIN::rollup_sums.push_back(item)
7、 设置 optimized = true
8、 设置 tables_list = query_block->leaf_tables
9、 为 ref_items、tmp_fields 分配内存
10、设置 ref_items[REF_SLICE_ACTIVE] = query_block->base_ref_items
11、遍历  query_block->leaf_tables tl
           tl->access_path_for_derived = nullptr
           如果 tl 是视图或者派生表，则执行 tl->optimize_derived(thd)，然后返回
           如果 t1 是表函数，则执行 setup_tmp_table_handler(thd, table, query_block->active_options() | TMP_TABLE_ALL_COLUMNS)
                              设置 table->file->stats.records = 2
12、如果开启 hypergraph_optimizer，
           遍历 query_block 下面的 Query_expression unit
                  如果 unit 没执行过 optimize，则执行 unit->optimize(thd, /*materialize_destination=*/nullptr, /*create_iterators=*/false, /*finalize_access_paths=*/false)           
           执行 query_block->add_active_options(OPTION_NO_CONST_TABLES | OPTION_NO_SUBQUERY_DURING_OPTIMIZATION)
                  因为 hypergraph optimizer 不会处理常量表也不会处理子查询
13、设置 has_lateral = false
14、设置 row_limit = ((select_distinct || !order.empty() || !group_list.empty()) ? HA_POS_ERROR : query_expression()->select_limit_cnt)
15、设置 m_select_limit = query_expression()->select_limit_cnt
16、如果是最外层的 Query_block 则设置 calc_found_rows = m_select_limit != HA_POS_ERROR && (!query_expression()->is_set_operation() || query_block == set_operand_block)
17、如果 query_expression()->select_limit_cnt == 0 && !calc_found_rows 则执行函数 set_root_access_path(create_access_paths_for_zero_rows())，然后 goto setup_subq_exit
18、如果 where_cond || query_block->outer_join
           18.1 执行 optimize_cond(thd, /*Item **cond*/&where_cond, /*COND_EQUAL **cond_equal*/&cond_equal, /*mem_root_deque<Table_ref *> *join_list*/&query_block->m_table_nest, 
                                           /*Item::cond_result *cond_value*/&query_block->cond_value)
                     18.1.1 构建 multiple equality predicates
                     18.1.2 执行常量替换字段
                     18.1.3 如果条件结果永远是 true 或者 false，则删除条件
                     18.1.4 删除所有的 item == item 条件 和  and-levels where CONST item != CONST item 条件
                     如果 join_list 则执行 
                        build_equal_items(thd, /*Item *cond*/*cond, /* Item **retcond*/cond, /*COND_EQUAL *inherited*/nullptr, /*bool do_inherit*/true, 
                                           /*mem_root_deque<Table_ref *> *join_list*/join_list, /*COND_EQUAL **cond_equal_ref*/cond_equal)
                                           1、执行函数 build_equal_items_for_cond(thd, cond, &cond, inherited, do_inherit) 构建多重相等性
                                           2、执行函数 cond->update_used_tables()
                                           3、
           18.2 如果  query_block->cond_value == Item::COND_FALSE 则执行  set_root_access_path(create_access_paths_for_zero_rows()，然后 goto setup_subq_exit
19、如果 having_cond
           19.1 执行 optimize_cond(thd, /*Item **cond*/&having_cond, /*COND_EQUAL **cond_equal*/&cond_equal, /*mem_root_deque<Table_ref *> *join_list*/nullptr,  /*Item::cond_result *cond_value*/&query_block->having_value)
                     19.1.1 构建 multiple equality predicates
                     19.1.2 执行常量替换字段
                     19.1.3 如果条件结果永远是 true 或者 false，则删除条件
                     19.1.4 删除所有的 item == item 条件 和  and-levels where CONST item != CONST item 条件
           19.2 如果  query_block->having_value == Item::COND_FALSE 则执行  set_root_access_path(create_access_paths_for_zero_rows()，然后 goto setup_subq_exit
20、执行函数 prune_table_partitions() 进行分区表裁剪
21、把 count(*), min() 和 max() 优化成常量字段
21、如果开启 hypergraph_optimizer 且 query_block->is_table_value_constructor，啥都不做
        否则如果 tables_list == nullptr 
                执行 make_tmp_tables_info()
                执行 count_field_types(query_block, &tmp_table_param, *fields, false, false)
                执行 set_plan_state(NO_TABLES)
                执行 create_access_paths()
                返回
22、初始化窗口函数相关的数据成员
23、如果没开启 hypergraph_optimizer 则设置 sort_by_table = get_sort_by_table(order.order, group_list.order, query_block->leaf_tables)
24、如果 (where_cond || !group_list.empty() || !order.empty()) && substitute_gc(thd, query_block, where_cond, group_list.order, order.order) 
        则执行函数 count_field_types(query_block, &tmp_table_param, query_block->fields, false, false)
            其中函数 substitute_gc 的作用是：将 WHERE 条件和 ORDER/GROUP 列表中的所有表达式替换为 generated columns (GC)  字段
25、如果开启 hypergraph_optimizer
           25.1 执行 remove_in2exists_conds(where_cond) 把 where_cond 中的 IN-to-EXISTS 条件项等价转换
           25.2 执行 remove_in2exists_conds(having_cond) 把 having_cond 中的 IN-to-EXISTS 条件等价转换
           25.3 执行 SaveCondEqualLists(/*COND_EQUAL **/cond_equal)
                      List<Item_equal> copy
                      遍历 cond_equal->current_level) item，然后执行 copy.push_back(&item)
                            因为超图优化器可以修改 Item_cond 中的列表（通过调用 compile()），导致 Item_equal 被替换为 Item_func_eq，并且这可能导致 List<Item_equal> 不再包含 Item_equal 指针。
                            由于解开这个混乱似乎非常困难，我们通过暴力解决：复制所有的 COND_EQUAL 列表，这样它们就不再进入 Item_cond。这允许我们随意修改 Item_cond。
                      设置 cond_equal->current_level = std::move(copy)
                      递归执行 SaveCondEqualLists(cond_equal->upper_levels)
           25.4 执行 m_root_access_path = FindBestQueryPlan(thd, query_block, trace_ptr)
           25.5 执行 FinalizePlanForQueryBlock(thd, query_block) 结束查询计划
           25.6 如果 where_cond != where_cond_no_in2exists || having_cond != having_cond_no_in2exists 则
                      设置 where_cond = where_cond_no_in2exists、having_cond != having_cond_no_in2exists
                      执行 m_root_access_path_no_in2exists = FindBestQueryPlan(thd, query_block, trace_ptr)
                否则设置 m_root_access_path_no_in2exists = nullptr
           25.7 设置 set_plan_state(PLAN_READY)


Item_func_eq 转 Item_equal 流程：
1、入口是函数 build_equal_items_for_cond(THD *thd, Item *cond, Item **retcond, COND_EQUAL *inherited, bool do_inherit)，它会把条件中的所有等式转换为多重等式
2、定义临时变量 Item_equal *item_equal;  COND_EQUAL cond_equal;  设置 cond_equal.upper_levels = inherited
3、如果 cond->type() == Item::FUNC_ITEM （即不是 AND 或 OR 条件）
           3.1 定义临时变量 List<Item> eq_list 和 bool equality。（独立等式的概念：等式谓词形成了整个 AND 级别）
           3.2 执行函数 check_equality(thd, cond, &cond_equal, &eq_list, &equality)
                     3.2.1 此函数检查项是否是简单等式，即将字段与另一个字段或常量（field=field_item 或 field=constant_item）相等的项，或者是行相等性
                     3.2.2 对于简单等式，该函数查找通过 cond_equal 直接或间接引用的列表中的多重等式，推断给定的简单等式。如果找不到任何等式，则构建/扩展多重等式以覆盖谓词
                     3.2.3 行相等性被消除，替换为作为原始等式谓词的连词规则，以与原始等式谓词相同的方式处理
                     3.3.3 注意点：如果等式是由 IN->EXISTS 创建的，则可能稍后会被子查询实现删除。因此，我们不将此可能是临时性等式与其他等式混合; 如果让它进入多重等式（Item_equal）中，那么我们以后就无法删除它。
                                  然而，有一个例外：如果外部表达式是常量，则安全地将等式留在物化表中；它所能做的就是阻止 NULL/FALSE 区分，但如果这种区分很重要，则等式将在触发条件中，所以我们不会来到这个函数。
                                  并且注入常量是好的，因为它使物化的表更小。
                     check_equality(THD *thd, Item *item, COND_EQUAL *cond_equal, List<Item> *eq_list, bool *equality) 的流程：
                            1、设置 *equality = false，创建临时变量 Item_func *item_func
                            2、如果是普通等式 item->type() == Item::FUNC_ITEM && (item_func = down_cast<Item_func *>(item))->functype() == Item_func::EQ_FUNC
                                  设置临时变量 Item *left_item = item_func->arguments()[0]，Item *right_item = item_func->arguments()[1]
                                  如果 item->created_by_in2exists() && !left_item->const_item() 则返回
                                  如果是 ROW 等式 left_item->type() == Item::ROW_ITEM && right_item->type() == Item::ROW_ITEM
                                            设置 thd->lex->current_query_block()->cond_count--
                                            执行函数 check_row_equality(thd, down_cast<Item_row *>(left_item), down_cast<Item_row *>(right_item), cond_equal, eq_list, equality)，返回
                                  如果是非 ROW 等式，则执行函数 check_simple_equality(thd, left_item, right_item, item, cond_equal, equality)，返回
                                            check_simple_equality(THD *thd, Item *left_item, Item *right_item, Item *item, COND_EQUAL *cond_equal, bool *simple_equality) 流程
                                                  1、设置 *simple_equality = false
                                                  2、如果 left_item 是视图引用(@视图字段)
                                                        如果是外连接的引用则返回成功，否则设置 left_item = left_item->real_item()
                                                  3、同样处理 right_item
                                                  4、定义临时变量 const Item_field *left_item_field, *right_item_field
                                                  6、如果 left_item 和 right_item 的关系是 字段=字段，且这两个字段都没 depended from 别的 query_block
                                                        6.1 把 Item 转换成 Item_field。设置 left_item_field = down_cast<const Item_field *>(left_item)，right_item_field = down_cast<const Item_field *>(right_item)
                                                        6.2 获取 Field。定义临时变量 const Field *const left_field = left_item_field->field，right_field = right_item_field->field
                                                        6.3 如果等式左右两边的数据类型不一致，则返回 false
                                                        6.4 创建临时变量 bool left_copyfl, right_copyfl
                                                        6.5 搜索包含 left_item_field 的多重等式 Item_equal *left_item_equal = find_item_equal(cond_equal, left_item_field, &left_copyfl)
                                                                6.5.1 find_item_equal(COND_EQUAL *cond_equal, const Item_field *item_field, bool *inherited_fl) 的流程：
                                                                          6.5.1.1 遍历 cond_equal->current_level 查找 item_field，如果找不到，则到 cond_equal->upper_levels 中继续查找
                                                                          6.5.1.2 如果不 cond_equal 的第一层查找到，则设置 inherited_fl = true，表示继承上层的等式
                                                        6.6 搜索包含 right_item_field 的多重等式 Item_equal *right_item_equal = find_item_equal(cond_equal, right_item_field, &right_copyfl)
                                                        6.7 由于 (NULL=NULL) != TRUE，我们不能简单地删除谓词 f=f
                                                        6.8 如果 left_field->eq(right_field)，其中 eq 函数中已经过滤 NULL=NULL 的场景
                                                                6.8.1 如果之前没找到对于的多重等式，且该字段不为 nullable: !((left_field->is_nullable() || left_field->table->is_nullable()) && !left_item_equal) 则设置 simple_equality = true，返回
                                                        6.9 如果之前找到对应的多重等式 left_item_equal && left_item_equal == right_item_equal 则设置 *simple_equality = true，返回
                                                        6.10 如果 left_copyfl 则设置 left_item_equal = new Item_equal(left_item_equal)，然后 push_back 到 cond_equal->current_level
                                                        6.11 right_copyfl 同理
                                                        6.12 如果 left_item_equal
                                                                  6.12.1 如果 !right_item_equal 则把 right_item 添加进 left_item_equal
                                                                          否则合并 left_item_equal 和 right_item_equal，然后从 cond_equal->current_level 中删除 right_item_equal
                                                             否则如果 right_item_equal，则把 left_item 添加到 right_item_equal 
                                                                     否则创建新的 Item_equal *item_equal = new Item_equal(down_cast<Item_field *>(left_item), down_cast<Item_field *>(right_item))
                                                                     然后把 item_equal push_back 到 cond_equal->current_level
                                                        6.13 设置 *simple_equality = true，返回
                                                  7、如果 left_item 和 right_item 的关系是 field=const/const=field
                                                        7.1 创建临时变量 Item *const_item = nullptr，Item_field *field_item = nullptr
                                                        7.2 如果 left_item 是字段且没有 depended from 别的 query_block，right_item 是常量表达式，则设置 const_item = right_item
                                                        7.3 right_item 同理
                                                        7.5 判断 const_item 是否需要在优化期间评估
                                                                7.5.1 如果 const_item 是常量，则表示它不需要访问任何表，则不需要在优化期间评估
                                                                7.5.2 如果 const_item 没有子查询，或者查询块未禁用子查询优化选项，则需要在优化期间评估
                                                            如果不需要在优化期间评估，则直接返回
                                                        7.6 如果常量表达式包含对字段的引用（例如，a = (a IS NULL)，则直接返回
                                                        7.7 如果 field_item 和 const_item 的 result_type() 一致
                                                                7.7.1 如果是 STRING_RESULT
                                                                          7.7.1.1 如果 item（它是 check_simple_equality 函数中的参数） 不为空，构建 Item_func_eq，然后赋值给 item
                                                                          7.7.1.2 如果 const_item 的字符集跟 item 的字符集不一样，则返回
                                                                          7.7.1.3 如果 field_item 或者 const_item 是 JSON 数据类型，则不构建 MES，返回
                                                                          7.7.1.4 如果 const_item 是时间类型，如果字段类型不是时间类型，则返回
                                                                7.7.2 创建临时变量 bool copyfl
                                                                7.7.3 在 cond_equal 中查找 field_item，代码为 Item_equal *item_equal = find_item_equal(cond_equal, field_item, &copyfl)
                                                                7.7.4 如果不是在本层 cond_equal 中查找到，则重新创建新的 Item_equal 并把它添加到 cond_equal->current_level.push_back(item_equal)
                                                                7.7.5 如果在 cond_equal 中找到 field_item，且多重等式中有常量，则需要确保现有的常量和新的常量是可比较的排序规则，
                                                                            如果多重等式已包含常量并且其值与 const_item 的值不相等，则将多重等式的 cond_false 标志设置为 1，
                                                                            否则把 const_item 和 field_item 添加到多重等式中
                                                                      否则使用 const_item, field_item 构建新的 Item_equal 然后赋值给 item_equal，在把它 push_back 到 cond_equal->current_level
                                                                7.7.6 设置 *simple_equality = true，返回
                                                  8、返回
                            3、返回
           3.3 如果 equality 不是空
                     3.3.1 设置临时变量 int n = cond_equal.current_level.elements + eq_list.elements
                              如果 n == 0 则设置 *retcond = new Item_func_true()，返回
                              如果 n == 1 
                                          如果 item_equal = cond_equal.current_level.pop()
                                                执行函数 item_equal->resolve_type(thd)，目的是设置 item_equal->eval_item 的数据类型、字符集，其中 item_equal->eval_item 是用来辅助字段之间的比较
                                                执行函数 item_equal->update_used_tables()
                                                    其中 update_used_tables() 的流程：
                                                          设置 item_equal 的 not_null_tables_cache = used_tables_cache = 0，m_accum_properties = 0
                                                          遍历 item_equal 的 fields item
                                                                      item 执行 item->update_used_tables()
                                                                      设置 used_tables_cache |= item->used_tables()
                                                                      设置 not_null_tables_cache |= item->not_null_tables()
                                                          如果 item_equal 的 m_const_arg != nullptr，则设置 used_tables_cache |= m_const_arg->used_tables()
                                                设置 *retcond = item_equal，返回
                                          设置 *retcond = eq_list.pop()，返回
                              如果 n >=2  
                                          则定义临时变量 Item_cond_and *and_cond = new Item_cond_and(eq_list)
                                          执行 and_cond->fixed = true;
                                          设置临时变量 List<Item> *args = and_cond->argument_list()
                                          遍历 cond_equal.current_level item_equal
                                                执行函数 item_equal->resolve_type(thd)，目的是设置 item_equal->eval_item 的数据类型、字符集，其中 item_equal->eval_item 是用来辅助字段之间的比较
                                                执行函数 item_equal->update_used_tables()
                                          设置 and_cond->cond_equal = cond_equal
                                          执行函数 args->concat((List<Item> *)&cond_equal.current_level)
                                          设置 *retcond = and_cond，返回
           3.4 如果 do_inherit == true 
                     设置临时变量 uchar *is_subst_valid = (uchar *)1;
                     执行函数 cond = cond->compile(&Item::subst_argument_checker, &is_subst_valid, &Item::equal_fields_propagator, (uchar *)inherited)
                              它的功能是：对于 cond 中的每个字段（要求不是来自多重等式、要求字段不是 string 类型，要求字段引用不是来自比较谓词的参数），设置它属于哪个 multiple equality
           3.5 执行 cond->update_used_tables()
4、设置 *retcond = cond，返回


等价逻辑变换整体流程：
1、根据 query_block->m_table_nest 生成 RelationalExpression *root
  1.1 生成每个谓词的 RelationalExpression 后，如果 Table_ref->m_join_cond_optim 不为空
      1.1.1  执行 EarlyExpandMultipleEquals 函数
          1.1.1.1  只处理条件中的 MultipleEquals
          1.1.1.2  如果 m_join_cond_optim 的条件中涉及表数为 0（说明遇到常量表），且条件为 FALSE，则 new Item_func_false
          1.1.1.3      如果 MultipleEquals 中有常量 A，则用该常量 A 填充所有字段
          1.1.1.4          如果 MultipleEquals 的 used_tables_cache 涉及表数超过 2，则执行 ExpandSameTableFromMultipleEquals 函数
                        1.1.1.4.1 提取 MultipleEquals 的主要信息：比如 MultipleEquals(t1.a, t2.a, t2.b, t3.a) 会被转换成 t2.a=t2.b AND (original item)。这可以让我们后续把 t2.a=t2.b 下推。
          1.1.1.5              如果  MultipleEquals 的 used_tables_cache 涉及表数为 2
                            1.1.1.5.1 执行 ExpandSameTableFromMultipleEquals 函数，提取 MultipleEquals 的主要信息：比如 MultipleEquals(t1.a, t2.a, t2.b, t3.a) 会被转换成 t2.a=t2.b AND (original item)。这可以让 我们后续把 t2.a=t2.b 下推。
                            1.1.1.5.2 获取两张表之间的一个等式 A.X = B.Y
          1.1.1.6  执行 CreateConjunction 函数，把 List<Item> 转换成 Item_cond_and
      1.1.2  执行 ExtractConditions 函数，把 Item_cond_and 转换成 Mem_root_array<Item *>
      1.1.3  执行 EarlyNormalizeConditions 函数
             1.1.3.1 执行 CSEConditions 函数对条件数组进行公共子表达式消除，得到新的条件数组
             1.1.3.2 对条件数组中的每个条件项进行处理
                     1.1.3.2.1 判断条件项是否是过滤器：如果条件项涉及的表小于2，那个这个条件项是个过滤器
                     1.1.3.2.2 如果是条件项是过滤器或者条件项不是 MULT_EQUAL_FUNC，则计算 tables_in_subtree
                               它的计算方法：如果条件项涉及的表只是在 RelationalExpression 的左边，则设置 tables_in_subtree 为 RelationalExpression->left->tables_in_subtree，
                               右边同样，否则为 RelationalExpression->tables_in_subtree
                               1.1.3.2.2.1 walk 条件项中的每个字段 A，
                                           如果字段 A 的 item_equal（也就是对应的 MultipleEquals）不为空，且 item_equal 包含常量，且常量跟字段 A 类型兼容，则用该常量替换字段 A 
                                               如果条件项不是过滤器，且字段 A 的 item_equal（指向 MultipleEquals） 没包含常量，则遍历字段 A 的 item_equal 所有字段 X，如果 X 对应的表在 tables_in_subtree 中，则使用 X 替换 A，然后退出
                     1.1.3.2.3 运行 remove_eq_conds 函数折叠条件: 
                                        1、只处理 cond 类型为 Item::FUNC_ITEM 或 Item::COND_ITEM 的情况 
                                        2、如果是 Item::COND_ITEM，则遍历 cond->argument_list()，对其中的每个条件项执行 fold_condition 函数，最后更新 used_tables_cache 
                                        3、如果是 Item::COND_ITEM 类型
                                           3.1 如果不是 <字段 运算符 常量> 这种形式则执行 fold_arguments 函数 
                                           3.2 如果是 <字段 运算符 常量> 这种形式，则对运算符、常量进行转换 
                                           3.3 最后把 retcond 构造成 Item_bool_func2
                               如果折叠后是 Item::COND_TRUE 则在条件数组中删除该条件项
                               如果折叠后是 res == Item::COND_FALSE 则清空条件数组，然后值保留上面的 Item_bool_func2
                               其它情况：如果条件项是 AND 条件表达式，则 need_resplit = true，然后更新条件项的 used_tables_cache
             1.1.3.3 如果 need_resplit = true 则执行 ResplitConditions 函数，重新拆分条件数组
                     例如：某个条件项是 A.x = B.x and B.x = D.x 则转换成 Mem_root_array<Item *> 数组，里面包含两个元素 A.x = B.x 和 B.x = D.x
      1.1.4  执行 ReorderConditions 函数，重排序 Mem_root_array<Item *> 数组。因为之前的 optimize_cond() 会导致等式放在数组后面。我们最好把等式调整到数组前面
  1.2 CompanionSet 共享的连接类型：INNER_JOIN 的 left、right，LEFT_JOIN、SEMIJOIN、ANTIJOIN 的 left
  1.3 执行 FlattenInnerJoins 函数：如果 RelationalExpression 符合转换成 MULTI_INNER_JOIN 要求，那么查看它左右孩子，如果也是 MULTI_INNER_JOIN，那么合并成一个更大的 MULTI_INNER_JOIN
  1.4 new Mem_root_array<Item *> 类型的数组：table_filters、cycle_inducing_edges
  1.5 执行 PushDownJoinConditions(thd, root, companion_collection, &table_filters, &cycle_inducing_edges, trace) 函数
        1.5.1 如果是 RelationalExpression::TABLE 则返回
        1.5.2 如果 RelationalExpression::join_conditions 不为空，则执行
              函数 expr->join_conditions = PushDownAsMuchAsPossible(thd, std::move(expr->join_conditions), expr,/*is_join_condition_for_expr=*/true, companion_collection,table_filters, cycle_inducing_edges, trace)
              只有此时的 is_join_condition_for_expr 是 true，下面的子目录中都是 false
              1.5.2.1 遍历参数中的条件数组
                      如果条件项涉及的表少于2，且 !is_join_condition_for_expr，则不会下推
                      如果条件项涉及的表集合不是 RelationalExpression::tables_in_subtree 的子集，条件项不是 MultipleEquals，且 is_join_condition_for_expr 为真，则不会下推
                      其它情况执行 PushDownCondition(item, expr, is_join_condition_for_expr, companion_collection, table_filters, cycle_inducing_edges, &remaining_parts, trace); 函数
                      1.5.2.1.1  如果 expr 是表，直接把 cond 放到 table_filters 数组中，然后返回
                      1.5.2.1.2  计算 cond->used_tables() 和 expr->tables_in_subtree 的交集为 used_tables
                      1.5.2.1.3  如果是 MULTI_INNER_JOIN，遍历 expr->multi_children
                                 1.5.2.1.3.1 如果 used_tables 是循环迭代器的 tables_in_subtree 的子集，则执行函数 PushDownCondition（继续下推）、返回
                                 1.5.2.1.3.2 如果 used_tables 不是任何一个循环迭代器的 tables_in_subtree 的子集，则执行函数
                                             expr = PartiallyUnflattenJoinForCondition(used_tables, expr); 
                                             它根据条件，把 MULTIJOIN 中相关的表撤离出来，比如：MULTIJOIN(t1, t2, t3, t4 LJ t5) 遇到条件 t2.x = t5.x，那么转换为 MULTIJOIN(t1, t3, t2 JOIN (t4 LJ t5))
                      1.5.2.1.4  把条件下推到 RelationalExpression->left 的必要条件：INNER_JOIN、STRAIGHT_INNER_JOIN、MULTI_INNER_JOIN、SEMIJOIN 或 !is_join_condition_for_expr，标记为 can_push_into_left
                      1.5.2.1.5  如果 used_tables 是 expr->left->tables_in_subtree 的子集
                                 1.5.2.1.5.1 如果 can_push_into_left 为真，则执行函数 
                                             PushDownCondition(cond, expr->left, /*is_join_condition_for_expr=*/false, companion_collection, table_filters, cycle_inducing_edges, remaining_parts, trace)，返回
                                 1.5.2.1.5.1 否则也返回
                      1.5.2.1.6  can_push_into_right 同 1.5.2.1.4
                      1.5.2.1.7  如果 (AlreadyExistsOnJoin(cond, *expr) 且 !(expr->type == RelationalExpression::LEFT_JOIN || expr->type == RelationalExpression::ANTIJOIN)) 为真，则返回
                                 其中 AlreadyExistsOnJoin 函数的功能是查看 RelationalExpression 的 join_conditions 是否有 cond，或者有 cond->source_multiple_equality
                                 也就是查看当前的 expr 是否已经蕴含 cond，如果蕴含，则直接返回
                      1.5.2.1.8  如果 can_push_into_left 且 used_tables 跟 expr->left->tables_in_subtree 有交集
                                 1.5.2.1.8.1 执行 make_cond_for_table(current_thd, cond, expr->left->tables_in_subtree, /*used_table=*/0, /*exclude_expensive_cond=*/true) 函数
                                             它的作用是： 如果 used_table 涉及的表是 T1，大体是把 (T1.a = 1 and T2.b = 2) or (T1.a = 3 and T2.b = 4) 转换成 T1.a = 1 or T1.a = 3
                                 1.5.2.1.8.2 如果 make_cond_for_table 的结果不为空，则执行
                                             PushDownCondition(partial_cond, expr->left, /*is_join_condition_for_expr=*/false, companion_collection, table_filters, cycle_inducing_edges, /*remaining_parts=*/nullptr, trace) 函数
                      1.5.2.1.9  can_push_into_right 同 1.5.2.1.8
                      1.5.2.1.10 如果条件是 MultipleEquals
                                 1.5.2.1.10.1 如果 left_tables = cond->used_tables() & expr->left->tables_in_subtree 的结果 >= 两张表, 则执行
                                              PushDownCondition(cond, expr->left, /*is_join_condition_for_expr=*/false, companion_collection, table_filters, cycle_inducing_edges, remaining_parts, trace) 函数
                                 1.5.2.1.10.2 right_tables 同 left_tables
                      1.5.2.1.11 到此，所有的局部下推工作已经完成，然后探索是否可以把原过滤器改造成 join condition
                      1.5.2.1.12 如果 is_join_condition_for_expr 为真则返回
                      1.5.2.1.13 如果 expr->type 属于 LEFT_JOIN 或 ANTIJOIN
                                 1.5.2.1.13.1 bool need_flatten = false，执行函数 AddJoinConditionPossiblyWithRewrite(expr, cond, AssociativeRewritesAllowed::ANY, /*used_commutativity=*/false, &need_flatten, trace)
                                              它的作用是旋转 expr，找到合适的 expr'，然后尝试把 Item *cond 添加进 expr'->join_conditions
                                 1.5.2.1.13.2 如果此时 need_flatten 为真，则执行 FlattenInnerJoins(expr)
                                              它的作用是：如果 RelationalExpression 符合转换成 MULTI_INNER_JOIN 要求，那么查看它左右孩子，如果也是 MULTI_INNER_JOIN，那么合并成一个更大的 MULTI_INNER_JOIN        
                                 1.5.2.1.13.3 返回     
                      1.5.2.1.13 如果 expr->type 属于 SEMIJOIN，则直接执行 expr->join_conditions.push_back(cond)， 然后返回
                      1.5.2.1.14 设置 bool need_flatten = false，执行函数 AddJoinConditionPossiblyWithRewrite(expr, cond, AssociativeRewritesAllowed::ANY, /*used_commutativity=*/false, &need_flatten, trace)
                                 如果函数返回 false
                                 1.5.2.1.14.1 如果 expr->type 属于 INNER_JOIN 且 IsCandidateForCycle(expr, cond, companion_collection) 为真，
                                              其中 IsCandidateForCycle 函数的作用是 检查 cond->used_tables() 是否在一个 CompanionSet 中
                                              1.5.2.1.14.1.1 如果 cond 是 MultipleEquals，创建 Mem_root_array<Item *> possible_cycle_edges
                                                             1.5.2.1.4.1.1.1 执行函数 FullyConcretizeMultipleEquals(down_cast<Item_equal *>(cond), expr->tables_in_subtree, &possible_cycle_edges)
                                                                             它的功能是：把 (A.x, B.x, D.x, E.x)、allowed_tables={A,B,C,D} 转换成  A.x = B.x and B.x = D.x (E.x is ignored)
                                                             1.5.2.1.4.1.1.2 遍历 possible_cycle_edges，
                                                                             执行函数 PushDownCondition(sub_cond, expr,/*is_join_condition_for_expr=*/false, companion_collection, table_filters, cycle_inducing_edges, remaining_parts, trace)
                                              1.5.2.1.14.1.2 如果 cond 不是 MultipleEquals 则执行函数 
                                                             cycle_inducing_edges->push_back(CanonicalizeCondition(cond, expr->tables_in_subtree, expr->tables_in_subtree))
                                                             其中 CanonicalizeCondition 函数的作用是 walk cond, 把其中的 MultipleEquals (A.x, B.x, D.x, E.x)、allowed_tables={A,B,C,D} 转换成  A.x = B.x and B.x = D.x (E.x is ignored)
                                              1.5.2.1.14.1.3 如果 need_flatten 为真则执行函数 FlattenInnerJoins(expr)
                                                             它的作用是：如果 RelationalExpression 符合转换成 MULTI_INNER_JOIN 要求，那么查看它左右孩子，如果也是 MULTI_INNER_JOIN，那么合并成一个更大的 MULTI_INNER_JOIN
                                              1.5.2.1.14.1.4 返回
                                 1.5.2.1.14.2 如果 cond 是 MultipleEquals 且 MultipleEqualityAlreadyExistsOnJoin(down_cast<Item_equal *>(cond), *expr) 为假，
                                              （其中 MultipleEqualityAlreadyExistsOnJoin 的作用是：查看 RelationalExpression 的 join_conditions、equijoin_conditions，检查是否有 Item_eq_base 属于 Item_equal）
                                              则执行函数  expr->join_conditions.push_back(ConcretizeMultipleEquals(down_cast<Item_equal *>(cond), *expr))
                                              （其中 ConcretizeMultipleEquals 函数的作用是：先到 GetVisibleTables(expr.left 或 right) 查找 item_field.used_tables() 是否能形成边，如果没有则到 expr.left->tables_in_subtree 中查找）
                                 1.5.2.1.14.3 其它情况，如果 used_tables 是 expr->tables_in_subtree 子集，则执行 expr->join_conditions.push_back(cond)
                                 1.5.2.1.14.4 其它情况，执行 remaining_parts->push_back(cond)
                      1.5.2.1.15 如果 need_flatten 为真则执行函数 FlattenInnerJoins(expr)
```

```cpp
static AccessPath *FindBestQueryPlanInner(THD *thd, Query_block *query_block, bool *retry, int *subgraph_pair_limit, string *trace) 流程：
1、 判断存储引擎是否支持 hypergraph
2、 把 JOIN 对象转变成 JoinHypergraph
       2.1 把 query_block 赋值给 临时变量 graph->m_query_block： JoinHypergraph graph(thd->mem_root, query_block)
       2.2 设置临时变量 bool where_is_always_false = false
       2.3 构建 JoinHypergraph:  MakeJoinHypergraph(thd, trace, &graph, &where_is_always_false
3、 如果 where_is_always_false 则返回 0 行： CreateZeroRowsForEmptyJoin(join, "WHERE condition is always false")
4、 执行函数 FindSargablePredicates(thd, trace, &graph); 
       4.1 遍历 graph->nodes、内嵌遍历 graph->node.join_conditions_pushable_to_this 
       4.2 如果 graph->predicates[i].condition 可以应用索引，则把它 放到 JoinHypergraph::Node->sargable_predicates
5、 执行函数 CacheCostInfoForJoinConditions(thd, query_block, &graph, trace)，用于缓存一些多次使用的信息
       5.1 遍历 graph->edge.expr->equijoin_conditions，构造 CachedPropertiesForPredicate，然后放进 graph->edge.expr->properties_for_equijoin_conditions
       5.2 遍历 graph->edge.expr->join_conditions，构造 CachedPropertiesForPredicate，然后放进 edge.expr->properties_for_join_conditions
6、 定义临时变量 bool need_rowid = false
       6.1 如果 SQL 是 group、order、distinct、windows 其中任何一个类型，
               6.1.1 遍历 *join->fields，如果有 blob 字段，则该 SQL 需要 rowid
               6.1.2 遍历 query_block->leaf_tables tl，如果 SortWillBeOnRowId(tl->table)，则该 SQL 需要 rowid
7、 定义临时变量 MutableOverflowBitset materializable_predicates{thd->mem_root, graph.predicates.size()}
       7.1 遍历 graph.predicates，如果 graph.predicates[i].condition 包含子查询，则标记该谓词需要物化
       7.2 把 materializable_predicates 深拷贝到 graph.materializable_predicates
8、 检查该 SQL 是否 DELETE 类型、UPDATE 类型、有全文检索函数
        定义临时变量 const bool is_topmost_query_block = query_block->outer_query_block() == nullptr，代表是否最外层 query_block
        定义临时变量 const bool is_delete = is_topmost_query_block && IsDeleteStatement(thd)，代表是否 DELETE 类型 SQL
        定义临时变量 const bool is_update = is_topmost_query_block && IsUpdateStatement(thd)，代表是否 UPDATE 类型 SQL
        定义临时变量 table_map update_delete_target_tables = 0，用于统计需要 DELETE 或者 UPDATE 的表编号    
        定义临时变量  table_map immediate_update_delete_candidates = 0
        如果该 SQL 是 DELETE 或者 UPDATE 类型，则分别更新 update_delete_target_tables 和 immediate_update_delete_candidates
        定义临时变量 NodeMap fulltext_tables = 0 和 uint64_t sargable_fulltext_predicates = 0
        如果该 query_block 有全文检索函数，则更新 fulltext_tables 和 sargable_fulltext_predicates
9、 从  ORDER BY, GROUP BY, semijoins 和 windows 中收集 interesting orders
        定义临时变量
        LogicalOrderings orderings(thd)
        Mem_root_array<SortAheadOrdering> sort_ahead_orderings(thd->mem_root)
        Mem_root_array<ActiveIndexInfo> active_indexes(thd->mem_root)
        Mem_root_array<SpatialDistanceScanInfo> spatial_indexes(thd->mem_root)
        Mem_root_array<FullTextIndexInfo> fulltext_searches(thd->mem_root)
        int order_by_ordering_idx = -1
        int group_by_ordering_idx = -1
        int distinct_ordering_idx = -1
        执行函数 BuildInterestingOrders(thd, &graph, query_block, &orderings, &sort_ahead_orderings, &order_by_ordering_idx, &group_by_ordering_idx, &distinct_ordering_idx, &active_indexes, &spatial_indexes, &fulltext_searches, trace)
10、执行函数 (InjectCastNodes(&graph)
        它把 graph->predicates 的 condition，还有 graph->edges 的 expr join_predicate_last、join_conditions，还有的 join->fields、join->group_list.order、join->having_cond 不兼容的数据类型比较转换成兼容的类型
11、遍历  graph.nodes node，执行函数 node.table->init_cost_model(thd->cost_model())，用于初始化每个 graph.nodes.table 的代价模型
12、定义临时变量  CostingReceiver receiver(thd, query_block, graph, &orderings, &sort_ahead_orderings, &active_indexes, &spatial_indexes, &fulltext_searches, fulltext_tables,
                                          sargable_fulltext_predicates, update_delete_target_tables, immediate_update_delete_candidates, need_rowid, EngineFlags(thd), 
                                          *subgraph_pair_limit, secondary_engine_cost_hook, secondary_engine_optimizer_request_state_hook, trace)
       12.1 如果 graph.nodes.size() == 1 则执行函数 receiver.FoundSingleNode(0)，查找单表查询的最佳路径
       12.2 如果 graph.nodes.size() > 1 则执行函数 EnumerateAllConnectedPartitions(graph.graph, &receiver) 用于查找最佳的 join order
            如果执行失败且 join->zero_result_cause == nullptr，则简化超图。定义临时变量 GraphSimplifier simplifier(&graph, thd->mem_root)
            do {
                定义临时变量 *subgraph_pair_limit = receiver.subgraph_pair_limit()
                执行函数 SetNumberOfSimplifications(0, &simplifier)
                执行函数 SimplifyQueryGraph(thd, *subgraph_pair_limit, &graph, &simplifier, trace) 简化超图
                重置 receiver = CostingReceiver(thd, query_block, graph, &orderings, &sort_ahead_orderings, &active_indexes, &spatial_indexes, &fulltext_searches, fulltext_tables, 
                                          sargable_fulltext_predicates, update_delete_target_tables, immediate_update_delete_candidates, need_rowid, EngineFlags(thd),
                                          *subgraph_pair_limit, secondary_engine_cost_hook, secondary_engine_optimizer_request_state_hook, trace)
            }while (EnumerateAllConnectedPartitions(graph.graph, &receiver) && (join->zero_result_cause == nullptr) && (!thd->is_error()))
13、如果 join->zero_result_cause != nullptr 则返回 0 记录的路径 CreateZeroRowsForEmptyJoin(join, join->zero_result_cause)
14、获取 root candidates，因为第二个引擎可能 hook 导致没有 candidates。
       14.1 定义临时变量 Prealloced_array<AccessPath *, 4> root_candidates = receiver.root_candidates()
       14.2 如果该 SQL 是 value_constructor 类型，则定义临时变量 AccessPath *path = NewTableValueConstructorAccessPath(thd, join)，并初始化它。
            然后执行函数 receiver.ProposeAccessPath(path, &root_candidates, /*obsolete_orderings=*/0, /*description_for_trace=*/"")
       14.3 root_candidates 为空，则打印错误信息
15、如果 receiver.always_empty()，则遍历 root_candidates root_path，如果是 0 记录的路径，则返回 CreateZeroRowsForEmptyJoin(join, root_path->zero_rows().cause)
17、现在，我们至少有一条把所有表 join 在一起的路径。接着我们需要找出最低成本的路径。
    我们忽略 LIMIT 后续的 init_cost，所以在每个步骤中我们只剩下很少的 candidates，但是这部分成本很低，不值得优化。
       17.1 定义临时变量  FunctionalDependencySet fd_set = receiver.active_fds_at_root()、ool has_final_predicates = false
       17.2 遍历 graph.num_where_predicates i，如果 graph.predicates[i].total_eligibility_set 跟 TablesBetween(0, graph.nodes.size()) 不相交
            则设置 fd_set |= graph.predicates[i].functional_dependencies、has_final_predicates = true
       17.3 在所有的 candidates 路径中，添加 final predicates，然后展开 过滤路径。如果没有过滤路径的话，就没必要添加。因为它开销不昂贵，所以不值得花太多精力去找到它是否可以用忽略。
              如果 has_final_predicates 或者  !(root_candidates.size() == 1 && root_candidates[0]->type == AccessPath::EQ_REF && IsEmpty(root_candidates[0]->filter_predicates))
                  定义临时变量  Prealloced_array<AccessPath *, 4> new_root_candidates(PSI_NOT_INSTRUMENTED)
                  遍历 root_candidates root_path
                      内嵌遍历 for (bool materialize_subqueries : {false, true})
                          定义临时变量 AccessPath path = *root_path、double init_once_cost = 0.0、 MutableOverflowBitset filter_predicates = path.filter_predicates.Clone(thd->mem_root)
                          遍历 graph.num_where_predicates i
                              如果 (!Overlaps(graph.predicates[i].total_eligibility_set, TablesBetween(0, graph.nodes.size())) || Overlaps(graph.predicates[i].total_eligibility_set, RAND_TABLE_BIT)
                                  则 filter_predicates.SetBit(i)
                                  然后评估过滤的代价：FilterCost cost = EstimateFilterCost(thd, root_path->num_output_rows(), graph.predicates[i].contained_subqueries)
                                  如果 materialize_subqueries 则设置 path.set_cost(path.cost() + cost.cost_if_materialized)、init_once_cost += cost.cost_to_materialize
                                  否则设置 path.set_cost(path.cost() + cost.cost_if_not_materialized)
                          设置 path.ordering_state = orderings.ApplyFDs(path.ordering_state, fd_set)
                               path.filter_predicates = std::move(filter_predicates)
                               const bool contains_subqueries = Overlaps(path.filter_predicates, graph.materializable_predicates)
                          现在我们需要 full plan，所以需要展开所有的过滤条件到对应的过滤节点中
                               执行函数 ExpandFilterAccessPaths(thd, &path, join, graph.predicates, graph.num_where_predicates)
                          如果 materialize_subqueries 则设置
                               path.filter().materialize_subqueries = true
                               path.set_cost(path.cost() + init_once_cost)  // Will be subtracted back for rescans.
                               path.set_init_cost(path.init_cost() + init_once_cost)
                               path.set_init_once_cost(path.init_once_cost() + init_once_cost)
                          执行函数 receiver.ProposeAccessPath(&path, &new_root_candidates, /*obsolete_orderings=*/0, materialize_subqueries ? "mat. subq" : "")
                          如果不包含子查询，则跳出循环
                  设置 root_candidates = std::move(new_root_candidates)
18、应用 GROUP BY。我们先操作 sorting，然后再使用流式聚合。
       18.1 检查聚合是否需要排序 const bool aggregation_is_unordered = Overlaps(EngineFlags(thd), MakeSecondaryEngineFlags(SecondaryEngineFlag::AGGREGATION_IS_UNORDERED))
       18.2 应用流式聚合 ApplyAggregation(thd, &graph, receiver, group_by_ordering_idx, need_rowid, aggregation_is_unordered, orderings, sort_ahead_orderings, fd_set, query_block, root_candidates, trace)
19、应用 HAVING 条件之前，需要确保 used_tables() cache 已经被是最新。该条件可能会被函数 FinalizePlanForQueryBlock() 改写成临时表
       19.1 如果 join->having_cond != nullptr，则执行函数 join->having_cond->update_used_tables()
       19.2 如果没有 window-related in2exists 的部分，则执行下面步骤
            定义临时变量 Item *having_cond、Item *having_cond_wf
            执行函数  SplitHavingCondition(thd, join->having_cond, &having_cond, &having_cond_wf)
            执行函数 ApplyHavingOrQualifyCondition(thd, having_cond, query_block, "Applying filter for HAVING\n", trace, &root_candidates, &receiver)
20、应用 窗口函数中的 GROUP BY，如果有 ORDER BY 的话，我们则需要在排序之前先物化
       20.1 如果 query_block->is_explicitly_grouped() && !join->m_windows.is_empty()
            定义临时变量 Prealloced_array<AccessPath *, 4> new_root_candidates(PSI_NOT_INSTRUMENTED)
            遍历 root_candidates root_path
                  设置 root_path = CreateMaterializationOrStreamingPath(thd, join, root_path, need_rowid, /*copy_items=*/true)
                  执行函数 receiver.ProposeAccessPath(root_path, &new_root_candidates, /*obsolete_orderings=*/0, "")
            设置 root_candidates = std::move(new_root_candidates)
       20.2 设置 join->m_windowing_steps = !join->m_windows.is_empty()
            如果 join->m_windowing_steps
                  则设置 root_candidates = ApplyWindowFunctions(thd, receiver, orderings, fd_set, aggregation_is_unordered, order_by_ordering_idx, distinct_ordering_idx, graph,
                                                                sort_ahead_orderings, query_block, graph.num_where_predicates, need_rowid, std::move(root_candidates), trace)
21、过滤节点需要添加到窗口函数中
       21.1 定义临时变量  Item *post_window_filter = nullptr
            如果 having_cond_wf != nullptr，则设置 post_window_filter = having_cond_wf
22、如果 query_block->qualify_cond() != nullptr，
       则设置 query_block->qualify_cond()->update_used_tables()
       如果 post_window_filter == nullptr 则设置 post_window_filter = query_block->qualify_cond()
            否则设置 
            post_window_filter = new Item_cond_and(post_window_filter, query_block->qualify_cond())
            post_window_filter->quick_fix_field()
            post_window_filter->update_used_tables()
            post_window_filter->apply_is_true()
23、执行函数 ApplyHavingOrQualifyCondition(thd, post_window_filter, query_block, description_for_trace.c_str(), trace, &root_candidates, &receiver)
24、如果 join->select_distinct || join->order.order != nullptr
       则设置
       const bool force_sort_rowids = update_delete_target_tables != 0
       root_candidates = ApplyDistinctAndOrder(thd, receiver, orderings, aggregation_is_unordered, order_by_ordering_idx, distinct_ordering_idx, sort_ahead_orderings,
                                               fd_set, query_block, need_rowid, force_sort_rowids, std::move(root_candidates), trace)
25、应用 LIMIT and OFFSET。如果 query block 有排序，那么他们已经在函数 ApplyDistinctAndOrder() 中被应用
       25.1 定义临时变量  Query_expression *query_expression = join->query_expression()
       25.2 如果没有排序 join->order.order == nullptr && (query_expression->select_limit_cnt != HA_POS_ERROR || query_expression->offset_limit_cnt != 0)
            则定义临时变量 Prealloced_array<AccessPath *, 4> new_root_candidates(PSI_NOT_INSTRUMENTED)
            遍历 root_candidates root_path
                 定义临时变量  AccessPath *limit_path = NewLimitOffsetAccessPath(thd, root_path, query_expression->select_limit_cnt, query_expression->offset_limit_cnt, join->calc_found_rows,
                                                                                /*reject_multiple_rows=*/false, /*send_records_override=*/nullptr)
                 执行函数  receiver.ProposeAccessPath(limit_path, &new_root_candidates, /*obsolete_orderings=*/0, "")
            设置 root_candidates = std::move(new_root_candidates);
26、如果是最外层的 query block，且是 DELETE 或者 UPDATE 的 SQL 类型，则添加 DELETE_ROWS 或者 UPDATE_ROWS 路径
27、定义临时变量 AccessPath *root_path = *std::min_element(root_candidates.begin(), root_candidates.end(), [](const AccessPath *a, const AccessPath *b) { return a->cost() < b->cost();})
28、如果最外层 query block 有 SQL_BUFFER_RESULT，则物化它的查询结果
       28.1 如果 query_block->active_options() & OPTION_BUFFER_RESULT && is_topmost_query_block && !IsMaterializationPath(root_path) && IteratorsAreNeeded(thd, root_path)
            如果有窗口函数，我们需要把最后的窗口函数物化
                 定义临时变量 bool copy_items = join->m_windows.is_empty()
                 设置 root_path = CreateMaterializationPath(thd, join, root_path, /*temp_table=*/nullptr, /*temp_table_param=*/nullptr, copy_items)
29、设置 join->needs_finalize = true，join->best_rowcount = lrint(root_path->num_output_rows())，join->best_read = root_path->cost()
30、如果结果不超过1行，且有 LIMIT 和 OFFSET，则代表它是常量表
       如果 join->best_rowcount <= 1 && query_expression->select_limit_cnt - query_expression->offset_limit_cnt > 1
              则设置 join->best_rowcount = PLACEHOLDER_TABLE_ROW_ESTIMATE
31、返回 root_path





2、如果 RelationalExpression 符合转换成 MULTI_INNER_JOIN 要求，那么查看它左右孩子，如果也是 MULTI_INNER_JOIN，那么合并成一个更大的 MULTI_INNER_JOIN
1、walk where_cond
  1.1、如果是常量表，
  1、展开 multiple equal 项
  1.1 如果 multiple equal 项只有两张表 A、B，则构建 A.X=B.Y 等式

下推方向的研究
2、    
A SJ B ON (A.ID=9 AND XXXX), 其中 A.ID=9  可以下推给表 A

3、
局部下推：
T1 JOIN T2 ON (T1.a = 1 and T2.b = 2) or (T1.a = 3 and T2.b = 4) 
可以把 JOIN 条件转换成 T1.a = 1 or T1.a = 3，然后下推给 T1

ON 条件的下推分析
4、
T1 SJ T2 ON XX1 WHERE XX2
XX1 可以下推到左边

T1 ANTIJ T2 ON XX1 WHERE XX2
XX1 不可以下推到左边

on 中的条件：
5、INNER JOIN ，两边都可以下推
6、LEFT JOIN ，右边可以下推 （待阅源码核对）
7、FULL JOIN ，都不可以下推 （待阅源码核对）

WHERE 条件的下推分析
T1 SJ T2 ON XX1 WHERE XX2

8、T1 LEFT JOIN T2 ON 中的过滤条件对 T1 不具有任何效果，但对 T2 全部有效。例子：
```sql
create table t1 (id int,a int);
create table t2 (id int,a int);
insert into t1 values(1,null);
insert into t2 values(1,1);

select t1.* from t1 left join t2 on t1.id=t2.id;
+----+------+
| id | a    |
+----+------+
|  1 | NULL |
+----+------+

select t1.* from t1 left join t2 on t1.id=t2.id and t1.id>1;   
+----+------+
| id | a    |
+----+------+
|  1 | NULL |
+----+------+

select t1.* from t1 left join t2 on t1.id=t2.id and t1.a is not null;
+----+------+
| id | a    |
+----+------+
|  1 | NULL |
+----+------+

select t2.* from t1 left join t2 on t1.id=t2.id and t2.id>1;
+------+------+
| id   | a    |
+------+------+
| NULL | NULL |
+------+------+

select t2.* from t1 left join t2 on t1.id=t2.id and t1.id>1;
+------+------+
| id   | a    |
+------+------+
| NULL | NULL |
+------+------+
```
但 INNER JOIN 是左右两边都起效。


过滤条件： 字段 ？ 常量
关系条件： 字段 ？ 字段
multiple equality 条件： 字段、字段、…… 字段 （没有常量）

总结：
on 中的关系、过滤条件：
1、INNER JOIN : 两边都可以下推
2、LEFT JOIN  : 可以下推到右边 （待阅源码核对）
3、FULL JOIN  : 都不可以下推   （待阅源码核对）
4、SEMI JOIN  : 可以下推到左边 （待阅源码核对）
5、ANTI JION  : 都不可以下推   （待阅源码核对）
6、MULTI_INNER_JOIN ：

where 中的过滤条件：
1、INNER JOIN : 本级、两边都可以下推
2、LEFT JOIN  : 可以下推到左边  跟左边相交可以下推到本级（待阅源码核对）。如果跟右边相交，则被转换成 INNER JOIN
3、FULL JOIN  : 左右两边、本级都不可以下推   （待阅源码核对）。如果跟其中一侧相交，则被转换成 LEFT JOIN，如果同时相交，则被转换成 INNER JOIN
4、SEMI JOIN  : 可以下推到左边 ，只能跟左边相交，建议直接下推到左边，没必要下推到本级（待阅源码核对）
5、ANTI JION  : 可以下推到左边 ，只能跟左边相交，建议直接下推到左边，没必要下推到本级（待阅源码核对）
6、MULTI_INNER_JOIN ：

where 中的关系条件：
1、INNER JOIN : 本级、两边都可以下推
2、LEFT JOIN  : 可以下推到左边 （待阅源码核对）。如果跟右边相交，则被转换成 INNER JOIN
3、FULL JOIN  : 左右两边、本级都不可以下推   （待阅源码核对）。如果跟其中一侧相交，则被转换成 LEFT JOIN，如果同时相交，则被转换成 INNER JOIN
4、SEMI JOIN  : 可以下推到左边，因为不会跟右边相交 （待阅源码核对）
5、ANTI JION  : 可以下推到左边，因为不会跟右边相交 （待阅源码核对）
6、MULTI_INNER_JOIN ：

multiple equality 下推
比如 (A.ID,B.ID,C.ID) 遇到 (A JOIN B) JOIN C
可以把 (A.ID,B.ID) 下推到左边，也就是 (A JOIN B) 

多层 join 的等价下推研究：
```sql
mysql> select * from t1;
+----+------+------+------+------+
| id | a    | b    | c    | d    |
+----+------+------+------+------+
|  0 |    0 |    0 |    0 |    0 |
|  1 |    1 |    0 |    0 |    0 |
|  8 |    8 |    0 |    0 |    0 |
+----+------+------+------+------+
3 rows in set (0.00 sec)

mysql> select * from t2;
+----+------+------+------+------+
| id | a    | b    | c    | d    |
+----+------+------+------+------+
|  0 |    0 |    0 |    0 |    0 |
|  1 |    1 |    0 |    0 |    0 |
|  2 |    2 |    0 |    0 |    0 |
+----+------+------+------+------+
3 rows in set (0.00 sec)

mysql> select * from t3;
+----+------+------+------+------+
| id | a    | b    | c    | d    |
+----+------+------+------+------+
|  1 |    1 |    0 |    0 |    0 |
|  2 |    2 |    0 |    0 |    0 |
|  3 |    3 |    0 |    0 |    0 |
|  8 |    8 |    0 |    0 |    0 |
+----+------+------+------+------+
4 rows in set (0.00 sec)

mysql> select t1.*,t2.*,t3.* from t1 left join t2 on 1=1 left join t3 on t1.id=t2.id and t1.id=t3.id;
+----+------+------+------+------+------+------+------+------+------+------+------+------+------+------+
| id | a    | b    | c    | d    | id   | a    | b    | c    | d    | id   | a    | b    | c    | d    |
+----+------+------+------+------+------+------+------+------+------+------+------+------+------+------+
|  0 |    0 |    0 |    0 |    0 |    2 |    2 |    0 |    0 |    0 | NULL | NULL | NULL | NULL | NULL |
|  0 |    0 |    0 |    0 |    0 |    1 |    1 |    0 |    0 |    0 | NULL | NULL | NULL | NULL | NULL |
|  0 |    0 |    0 |    0 |    0 |    0 |    0 |    0 |    0 |    0 | NULL | NULL | NULL | NULL | NULL |
|  1 |    1 |    0 |    0 |    0 |    2 |    2 |    0 |    0 |    0 | NULL | NULL | NULL | NULL | NULL |
|  1 |    1 |    0 |    0 |    0 |    1 |    1 |    0 |    0 |    0 |    1 |    1 |    0 |    0 |    0 |
|  1 |    1 |    0 |    0 |    0 |    0 |    0 |    0 |    0 |    0 | NULL | NULL | NULL | NULL | NULL |
|  8 |    8 |    0 |    0 |    0 |    2 |    2 |    0 |    0 |    0 | NULL | NULL | NULL | NULL | NULL |
|  8 |    8 |    0 |    0 |    0 |    1 |    1 |    0 |    0 |    0 | NULL | NULL | NULL | NULL | NULL |
|  8 |    8 |    0 |    0 |    0 |    0 |    0 |    0 |    0 |    0 | NULL | NULL | NULL | NULL | NULL |
+----+------+------+------+------+------+------+------+------+------+------+------+------+------+------+
9 rows in set (0.00 sec)
```
可以看出如果 t1.id=t2.id 下推给 t1 left join t2 就不等价了


CertainlyUsedTablesForCondition 例子
// 遍历 expr.join_conditions，获取条件中使用的表。因为 multiple equalities 的 used_tables() 没有设置，所以需要特殊处理
// 如果 cond 是 multiple equalities，根据 left、right 的 RelationalExpression::type 来获取 used_tables
// GetVisibleTables：SEMIJOIN、ANTIJOIN 返回左边 RelationalExpression 的 tables_in_subtree，其他返回 左右两边 RelationalExpression 的 tables_in_subtree
也就是各种JOIN类型，只有 SEMIJOIN、ANTIJOIN 右边的表，对于上层来说不可见


expr->companion_set 
如果 expr 是表 ，则遍历 expr->join_conditions_pushable_to_this，把里面的等式添加到 expr->companion_set
其它情况，则遍历 expr->equijoin_conditions，把里面的等式添加到 expr->companion_set

select t1.* from t1
left join t2 on t1.id=t2.a
left join t3 on t1.b=t3.c
where t1.a=1 and t2.a=t1.a and t3.a=t1.a # 常量替换
      and ((t1.b = 1 and t2.b=2) or (t1.b=1 and t2.c=2)) # 公共子表达式消除后是 (t1.b = 1 and ( t2.b= 2 or t2.c=2))
      and t3.id # 标量处理
      and t1.b=t3.id
      ;
得到的 expr->companion_set 是
Mem_root_array_Field_0x7fff3411b840
0x7fff340ac530   Field_long * ---- field_name:t1.b 
0x7fff34018cc0   Field_long * ---- field_name:t3.id


Selectivity 探索
意思：给出一个常量，计算它在表中的命中率
  EstimateEqualPredicateSelectivity(const EqualFieldArray &equal_fields, const CompanionSet &companion_set, string *trace)

如果 WHERE 条件中出现 字段A=字段B，则它一定是 INNER|ANTI|SJ JOIN 的条件


select t1.* from t1
left join t2 on t1.id=t2.a
left join t3 on t1.d=t3.c
where t1.a=1 and t2.a=t1.a and t3.a=t1.a # 常量替换
      and ((t1.b = t2.d and t2.b=2) or (t2.d=t1.b and t2.c=2)) # 公共子表达式消除后是 (t1.b = t2.d and ( t2.b= 2 or t2.c=2))
	  ;

检查能不能识别 t1.b = t2.d 跟 t2.d=t1.b 是一样
有 BUG
```sql
select t1.* from t1
left join t2 on t1.id=t2.a
left join t3 on t1.d=t3.c
where t1.a=1 and t2.a=t1.a and t3.a=t1.a # 常量替换
      and ((t1.b = t2.d and t2.b=2) or (t2.d=t1.b and t2.c=2)) # 公共子表达式消除后是 (t1.b = t2.d and ( t2.b= 2 or t2.c=2))
	  ;
该SQL 在这里  (((`test`.`t1`.`b` = `test`.`t2`.`d`) and (`test`.`t2`.`b` = 2)) or ((`test`.`t2`.`d` = `test`.`t1`.`b`) and (`test`.`t2`.`c` = 2))) 没生成对应的 multiple_equality，导致没有触发 公共子表达式消除

如果把 left join t3 on t1.d=t3.c 改写成 left join t3 on t1.b=t3.c
它会生成 对应的 multiple_equality，然后触发 公共子表达式消除
```
