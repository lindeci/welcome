- [简单例子](#简单例子)
- [Makefile结构说明](#makefile结构说明)
- [复杂一些的Makefile](#复杂一些的makefile)
- [常用的预定义变量。](#常用的预定义变量)
- [Makefile 提高版](#makefile-提高版)
- [写Makefile的注意事项](#写makefile的注意事项)
- [隐含规则](#隐含规则)
  - [隐含规则的含义](#隐含规则的含义)
  - [隐含规则的工作流程](#隐含规则的工作流程)
  - [隐含规则可能导致的问题](#隐含规则可能导致的问题)
  - [隐含变量](#隐含变量)
    - [关于命令的变量](#关于命令的变量)
    - [关于命令参数的变量](#关于命令参数的变量)
- [其它](#其它)
- [内建的特殊目标](#内建的特殊目标)

# 简单例子
```shell
hello:hello.c                           #目标:源
	gcc -I${HOME}/incl -c hello.c       #预编译
	gcc -o hello hello.o                #链接
	rm -f hello.o                       #删除中间文件
	mv hello ${HOME}/bin                #移动执行文件
```
# Makefile结构说明

Makefile里主要包含了五个东西：变量定义、显式规则、隐晦规则、文件指示和注释。

1. 变量的定义。在Makefile中我们要定义一系列的变量，变量一般都是字符串，这个有点像C语言中的宏，当Makefile被执行时，其中的变量都会被扩展到相应的引用位置上。

2. 显式规则。显式规则说明了，如何生成一个或多的的目标文件。这是由Makefile的书写者明显指出，要生成的文件，文件的依赖文件，生成的命令。 刚才写的疑似shell脚本的Makefile全部都是显示规则。

3. 隐晦规则。由于我们的make有自动推导的功能，所以隐晦的规则可以让我们比较粗糙地简略地书写Makefile，这是由make所支持的。

4. 文件指示。其包括了三个部分，一个是在一个Makefile中引用另一个Makefile，就像C语言中的include一样。

5. 注释。Makefile中只有行注释，和UNIX的Shell脚本一样，其注释是用“#”字符，这个就像C/C++中的“//”一样。如果你要在你的Makefile中使用“#”字符。

# 复杂一些的Makefile
```shell
#隐含规则
INCL=-I${HOME}/incl                 #变量定义
#------------------隐含规则-------------------
.SUFFIXES: .cpp .c
.cpp.o:
	g++ ${INCL} -c $<               #变量使用

.c.o:
	gcc ${INCL} -c $<               # $< 为预定义变量
#--------------------------------------------
#C++编译
hellocpp:hellocpp.o
	echo "开始编译"                 # 隐含规则已经编译，无需再写
	g++ -o hellocpp hellocpp.o
	rm -f hellocpp.o
	mv hellocpp ${HOME}/bin
	echo "编译结束"                 # 增加编译日志

#C编译
hello:hello.o
	echo "开始编译"                 # 隐含规则已经编译，无需再写
	gcc -o hello hello.o
	rm -f hello.o
	mv hello ${HOME}/bin
	echo "编译结束"
```
# 常用的预定义变量。
$* 　　不包含扩展名的目标文件名称。

$+ 　　所有的依赖文件，以空格分开，并以出现的先后为序，可能包含重复的依赖文件。

$< 　　第一个依赖文件的名称。

$? 　　所有的依赖文件，以空格分开，这些依赖文件的修改日期比目标的创建日期晚。

$@ 　 目标的完整名称。

$^ 　　所有的依赖文件，以空格分开，不包含重复的依赖文件。

$% 　　如果目标是归档成员，则该变量表示目标的归档成员名称。

# Makefile 提高版
```sh
#最后形成的Makefile
INCL=-I${HOME}/incl
BIN=$(HOME)/bin
OBJ1=hellocpp.o
OBJ2=hello.o
#----------------隐晦规则-------------------
.SUFFIXES: .cpp .c
.cpp.o:
	g++ ${INCL} -c $<

.c.o:
	gcc ${INCL} -c $<
#-------------------------------------------
all: hellocpp hello                             #新增一个all目标，默认编译all后面所有文件

#C++编译
hellocpp:${OBJ1}
	@echo "============开始编译============"
	g++ -o $@ $?                                # $@ 表示目标，即hellocpp； $? 表示所有依赖，即hellocpp.cpp; 如果依赖多个文件，则全部带上
	@rm -f ${OBJ1}
	@mv $@ ${BIN}
	@echo "============编译结束============"
	@echo ""

#C编译
hello:${OBJ2}
	@echo "============开始编译============"
	gcc -o $@ $?
	@rm -f ${OBJ2}                              #命令前加@，表示当前命令不显示
	@mv $@ ${BIN}
	@echo "============编译结束============"
	@echo ""

```

# 写Makefile的注意事项
1. tab分隔，不能用空格。
2. 每个makefile最好加一个all
3. 注释用“#”符号
4. 文件指示，引用其他的makefile文件

# 隐含规则
## 隐含规则的含义
隐含规则，就是我们做出一些具体的操作后，系统自动推导完成。  
在某些情况下，不需要给出重建目标文件的命令，甚至不需要给出规则。  
比如下面的例子就没有书写重建 test.o 的命令，但是执行 make后，依然重建了 test 和 test.o 文件。这其实就是隐含规则的作用。
```sh
test:test.o
    gcc -o test test.o
test.o:test.c
```
比如下面代码的运行结果与上面是相同的。但注意，隐含条件只能省略中间目标文件重建的命令和规则，但是最终目标的命令和规则不能省略。
```sh
test:test.o
    gcc -o test test.o
```
## 隐含规则的工作流程
make 执行过程中找到的隐含规则，提供了此目标的基本依赖关系，确定了目标的依赖文件和重建目标需要使用的命令行。  

但是隐含规则所提供的依赖文件只是一个基本的文件，比如在C语言中对应关系是test.o 对应 test.c 文件。当需要增加这个文件的依赖文件时，要在 Makefile 中使用没有命令行的规则给出。
```sh
test:test.o
    gcc -o test test.o
test:test1.h   #这是新加的
```
## 隐含规则可能导致的问题
make 有一个“隐含规则库”，库中的每一条隐含规则都有相应的优先级顺序，优先级也就会越高，使用时也就会被优先使用。

我们可以使用 make 的选项-r或-n-builtin-rules，来取消所有的预设值的隐含规则。

## 隐含变量
隐含规则的命令中所使用的变量都是预定义的，我们将这些变量称为“隐含变量”，Makefile 的隐含规则会使用到这些变量。  

比如在 Makefile 中编译 .c 文件，如果规则中没有写任何命令，则采用隐含的规则，即默认使用到的编译命令是CC，默认执行的命令是“CC -c”。我们也可以通过上面三种修改方式之一，将CC重新定义为ncc，这样我们编译 .c 文件的时候就可以用ncc进行编译。

隐含规则中使用的变量可以分成两类：关于命令的变量，关于命令参数的变量。

### 关于命令的变量
```yaml
AR：函数库打包程序，创建静态库 .a，默认命令是ar。
AS：汇编语言编译程序，将编译后的文件汇编成目标文件，默认命令是as。
CC：C编译程序，将预处理后的文件编程成汇编代码，默认命令是cc，而cc又指向gcc。
CXX：C++编译程序，将预处理后的文件编程成汇编代码，默认命令是g++。
CO：从 RCS 中提取文件的程序。
CPP：C程序的预处理器，默认命令是“$(CC) -E”。
LD：链接器，默认的命令是ld。
FC：编译器和与处理函数 Fortran 源文件的编译器。
GET：从CSSC 中提取文件程序。
LEX：将Lex语言转变为 C 或 Ratfo 的程序。
PC：Pascal 语言编译器。
YACC：Yacc 文法分析器（针对于C语言）
YACCR：Yacc 文法分析器。
……
RM：删除文件命令，默认命令是“rm -f”。
MAKE：make工具命令，其值是“make”。
```
### 关于命令参数的变量
下面所列的变量是上面所列的变量的参数，如果没有指明其默认值，则默认值为空。
```yaml
    ARFLAGS，AR命令的参数，默认值是rv。
    ASFLAGS，汇编语言编译程序参数。
    CFLAGS，C语言编译器参数。
    CXXFLAGS，C++语言编译器参数。
    CPPFLAGS，C预处理器参数。
    LDFLAGS，链接器参数。
    MAKEFLAG：执行make时会将make后面所带的参数以一定格式组合，赋值给这个变量。
```

# 其它
shell
```yaml
$(shell pwd)
shell是函数名，后面的pwd是参数，返回的结果赋值给LDIR
```
=
```yaml
# “=” 是最普通的等号，然而在Makefile中确实最容易搞错的赋值等号，使用”=”进行赋值，变量的值是整个makefile中最后被指定的值。
VIR_A = A
VIR_B = $(VIR_A) B
VIR_A = AA

#经过上面的赋值后，最后VIR_B的值是AA B，而不是A B。在make时，会把整个makefile展开，拉通决定变量的值。
```
:=
```yaml
# 相比于前面“最普通”的”=”，”:=”就容易理解多了。”:=”就表示直接赋值，赋予当前位置的值。
VIR_A := A
VIR_B := $(VIR_A) B
VIR_A := AA
# 最后变量VIR_B的值是A B，即根据当前位置进行赋值。因此相比于”=”，”:=”才是真正意义上的直接赋值。
```
?=
```yaml
#“？=”表示如果该变量没有被赋值，则赋予等号后的值。
VIR ?= new_value
```
+=
```yaml
# “+=” 和平时写代码的理解是一样的，表示将等号后面的值添加到前面的变量上
```
vpath
```yaml
#用于定义make的查找路径
vpath %.h include
#表示添加头文件的搜索路径include，其中%表示匹配零个或多个字符。
#多个路径集间用冒号":"分隔。比如 VPATH=include:src
```

Darwin  
由苹果电脑于2000年开发的一个开放原始码操作系统

# 内建的特殊目标
某些名字作为目标存在时有特殊含义。
1. PHONY 该目标的依赖被认为是phony目标，处理这些目标时，命令无条件被执行，不管文件名是否
      存在及其最后修改时间
2. SUFFIXES 该目标的依赖被认为是一个后缀列表，在检查后缀规则时使用
3. DEFAULT 该目标的规则被使用在没有规则（显式的或隐含的）的目标上。如果’DEFAULT’命令定
      义了，则对所有不是规则目标的依赖文件都会执行该组命令
4. PRECIOUS 该目标的依赖文件会受到特别对待：如果make被kill或命令的执行被中止，这些目标并不
      删除；而且如果该目标是中间文件，在不需要时不会被删除。可以将隐含规则的目标模式（如%.o）
      做为’.PRECIOUS’的依赖文件，这样可以保存这些规则产生的中间文件。
5. INTERMEDIATE 该目标的依赖文件被当作中间文件；如果该目标没有依赖文件，则makefile中所有的
      目标文件均被认为是中间文件。
6. IGNORE 在执行该目标的依赖规则的命令时，make会忽略错误，此规则本身的命令没有意义。如果该
      规则没有依赖关系，表示忽略所有命令执行的错误，这种用法只是为了向后兼容；由于会影响到所
      有的命令，所以不是特别有用，推荐使用其它更有选择性忽略错误的方法。
7. SILENT 在执行该目标的依赖规则的命令时，make并不打印命令本身。该规则的命令没有意义。
      在’.SILIENT’没有依赖关系时，表示执行makefile中的所有命令都不会打印，该规则只是为了向
      后兼容提供的。
8. EXPORT_ALL_VARIABLES 只是作为一个目标存在，指示make将所有变量输出到子进程中。
      定义的隐含规则的后缀作为目标时，也认为它是特殊目标；两个后缀的连接也是一样，比
      如’.c.o’。这些目标是后缀规则，一中定义隐式规则的过时方法（但仍然广泛使用）。后缀通常        以’.’开始，
      所以特殊目标也以’.’开始。